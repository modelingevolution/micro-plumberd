using MicroPlumberd.Services;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.Tests.AppSrc;

[EventHandler]
public partial class FooProcessor(IPlumber plumber)
{
    private async Task Given(Metadata m, FooUpdated ev)
    {
        var agg = FooAggregate.New(Guid.NewGuid());
        agg.Open(ev.Name + "new");
        await plumber.SaveNew(agg);
    }
}

[ProcessManager]
public partial class XooProcessManager : IProcessManager, IVersionAware, IIdAware, ITypeRegister
{
    private long _version = -1;
    private Guid _id;
    public Guid Id => _id;
    Guid IIdAware.Id { set => _id = value; }
    public long Version => _version;
    void IVersionAware.Increase() => _version += 1;
    public async Task<ICommandRequest<CreateBoo>> StartWhen(Metadata m, FooCreated ev)
    {
        return CommandRequest.Create("Hello".ToGuid(), new CreateBoo());
    }
    private async Task<ICommandRequest<CreateLoo>> When(Metadata m, BooUpdated ev)
    {
        return CommandRequest.Create(Guid.NewGuid(), new CreateLoo());
    }

    private async Task Given(Metadata m, FooCreated ev)
    {
        // This method is used to rebuild the state;
        // In this example, It is called only When method "When(.., BooUpdated)" is executed.
        // Because the state of the FooProcessManager needs to be rebuilt.
        Console.WriteLine("Given-FooCreated");
    }

    private async Task Given(Metadata m, CommandEnqueued<CreateLoo> ev)
    {
        // This method is optional; It is used to capture the fact, that command was sent to the queue.
        Console.WriteLine("Given-CommandEnqueued<CreateLoo>");
    }


    #region AutoGenerated
    static Type IProcessManager.StartEvent => typeof(FooCreated);

    public static IEnumerable<Type> CommandTypes
    {
        get
        {
            yield return typeof(CommandEnqueued<CreateBoo>);
            yield return typeof(CommandEnqueued<CreateLoo>);
        }
    }

    async Task<ICommandRequest> IProcessManager.StartWhen(Metadata m, object evt) => await StartWhen(m, (FooCreated)evt);
    public async Task<ICommandRequest?> HandleError(ExecutionContext executionContext)
    {
        return null;
    }

    public async Task<ICommandRequest> When(Metadata m, object evt)
    {
        switch (evt)
        {
            case BooUpdated e: return await When(m, e);
            default: return null;
        }
    }
    async Task IEventHandler.Handle(Metadata m, object evt)
    {
        switch (evt)
        {
            case FooCreated e: await Given(m, e); return;
            case CommandEnqueued<CreateLoo> e: await Given(m, e); return;
            default: return;
        }
    }
    #endregion

    private static Dictionary<string, Type> _register = new Dictionary<string, Type>()
    {
        {nameof(FooCreated), typeof(FooCreated)},
        {nameof(BooUpdated), typeof(BooUpdated)},
    };

    static IReadOnlyDictionary<string, Type> ITypeRegister.TypeRegister => _register;
}