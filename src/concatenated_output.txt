


// --- File: Markdown2Toc\Md2TocGenerator.cs ---


using System.Text.RegularExpressions;
using Markdig;
using Markdig.Syntax;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

class Md2TocGenerator
{
    public static async Task Generate(string input, string output, string toc)
    {
        List<TocEntryLeaf> entries = new List<TocEntryLeaf>();
        if (Directory.Exists(input))
        {
            foreach (var i in Directory.EnumerateFiles(input, "*.md", SearchOption.AllDirectories)) 
                entries.AddRange(await ParseMarkdownFile(i));
        }
        else
        {
            var tocEntries = await ParseMarkdownFile(input);
            entries.AddRange(tocEntries);
        }

        if (!string.IsNullOrWhiteSpace(toc))
        {
            var serializer = new DeserializerBuilder()
                .WithNamingConvention(UnderscoredNamingConvention.Instance)
                .Build();
            var toMerge = serializer.Deserialize<List<TocEntryNode>>(await File.ReadAllTextAsync(toc));

            entries.AddRange(toMerge.Select(x=>x.Reduce()));
        }

        
        await GenerateTocFile(entries, output);
    }

    static async Task<List<TocEntryLeaf>> ParseMarkdownFile(string filePath)
    {
        var fileName = Path.GetFileName(filePath);
        var markdown = await File.ReadAllTextAsync(filePath);
        var document = Markdown.Parse(markdown);
        var tocEntries = new List<TocEntryNode>();
        var stack = new Stack<(TocEntryNode entry, int level)>();

        foreach (var node in document.Descendants<HeadingBlock>())
        {
            var level = node.Level;
            var title = node.Inline.FirstChild.ToString();
            var entry = new TocEntryNode
            {
                Name = title,
                Href = $"{fileName}#{GenerateSlug(title)}"
            };

            while (stack.Any() && stack.Peek().level >= level) stack.Pop();

            if (stack.Any())
                stack.Peek().entry.Items.Add(entry);
            else
                tocEntries.Add(entry);

            stack.Push((entry, level));
        }

        return tocEntries.Select(x=>x.Reduce()).ToList();

    }

    static string GenerateSlug(string title)
    {
        string slug = title.ToLower();
        slug = Regex.Replace(slug, @"[^a-z0-9\s-]", ""); // Remove invalid characters
        slug = Regex.Replace(slug, @"\s+", " ").Trim(); // Convert multiple spaces into one space
        slug = slug.Substring(0, slug.Length <= 64 ? slug.Length : 64).Trim(); // Cut and trim
        slug = Regex.Replace(slug, @"\s", "-"); // Replace spaces with hyphens
        return slug;
    }

    static async Task  GenerateTocFile(List<TocEntryLeaf> tocEntries, string filePath)
    {
        var serializer = new SerializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .Build();

        var yaml = serializer.Serialize(tocEntries);

        if (filePath.EndsWith("/"))
            filePath = Path.Combine(filePath, "toc.yml");

        await File.WriteAllTextAsync(filePath, yaml);
    }

    
}


// --- File: Markdown2Toc\Program.cs ---


using System;
using System.Collections;
using System.Collections.Generic;
using System.CommandLine;
using System.IO;
using System.Linq;


class Program
{
    static async Task<int> Main(string[] args)
    {
        var inArg = new Argument<string>("--input-file", description: "Input markdown file(s) path");
        var outArg = new Argument<string>("--output-file", getDefaultValue: () => "./", description: "Output TOC file or directory path");
        var toc = new Option<string>("--toc-file", description: "TOC file to merge");
        var rootCommand = new RootCommand();
        rootCommand.Description = "Simple tool to generate table-of-content yaml files from Markdown files";
        rootCommand.AddArgument(inArg);
        rootCommand.AddArgument(outArg);
        rootCommand.AddOption(toc);
        rootCommand.SetHandler(Md2TocGenerator.Generate, inArg, outArg, toc);

        // Parse the incoming args and invoke the handler
        return await rootCommand.InvokeAsync(args);
    }

    
}



// --- File: Markdown2Toc\TocEntryLeaf.cs ---


class TocEntryLeaf
{
    public virtual string Name { get; set; }
    public virtual string Href { get; set; }
}


// --- File: Markdown2Toc\TocEntryNode.cs ---


class TocEntryNode : TocEntryLeaf
{
    private readonly TocEntryLeaf _n;

    public TocEntryNode()
    {
        _n = new TocEntryLeaf();
    }
    public TocEntryNode(TocEntryLeaf n)
    {
        _n = n;
    }

    public TocEntryLeaf Reduce()
    {
        if (Items.Count == 0) return _n;

        for (var index = 0; index < Items.Count; index++)
        {
            var i = Items[index];
            if (i is TocEntryNode n)
                Items[index] = n.Reduce();
        }
        return this;
    }

    public override string Href
    {
        get => _n.Href;
        set => _n.Href = value;
    }

    public override string Name
    {
        get => _n.Name;
        set => _n.Name = value;
    }
    public List<TocEntryLeaf> Items { get; } = new List<TocEntryLeaf>();
}


// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\_Imports.razor ---


@layout ManageLayout
@attribute [Microsoft.AspNetCore.Authorization.Authorize]



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\ChangePassword.razor ---


@page "/Account/Manage/ChangePassword"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ChangePassword> Logger

<PageTitle>Change password</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Change password</MudText>

<StatusMessage Message="@message" />

<EditForm Model="Input" FormName="change-password" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.OldPassword)" @bind-Value="Input.OldPassword" InputType="InputType.Password"
                                Label="Old Password" Placeholder="old password" HelperText="Please enter your old password."
                                UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.NewPassword)" @bind-Value="Input.NewPassword" InputType="InputType.Password"
                                Label="New Password" Placeholder="new password" HelperText="Please enter your new password."
                                UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.ConfirmPassword)" @bind-Value="Input.ConfirmPassword" InputType="InputType.Password"
                                Label="Confirm Password" Placeholder="confirm password" HelperText="Please confirm your new password."
                                UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Update password</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private bool hasPassword;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        hasPassword = await UserManager.HasPasswordAsync(user);
        if (!hasPassword)
        {
            RedirectManager.RedirectTo("Account/Manage/SetPassword");
        }
    }

    private async Task OnValidSubmitAsync()
    {
        var changePasswordResult = await UserManager.ChangePasswordAsync(user, Input.OldPassword, Input.NewPassword);
        if (!changePasswordResult.Succeeded)
        {
            message = $"Error: {string.Join(",", changePasswordResult.Errors.Select(error => error.Description))}";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        Logger.LogInformation("User changed their password successfully.");

        RedirectManager.RedirectToCurrentPageWithStatus("Your password has been changed", HttpContext);
    }

    private sealed class InputModel
    {
        [Required]
        [DataType(DataType.Password)]
        [Display(Name = "Current password")]
        public string OldPassword { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "New password")]
        public string NewPassword { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm new password")]
        [Compare("NewPassword", ErrorMessage = "The new password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\DeletePersonalData.razor ---


@page "/Account/Manage/DeletePersonalData"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<DeletePersonalData> Logger

<PageTitle>Delete Personal Data</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Delete personal data</MudText>

<StatusMessage Message="@message" />

<MudAlert Severity="Severity.Error" Variant="Variant.Text">
    Deleting this data will permanently remove your account, and this cannot be recovered.
</MudAlert>

<EditForm Model="Input" FormName="delete-user" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />

    <MudGrid>
        @if (requirePassword)
        {
            <MudItem md="12">
                <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password" InputType="InputType.Password"
                                    Label="Password" Placeholder="password" HelperText="Please enter your new password."
                                    UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } } )" />
            </MudItem>
        }
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Delete data and close my account</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private bool requirePassword;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        Input ??= new();
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        requirePassword = await UserManager.HasPasswordAsync(user);
    }

    private async Task OnValidSubmitAsync()
    {
        if (requirePassword && !await UserManager.CheckPasswordAsync(user, Input.Password))
        {
            message = "Error: Incorrect password.";
            return;
        }

        var result = await UserManager.DeleteAsync(user);
        if (!result.Succeeded)
        {
            throw new InvalidOperationException("Unexpected error occurred deleting user.");
        }

        await SignInManager.SignOutAsync();

        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' deleted themselves.", userId);

        RedirectManager.RedirectToCurrentPage();
    }

    private sealed class InputModel
    {
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\Disable2fa.razor ---


@page "/Account/Manage/Disable2fa"

@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<Disable2fa> Logger

<PageTitle>Disable two-factor authentication (2FA)</PageTitle>

<StatusMessage />
<h3>Disable two-factor authentication (2FA)</h3>

<div class="alert alert-warning" role="alert">
    <p>
        <strong>This action only disables 2FA.</strong>
    </p>
    <p>
        Disabling 2FA does not change the keys used in authenticator apps. If you wish to change the key
        used in an authenticator app you should <a href="Account/Manage/ResetAuthenticator">reset your authenticator keys.</a>
    </p>
</div>

<div>
    <form @formname="disable-2fa" @onsubmit="OnSubmitAsync" method="post">
        <AntiforgeryToken />
        <button class="btn btn-danger" type="submit">Disable 2FA</button>
    </form>
</div>

@code {
    private ApplicationUser user = default!;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        if (HttpMethods.IsGet(HttpContext.Request.Method) && !await UserManager.GetTwoFactorEnabledAsync(user))
        {
            throw new InvalidOperationException("Cannot disable 2FA for user as it's not currently enabled.");
        }
    }

    private async Task OnSubmitAsync()
    {
        var disable2faResult = await UserManager.SetTwoFactorEnabledAsync(user, false);
        if (!disable2faResult.Succeeded)
        {
            throw new InvalidOperationException("Unexpected error occurred disabling 2FA.");
        }

        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has disabled 2fa.", userId);
        RedirectManager.RedirectToWithStatus(
            "Account/Manage/TwoFactorAuthentication",
            "2fa has been disabled. You can reenable 2fa when you setup an authenticator app",
            HttpContext);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\Email.razor ---


@page "/Account/Manage/Email"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject IdentityUserAccessor UserAccessor
@inject NavigationManager NavigationManager

<PageTitle>Manage email</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Manage email</MudText>

<StatusMessage Message="@message" />

<form @onsubmit="OnSendEmailVerificationAsync" @formname="send-verification" id="send-verification-form" method="post">
    <AntiforgeryToken />
</form>
<EditForm Model="Input" FormName="change-email" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />

    <MudGrid>

        @if (isEmailConfirmed)
        {
            <MudItem md="12">
                <MudStaticTextField Value="@email" Label="Email" Placeholder="Please enter your email." Disabled="true" AdornmentIcon="Icons.Material.Filled.Check" AdornmentColor="Color.Success" />
            </MudItem>
        }
        else
        {
            <MudItem md="12">
                <MudStaticTextField Value="@email" Label="Email" Placeholder="Please enter your email." Disabled="true" />
            </MudItem>
            <MudItem md="12">
                <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Send verification email</MudStaticButton>
            </MudItem>
        }

        <MudItem md="12">
            <MudStaticTextField @bind-Value="@Input.NewEmail" For="@(() => Input.NewEmail)" UserAttributes="@(new() { { "autocomplete", "email" }, { "aria-required", "true" } } )" Label="New Email" HelperText="Please enter new email." />
        </MudItem>

        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Change email</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;
    private ApplicationUser user = default!;
    private string? email;
    private bool isEmailConfirmed;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm(FormName = "change-email")]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        email = await UserManager.GetEmailAsync(user);
        isEmailConfirmed = await UserManager.IsEmailConfirmedAsync(user);

        Input.NewEmail ??= email;
    }

    private async Task OnValidSubmitAsync()
    {
        if (Input.NewEmail is null || Input.NewEmail == email)
        {
            message = "Your email is unchanged.";
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateChangeEmailTokenAsync(user, Input.NewEmail);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmailChange").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["email"] = Input.NewEmail, ["code"] = code });

        await EmailSender.SendConfirmationLinkAsync(user, Input.NewEmail, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Confirmation link to change email sent. Please check your email.";
    }

    private async Task OnSendEmailVerificationAsync()
    {
        if (email is null)
        {
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });

        await EmailSender.SendConfirmationLinkAsync(user, email, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Verification email sent. Please check your email.";
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "New email")]
        public string? NewEmail { get; set; }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\EnableAuthenticator.razor ---


@page "/Account/Manage/EnableAuthenticator"

@using System.ComponentModel.DataAnnotations
@using System.Globalization
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject UrlEncoder UrlEncoder
@inject IdentityRedirectManager RedirectManager
@inject ILogger<EnableAuthenticator> Logger

<PageTitle>Configure authenticator app</PageTitle>

@if (recoveryCodes is not null)
{
    <ShowRecoveryCodes RecoveryCodes="recoveryCodes.ToArray()" StatusMessage="@message" />
}
else
{
    <MudText Typo="Typo.h6" GutterBottom="true">Configure authenticator app</MudText>

    <StatusMessage Message="@message" />

    <MudText Typo="Typo.body1" GutterBottom="true">To use an authenticator app go through the following steps:</MudText>

    <ol class="list">
        <li>
            <MudText Typo="Typo.body2">
                Download a two-factor authenticator app like Microsoft Authenticator for
                <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=825072">Android</MudLink> and
                <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=825073">iOS</MudLink> or
                Google Authenticator for
                <MudLink Target="_blank" Href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en">Android</MudLink> and
                <MudLink Target="_blank" Href="https://itunes.apple.com/us/app/google-authenticator/id388497605?mt=8">iOS</MudLink>.
            </MudText>
        </li>
        <li>
            <MudText Typo="Typo.body2">
                Scan the QR Code or enter this key into your two factor authenticator app. Spaces and casing do not matter:
            </MudText>

            <MudAlert Variant="Variant.Text" Severity="Severity.Info" Icon="@Icons.Material.Filled.Key">@sharedKey</MudAlert>

            <MudText Typo="Typo.body2">
                Learn how to <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?Linkid=852423">enable QR code generation</MudLink>.
            </MudText>

            <div data-url="@authenticatorUri"></div>
        </li>
        <li>
            <MudText Typo="Typo.body2">
                Once you have scanned the QR code or input the key above, your two factor authentication app will provide you
                with a unique code. Enter the code in the confirmation box below.
            </MudText>

            <EditForm Model="Input" FormName="send-code" OnValidSubmit="OnValidSubmitAsync" method="post">
                <DataAnnotationsValidator />
                <MudGrid>
                    <MudItem md="12">
                        <MudStaticTextField @bind-Value="@Input.Code" For="@(() => Input.Code)" Label="Verification Code" HelperText="Please enter the code." />
                    </MudItem>
                    <MudItem md="12">
                        <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Verify</MudStaticButton>
                    </MudItem>
                </MudGrid>
            </EditForm>
        </li>
    </ol>
}

@code {
    private const string AuthenticatorUriFormat = "otpauth://totp/{0}:{1}?secret={2}&issuer={0}&digits=6";

    private string? message;
    private ApplicationUser user = default!;
    private string? sharedKey;
    private string? authenticatorUri;
    private IEnumerable<string>? recoveryCodes;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        await LoadSharedKeyAndQrCodeUriAsync(user);
    }

    private async Task OnValidSubmitAsync()
    {
        // Strip spaces and hyphens
        var verificationCode = Input.Code.Replace(" ", string.Empty).Replace("-", string.Empty);

        var is2faTokenValid = await UserManager.VerifyTwoFactorTokenAsync(
            user, UserManager.Options.Tokens.AuthenticatorTokenProvider, verificationCode);

        if (!is2faTokenValid)
        {
            message = "Error: Verification code is invalid.";
            return;
        }

        await UserManager.SetTwoFactorEnabledAsync(user, true);
        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has enabled 2FA with an authenticator app.", userId);

        message = "Your authenticator app has been verified.";

        if (await UserManager.CountRecoveryCodesAsync(user) == 0)
        {
            recoveryCodes = await UserManager.GenerateNewTwoFactorRecoveryCodesAsync(user, 10);
        }
        else
        {
            RedirectManager.RedirectToWithStatus("Account/Manage/TwoFactorAuthentication", message, HttpContext);
        }
    }

    private async ValueTask LoadSharedKeyAndQrCodeUriAsync(ApplicationUser user)
    {
        // Load the authenticator key & QR code URI to display on the form
        var unformattedKey = await UserManager.GetAuthenticatorKeyAsync(user);
        if (string.IsNullOrEmpty(unformattedKey))
        {
            await UserManager.ResetAuthenticatorKeyAsync(user);
            unformattedKey = await UserManager.GetAuthenticatorKeyAsync(user);
        }

        sharedKey = FormatKey(unformattedKey!);

        var email = await UserManager.GetEmailAsync(user);
        authenticatorUri = GenerateQrCodeUri(email!, unformattedKey!);
    }

    private string FormatKey(string unformattedKey)
    {
        var result = new StringBuilder();
        int currentPosition = 0;
        while (currentPosition + 4 < unformattedKey.Length)
        {
            result.Append(unformattedKey.AsSpan(currentPosition, 4)).Append(' ');
            currentPosition += 4;
        }
        if (currentPosition < unformattedKey.Length)
        {
            result.Append(unformattedKey.AsSpan(currentPosition));
        }

        return result.ToString().ToLowerInvariant();
    }

    private string GenerateQrCodeUri(string email, string unformattedKey)
    {
        return string.Format(
            CultureInfo.InvariantCulture,
            AuthenticatorUriFormat,
            UrlEncoder.Encode("Microsoft.AspNetCore.Identity.UI"),
            UrlEncoder.Encode(email),
            unformattedKey);
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(7, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Text)]
        [Display(Name = "Verification Code")]
        public string Code { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\ExternalLogins.razor ---


@page "/Account/Manage/ExternalLogins"

@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IUserStore<ApplicationUser> UserStore
@inject IdentityRedirectManager RedirectManager

<PageTitle>Manage your external logins</PageTitle>

<StatusMessage />
@if (currentLogins?.Count > 0)
{
    <h3>Registered Logins</h3>
    <table class="table">
        <tbody>
            @foreach (var login in currentLogins)
            {
                <tr>
                    <td>@login.ProviderDisplayName</td>
                    <td>
                        @if (showRemoveButton)
                        {
                            <form @formname="@($"remove-login-{login.LoginProvider}")" @onsubmit="OnSubmitAsync" method="post">
                                <AntiforgeryToken />
                                <div>
                                    <input type="hidden" name="@nameof(LoginProvider)" value="@login.LoginProvider" />
                                    <input type="hidden" name="@nameof(ProviderKey)" value="@login.ProviderKey" />
                                    <button type="submit" class="btn btn-primary" title="Remove this @login.ProviderDisplayName login from your account">Remove</button>
                                </div>
                            </form>
                        }
                        else
                        {
                            @: &nbsp;
                        }
                    </td>
                </tr>
            }
        </tbody>
    </table>
}
@if (otherLogins?.Count > 0)
{
    <h4>Add another service to log in.</h4>
    <MudDivider />
    <form class="form-horizontal" action="Account/Manage/LinkExternalLogin" method="post">
        <AntiforgeryToken />
        <div>
            <p>
                @foreach (var provider in otherLogins)
                {
                    <button type="submit" class="btn btn-primary" name="Provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">
                        @provider.DisplayName
                    </button>
                }
            </p>
        </div>
    </form>
}

@code {
    public const string LinkLoginCallbackAction = "LinkLoginCallback";

    private ApplicationUser user = default!;
    private IList<UserLoginInfo>? currentLogins;
    private IList<AuthenticationScheme>? otherLogins;
    private bool showRemoveButton;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private string? LoginProvider { get; set; }

    [SupplyParameterFromForm]
    private string? ProviderKey { get; set; }

    [SupplyParameterFromQuery]
    private string? Action { get; set; }

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        currentLogins = await UserManager.GetLoginsAsync(user);
        otherLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync())
            .Where(auth => currentLogins.All(ul => auth.Name != ul.LoginProvider))
            .ToList();

        string? passwordHash = null;
        if (UserStore is IUserPasswordStore<ApplicationUser> userPasswordStore)
        {
            passwordHash = await userPasswordStore.GetPasswordHashAsync(user, HttpContext.RequestAborted);
        }

        showRemoveButton = passwordHash is not null || currentLogins.Count > 1;

        if (HttpMethods.IsGet(HttpContext.Request.Method) && Action == LinkLoginCallbackAction)
        {
            await OnGetLinkLoginCallbackAsync();
        }
    }

    private async Task OnSubmitAsync()
    {
        var result = await UserManager.RemoveLoginAsync(user, LoginProvider!, ProviderKey!);
        if (!result.Succeeded)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: The external login was not removed.", HttpContext);
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("The external login was removed.", HttpContext);
    }

    private async Task OnGetLinkLoginCallbackAsync()
    {
        var userId = await UserManager.GetUserIdAsync(user);
        var info = await SignInManager.GetExternalLoginInfoAsync(userId);
        if (info is null)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: Could not load external login info.", HttpContext);
        }

        var result = await UserManager.AddLoginAsync(user, info);
        if (!result.Succeeded)
        {
            RedirectManager.RedirectToCurrentPageWithStatus("Error: The external login was not added. External logins can only be associated with one account.", HttpContext);
        }

        // Clear the existing external cookie to ensure a clean login process
        await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);

        RedirectManager.RedirectToCurrentPageWithStatus("The external login was added.", HttpContext);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\GenerateRecoveryCodes.razor ---


@page "/Account/Manage/GenerateRecoveryCodes"

@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<GenerateRecoveryCodes> Logger

<PageTitle>Generate two-factor authentication (2FA) recovery codes</PageTitle>

@if (recoveryCodes is not null)
{
    <ShowRecoveryCodes RecoveryCodes="recoveryCodes.ToArray()" StatusMessage="@message" />
}
else
{
    <h3>Generate two-factor authentication (2FA) recovery codes</h3>
    <div class="alert alert-warning" role="alert">
        <p>
            <span class="glyphicon glyphicon-warning-sign"></span>
            <strong>Put these codes in a safe place.</strong>
        </p>
        <p>
            If you lose your device and don't have the recovery codes you will lose access to your account.
        </p>
        <p>
            Generating new recovery codes does not change the keys used in authenticator apps. If you wish to change the key
            used in an authenticator app you should <a href="Account/Manage/ResetAuthenticator">reset your authenticator keys.</a>
        </p>
    </div>
    <div>
        <form @formname="generate-recovery-codes" @onsubmit="OnSubmitAsync" method="post">
            <AntiforgeryToken />
            <button class="btn btn-danger" type="submit">Generate Recovery Codes</button>
        </form>
    </div>
}

@code {
    private string? message;
    private ApplicationUser user = default!;
    private IEnumerable<string>? recoveryCodes;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        var isTwoFactorEnabled = await UserManager.GetTwoFactorEnabledAsync(user);
        if (!isTwoFactorEnabled)
        {
            throw new InvalidOperationException("Cannot generate recovery codes for user because they do not have 2FA enabled.");
        }
    }

    private async Task OnSubmitAsync()
    {
        var userId = await UserManager.GetUserIdAsync(user);
        recoveryCodes = await UserManager.GenerateNewTwoFactorRecoveryCodesAsync(user, 10);
        message = "You have generated new recovery codes.";

        Logger.LogInformation("User with ID '{UserId}' has generated new 2FA recovery codes.", userId);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\Index.razor ---


@page "/Account/Manage"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Profile</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Profile</MudText>

<StatusMessage />

<EditForm Model="Input" FormName="profile" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField Value="@username" Label="Username" Disabled="true" Placeholder="Please choose your username." />
        </MudItem>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.PhoneNumber)" @bind-Value="Input.PhoneNumber"
                                Label="Phone Number" HelperText="Please enter your phone number."
                                UserAttributes="@(new() { { "autocomplete", "tel-national" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Save</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private ApplicationUser user = default!;
    private string? username;
    private string? phoneNumber;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        username = await UserManager.GetUserNameAsync(user);
        phoneNumber = await UserManager.GetPhoneNumberAsync(user);

        Input.PhoneNumber ??= phoneNumber;
    }

    private async Task OnValidSubmitAsync()
    {
        if (Input.PhoneNumber != phoneNumber)
        {
            var setPhoneResult = await UserManager.SetPhoneNumberAsync(user, Input.PhoneNumber);
            if (!setPhoneResult.Succeeded)
            {
                RedirectManager.RedirectToCurrentPageWithStatus("Error: Failed to set phone number.", HttpContext);
            }
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("Your profile has been updated", HttpContext);
    }

    private sealed class InputModel
    {
        [Phone]
        [Display(Name = "Phone number")]
        public string? PhoneNumber { get; set; }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\PersonalData.razor ---


@page "/Account/Manage/PersonalData"

@inject IdentityUserAccessor UserAccessor

<PageTitle>Personal Data</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Personal data</MudText>

<StatusMessage />

<MudGrid>
    <MudItem md="12">
        <MudText Typo="Typo.body1">
            Your account contains personal data that you have given us. This page allows you to download or delete that data.
        </MudText>
    </MudItem>
    <MudItem md="12">
        <MudAlert Severity="Severity.Warning" Variant="Variant.Text">
            Deleting this data will permanently remove your account, and this cannot be recovered.
        </MudAlert>
    </MudItem>
    <MudItem md="12">
        <form action="Account/Manage/DownloadPersonalData" method="post">
            <AntiforgeryToken />
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Download</MudStaticButton>
        </form>
    </MudItem>
    <MudItem md="12">
        <MudLink Href="Account/Manage/DeletePersonalData" Color="Color.Error">Delete</MudLink>
    </MudItem>
</MudGrid>

@code {
    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        _ = await UserAccessor.GetRequiredUserAsync(HttpContext);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\ResetAuthenticator.razor ---


@page "/Account/Manage/ResetAuthenticator"

@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ResetAuthenticator> Logger

<PageTitle>Reset authenticator key</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Reset authenticator key</MudText>

<StatusMessage />

<MudAlert Severity="Severity.Warning" Variant="Variant.Text">
    If you reset your authenticator key your authenticator app will not work until you reconfigure it.
</MudAlert>

<MudText Typo="Typo.body2" Class="my-4">
    This process disables 2FA until you verify your authenticator app.
    If you do not complete your authenticator app configuration you may lose access to your account.
</MudText>

<form @formname="reset-authenticator" @onsubmit="OnSubmitAsync" method="post">
    <AntiforgeryToken />

    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Reset authenticator key</MudStaticButton>
</form>

@code {
    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    private async Task OnSubmitAsync()
    {
        var user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        await UserManager.SetTwoFactorEnabledAsync(user, false);
        await UserManager.ResetAuthenticatorKeyAsync(user);
        var userId = await UserManager.GetUserIdAsync(user);
        Logger.LogInformation("User with ID '{UserId}' has reset their authentication app key.", userId);

        await SignInManager.RefreshSignInAsync(user);

        RedirectManager.RedirectToWithStatus(
            "Account/Manage/EnableAuthenticator",
            "Your authenticator app key has been reset, you will need to configure your authenticator app using the new key.",
            HttpContext);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\SetPassword.razor ---


@page "/Account/Manage/SetPassword"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Set password</PageTitle>

<h3>Set your password</h3>
<StatusMessage Message="@message" />
<p class="text-info">
    You do not have a local username/password for this site. Add a local
    account so you can log in without an external login.
</p>
<div class="row">
    <div class="col-xl-6">
        <EditForm Model="Input" FormName="set-password" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" role="alert" />
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.NewPassword" id="Input.NewPassword" class="form-control" autocomplete="new-password" placeholder="Enter the new password" />
                <label for="Input.NewPassword" class="form-label">New password</label>
                <ValidationMessage For="() => Input.NewPassword" class="text-danger" />
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.ConfirmPassword" id="Input.ConfirmPassword" class="form-control" autocomplete="new-password" placeholder="Enter the new password" />
                <label for="Input.ConfirmPassword" class="form-label">Confirm password</label>
                <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger" />
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Set password</button>
        </EditForm>
     </div>
</div>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        user = await UserAccessor.GetRequiredUserAsync(HttpContext);

        var hasPassword = await UserManager.HasPasswordAsync(user);
        if (hasPassword)
        {
            RedirectManager.RedirectTo("Account/Manage/ChangePassword");
        }
    }

    private async Task OnValidSubmitAsync()
    {
        var addPasswordResult = await UserManager.AddPasswordAsync(user, Input.NewPassword!);
        if (!addPasswordResult.Succeeded)
        {
            message = $"Error: {string.Join(",", addPasswordResult.Errors.Select(error => error.Description))}";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        RedirectManager.RedirectToCurrentPageWithStatus("Your password has been set.", HttpContext);
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "New password")]
        public string? NewPassword { get; set; }

        [DataType(DataType.Password)]
        [Display(Name = "Confirm new password")]
        [Compare("NewPassword", ErrorMessage = "The new password and confirmation password do not match.")]
        public string? ConfirmPassword { get; set; }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Manage\TwoFactorAuthentication.razor ---


@page "/Account/Manage/TwoFactorAuthentication"

@using Microsoft.AspNetCore.Http.Features
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityUserAccessor UserAccessor
@inject IdentityRedirectManager RedirectManager

<PageTitle>Two-factor authentication (2FA)</PageTitle>

<MudText Typo="Typo.h6" GutterBottom="true">Two-factor authentication (2FA)</MudText>

<StatusMessage />

@if (canTrack)
{
    if (is2faEnabled)
    {
        if (recoveryCodesLeft == 0)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Error">You have no recovery codes left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You must <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>
                before you can log in with a recovery code.
            </MudText>
        }
        else if (recoveryCodesLeft == 1)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Warning">You have 1 recovery code left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You can <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>.
            </MudText>
        }
        else if (recoveryCodesLeft <= 3)
        {
            <MudAlert Variant="Variant.Text" Severity="Severity.Warning">You have @recoveryCodesLeft recovery codes left.</MudAlert>

            <MudText Typo="Typo.body1" Class="pt-4">
                You should <MudLink Href="Account/Manage/GenerateRecoveryCodes">generate a new set of recovery codes</MudLink>.
            </MudText>
        }

        if (isMachineRemembered)
        {
            <form style="display: inline-block" @formname="forget-browser" @onsubmit="OnSubmitForgetBrowserAsync" method="post">
                <AntiforgeryToken />
                
                <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Forget this browser</MudStaticButton>
            </form>
        }

        <MudLink Href="Account/Manage/Disable2fa">Disable 2FA</MudLink><br />
        <MudLink Href="Account/Manage/GenerateRecoveryCodes">Reset recovery codes</MudLink>
    }

    <MudText Typo="Typo.h6" GutterBottom="true">Authenticator app</MudText>

    @if (!hasAuthenticator)
    {
        <MudLink Href="Account/Manage/EnableAuthenticator">Add authenticator app</MudLink><br />
    }
    else
    {
        <MudLink Href="Account/Manage/EnableAuthenticator">Set up authenticator app</MudLink><br />
        <MudLink Href="Account/Manage/ResetAuthenticator">Reset authenticator app</MudLink>
    }
}
else
{
    <MudAlert Variant="Variant.Text" Severity="Severity.Error">Privacy and cookie policy have not been accepted.</MudAlert>

    <MudText Typo="Typo.body1" Class="pt-4">
        You must accept the policy before you can enable two factor authentication.
    </MudText>
}

@code {
    private bool canTrack;
    private bool hasAuthenticator;
    private int recoveryCodesLeft;
    private bool is2faEnabled;
    private bool isMachineRemembered;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    protected override async Task OnInitializedAsync()
    {
        var user = await UserAccessor.GetRequiredUserAsync(HttpContext);
        canTrack = HttpContext.Features.Get<ITrackingConsentFeature>()?.CanTrack ?? true;
        hasAuthenticator = await UserManager.GetAuthenticatorKeyAsync(user) is not null;
        is2faEnabled = await UserManager.GetTwoFactorEnabledAsync(user);
        isMachineRemembered = await SignInManager.IsTwoFactorClientRememberedAsync(user);
        recoveryCodesLeft = await UserManager.CountRecoveryCodesAsync(user);
    }

    private async Task OnSubmitForgetBrowserAsync()
    {
        await SignInManager.ForgetTwoFactorClientAsync();

        RedirectManager.RedirectToCurrentPageWithStatus(
            "The current browser has been forgotten. When you login again from this browser you will be prompted for your 2fa code.",
            HttpContext);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\_Imports.razor ---


@using MudBlazor
@using MicroPluberd.Examples.Blazor.Identity.Components.Account.Shared
@attribute [ExcludeFromInteractiveRouting]



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\AccessDenied.razor ---


@page "/Account/AccessDenied"

<PageTitle>Access denied</PageTitle>

<MudAlert Severity="Severity.Error">You do not have access to this resource.</MudAlert>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ConfirmEmail.razor ---


@page "/Account/ConfirmEmail"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Confirm email</PageTitle>

<h1>Confirm email</h1>
<StatusMessage Message="@statusMessage" />

@code {
    private string? statusMessage;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery]
    private string? UserId { get; set; }

    [SupplyParameterFromQuery]
    private string? Code { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (UserId is null || Code is null)
        {
            RedirectManager.RedirectTo("");
        }

        var user = await UserManager.FindByIdAsync(UserId);
        if (user is null)
        {
            HttpContext.Response.StatusCode = StatusCodes.Status404NotFound;
            statusMessage = $"Error loading user with ID {UserId}";
        }
        else
        {
            var code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
            var result = await UserManager.ConfirmEmailAsync(user, code);
            statusMessage = result.Succeeded ? "Thank you for confirming your email." : "Error confirming your email.";
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ConfirmEmailChange.razor ---


@page "/Account/ConfirmEmailChange"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Confirm email change</PageTitle>

<h1>Confirm email change</h1>

<StatusMessage Message="@message" />

@code {
    private string? message;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery]
    private string? UserId { get; set; }

    [SupplyParameterFromQuery]
    private string? Email { get; set; }

    [SupplyParameterFromQuery]
    private string? Code { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (UserId is null || Email is null || Code is null)
        {
            RedirectManager.RedirectToWithStatus(
                "Account/Login", "Error: Invalid email change confirmation link.", HttpContext);
        }

        var user = await UserManager.FindByIdAsync(UserId);
        if (user is null)
        {
            message = "Unable to find user with Id '{userId}'";
            return;
        }

        var code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
        var result = await UserManager.ChangeEmailAsync(user, Email, code);
        if (!result.Succeeded)
        {
            message = "Error changing email.";
            return;
        }

        // In our UI email and user name are one and the same, so when we update the email
        // we need to update the user name.
        var setUserNameResult = await UserManager.SetUserNameAsync(user, Email);
        if (!setUserNameResult.Succeeded)
        {
            message = "Error changing user name.";
            return;
        }

        await SignInManager.RefreshSignInAsync(user);
        message = "Thank you for confirming your email change.";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ExternalLogin.razor ---


@page "/Account/ExternalLogin"

@using System.ComponentModel.DataAnnotations
@using System.Security.Claims
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IUserStore<ApplicationUser> UserStore
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ExternalLogin> Logger

<PageTitle>Register</PageTitle>

<StatusMessage Message="@message" />
<h1>Register</h1>
<h2>Associate your @ProviderDisplayName account.</h2>
<MudDivider />

<div  class="alert alert-info">
    You've successfully authenticated with <strong>@ProviderDisplayName</strong>.
    Please enter an email address for this site below and click the Register button to finish
    logging in.
</div>

<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" OnValidSubmit="OnValidSubmitAsync" FormName="confirmation" method="post">
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" role="alert" />
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.Email" id="Input.Email" class="form-control" autocomplete="email" placeholder="Please enter your email." />
                <label for="Input.Email" class="form-label">Email</label>
                <ValidationMessage For="() => Input.Email" />
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Register</button>
        </EditForm>
    </div>
</div>

@code {
    public const string LoginCallbackAction = "LoginCallback";

    private string? message;
    private ExternalLoginInfo? externalLoginInfo;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? RemoteError { get; set; }

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery]
    private string? Action { get; set; }

    private string? ProviderDisplayName => externalLoginInfo?.ProviderDisplayName;

    protected override async Task OnInitializedAsync()
    {
        if (RemoteError is not null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", $"Error from external provider: {RemoteError}", HttpContext);
        }

        var info = await SignInManager.GetExternalLoginInfoAsync();
        if (info is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information.", HttpContext);
        }

        externalLoginInfo = info;

        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            if (Action == LoginCallbackAction)
            {
                await OnLoginCallbackAsync();
                return;
            }

            // We should only reach this page via the login callback, so redirect back to
            // the login page if we get here some other way.
            RedirectManager.RedirectTo("Account/Login");
        }
    }

    private async Task OnLoginCallbackAsync()
    {
        if (externalLoginInfo is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information.", HttpContext);
        }

        // Sign in the user with this external login provider if the user already has a login.
        var result = await SignInManager.ExternalLoginSignInAsync(
            externalLoginInfo!.LoginProvider,
            externalLoginInfo!.ProviderKey,
            isPersistent: false,
            bypassTwoFactor: true);

        if (result.Succeeded)
        {
            Logger.LogInformation(
                "{Name} logged in with {LoginProvider} provider.",
                externalLoginInfo.Principal.Identity?.Name,
                externalLoginInfo.LoginProvider);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            RedirectManager.RedirectTo("Account/Lockout");
        }

        // If the user does not have an account, then ask the user to create an account.
        if (externalLoginInfo.Principal.HasClaim(c => c.Type == ClaimTypes.Email))
        {
            Input.Email = externalLoginInfo.Principal.FindFirstValue(ClaimTypes.Email) ?? "";
        }
    }

    private async Task OnValidSubmitAsync()
    {
        if (externalLoginInfo is null)
        {
            RedirectManager.RedirectToWithStatus("Account/Login", "Error loading external login information during confirmation.", HttpContext);
        }

        var emailStore = GetEmailStore();
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);

        var result = await UserManager.CreateAsync(user);
        if (result.Succeeded)
        {
            result = await UserManager.AddLoginAsync(user, externalLoginInfo);
            if (result.Succeeded)
            {
                Logger.LogInformation("User created an account using {Name} provider.", externalLoginInfo.LoginProvider);

                var userId = await UserManager.GetUserIdAsync(user);
                var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
                code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

                var callbackUrl = NavigationManager.GetUriWithQueryParameters(
                    NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
                    new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });
                await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

                // If account confirmation is required, we need to show the link if we don't have a real email sender
                if (UserManager.Options.SignIn.RequireConfirmedAccount)
                {
                    RedirectManager.RedirectTo("Account/RegisterConfirmation", new() { ["email"] = Input.Email });
                }

                await SignInManager.SignInAsync(user, isPersistent: false, externalLoginInfo.LoginProvider);
                RedirectManager.RedirectTo(ReturnUrl);
            }
        }

        message = $"Error: {string.Join(",", result.Errors.Select(error => error.Description))}";
    }

    private static ApplicationUser CreateUser()
    {
        try
        {
            return Activator.CreateInstance<ApplicationUser>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(ApplicationUser)}'. " +
                $"Ensure that '{nameof(ApplicationUser)}' is not an abstract class and has a parameterless constructor");
        }
    }

    private IUserEmailStore<ApplicationUser> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }
        return (IUserEmailStore<ApplicationUser>)UserStore;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ForgotPassword.razor ---


@page "/Account/ForgotPassword"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Forgot your password?</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Forgot your password?</MudText>
<MudText Typo="Typo.body1" GutterBottom="true">Enter your email.</MudText>

<EditForm Model="Input" FormName="forgot-password" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />


    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField @bind-Value="Input.Email" For="@(() => Input.Email)" 
                                Label="Email" Placeholder="name@example.com"
                                UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Reset password</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email);
        if (user is null || !(await UserManager.IsEmailConfirmedAsync(user)))
        {
            // Don't reveal that the user does not exist or is not confirmed
            RedirectManager.RedirectTo("Account/ForgotPasswordConfirmation");
        }

        // For more information on how to enable account confirmation and password reset please
        // visit https://go.microsoft.com/fwlink/?LinkID=532713
        var code = await UserManager.GeneratePasswordResetTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ResetPassword").AbsoluteUri,
            new Dictionary<string, object?> { ["code"] = code });

        await EmailSender.SendPasswordResetLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        RedirectManager.RedirectTo("Account/ForgotPasswordConfirmation");
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ForgotPasswordConfirmation.razor ---


@page "/Account/ForgotPasswordConfirmation"

<PageTitle>Forgot password confirmation</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Forgot password confirmation</MudText>

<MudText Typo="Typo.body1" GutterBottom="true">Please check your email to reset your password.</MudText>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\InvalidPasswordReset.razor ---


@page "/Account/InvalidPasswordReset"

<PageTitle>Invalid password reset</PageTitle>

<h1>Invalid password reset</h1>
<p role="alert">
    The password reset link is invalid.
</p>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\InvalidUser.razor ---


@page "/Account/InvalidUser"

<PageTitle>Invalid user</PageTitle>

<h3>Invalid user</h3>

<StatusMessage />



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Lockout.razor ---


@page "/Account/Lockout"

<PageTitle>Locked out</PageTitle>

<header>
    <h1 class="text-danger">Locked out</h1>
    <p class="text-danger" role="alert">This account has been locked out, please try again later.</p>
</header>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Login.razor ---


@page "/Account/Login"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject ILogger<Login> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Log in</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Log in</MudText>

<MudGrid>
    <MudItem md="6">
        <StatusMessage Message="@errorMessage" />
        <EditForm Model="Input" method="post" OnValidSubmit="LoginUser" FormName="login">
            <DataAnnotationsValidator />

            <MudText GutterBottom="true" Typo="Typo.body1">Use a local account to log in.</MudText>

            <MudGrid>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email" 
                        Label="Email" Placeholder="name@example.com" 
                        UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } } )" />
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password" 
                        Label="Password" InputType="InputType.Password" Placeholder="password" 
                        UserAttributes="@(new() { { "autocomplete", "current-password" }, { "aria-required", "true" } } )" />
                </MudItem>
                <MudItem md="12">
                    <MudStaticCheckBox For="@(() => Input.RememberMe)" @bind-Value="Input.RememberMe">Remember me</MudStaticCheckBox>
                </MudItem>
                <MudItem md="12">
                    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Log in</MudStaticButton>
                </MudItem>
            </MudGrid>
        </EditForm>

        <MudGrid Class="mt-4">
            <MudItem md="12">
                <MudLink Href="Account/ForgotPassword">Forgot your password?</MudLink><br />
                <MudLink Href="@(NavigationManager.GetUriWithQueryParameters("Account/Register", new Dictionary<string, object?> { ["ReturnUrl"] = ReturnUrl }))">Register as a new user</MudLink><br />
                <MudLink Href="Account/ResendEmailConfirmation">Resend email confirmation</MudLink>
            </MudItem>
        </MudGrid>
    </MudItem>
    <MudItem md="6">
        <MudText GutterBottom="true" Typo="Typo.body1">Use another service to log in.</MudText>

        <ExternalLoginPicker />
    </MudItem>
</MudGrid>

@code {
    private string? errorMessage;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            // Clear the existing external cookie to ensure a clean login process
            await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);
        }
    }

    public async Task LoginUser()
    {
        // This doesn't count login failures towards account lockout
        // To enable password failures to trigger account lockout, set lockoutOnFailure: true
        var result = await SignInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: false);
        if (result.Succeeded)
        {
            Logger.LogInformation("User logged in.");
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.RequiresTwoFactor)
        {
            RedirectManager.RedirectTo(
                "Account/LoginWith2fa",
                new() { ["returnUrl"] = ReturnUrl, ["rememberMe"] = Input.RememberMe });
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User account locked out.");
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            errorMessage = "Error: Invalid login attempt.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";

        [Required]
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";

        [Display(Name = "Remember me?")]
        public bool RememberMe { get; set; }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\LoginWith2fa.razor ---


@page "/Account/LoginWith2fa"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<LoginWith2fa> Logger

<PageTitle>Two-factor authentication</PageTitle>

<h1>Two-factor authentication</h1>
<MudDivider />
<StatusMessage Message="@message" />
<p>Your login is protected with an authenticator app. Enter your authenticator code below.</p>
<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" FormName="login-with-2fa" OnValidSubmit="OnValidSubmitAsync" method="post">
            <input type="hidden" name="ReturnUrl" value="@ReturnUrl" />
            <input type="hidden" name="RememberMe" value="@RememberMe" />
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" role="alert" />
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.TwoFactorCode" id="Input.TwoFactorCode" class="form-control" autocomplete="off" />
                <label for="Input.TwoFactorCode" class="form-label">Authenticator code</label>
                <ValidationMessage For="() => Input.TwoFactorCode" class="text-danger" />
            </div>
            <div class="checkbox mb-3">
                <label for="remember-machine" class="form-label">
                    <InputCheckbox @bind-Value="Input.RememberMachine" />
                    Remember this machine
                </label>
            </div>
            <div>
                <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
            </div>
        </EditForm>
    </div>
</div>
<p>
    Don't have access to your authenticator device? You can
    <a class="mud-link mud-primary-text mud-link-underline-hover" href="Account/LoginWithRecoveryCode?ReturnUrl=@ReturnUrl">log in with a recovery code</a>.
</p>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery]
    private bool RememberMe { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Ensure the user has gone through the username & password screen first
        user = await SignInManager.GetTwoFactorAuthenticationUserAsync() ??
            throw new InvalidOperationException("Unable to load two-factor authentication user.");
    }

    private async Task OnValidSubmitAsync()
    {
        var authenticatorCode = Input.TwoFactorCode!.Replace(" ", string.Empty).Replace("-", string.Empty);
        var result = await SignInManager.TwoFactorAuthenticatorSignInAsync(authenticatorCode, RememberMe, Input.RememberMachine);
        var userId = await UserManager.GetUserIdAsync(user);

        if (result.Succeeded)
        {
            Logger.LogInformation("User with ID '{UserId}' logged in with 2fa.", userId);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User with ID '{UserId}' account locked out.", userId);
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            Logger.LogWarning("Invalid authenticator code entered for user with ID '{UserId}'.", userId);
            message = "Error: Invalid authenticator code.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [StringLength(7, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Text)]
        [Display(Name = "Authenticator code")]
        public string? TwoFactorCode { get; set; }

        [Display(Name = "Remember this machine")]
        public bool RememberMachine { get; set; }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\LoginWithRecoveryCode.razor ---


@page "/Account/LoginWithRecoveryCode"

@using System.ComponentModel.DataAnnotations
@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject SignInManager<ApplicationUser> SignInManager
@inject UserManager<ApplicationUser> UserManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<LoginWithRecoveryCode> Logger

<PageTitle>Recovery code verification</PageTitle>

<h1>Recovery code verification</h1>
<MudDivider />
<StatusMessage Message="@message" />
<p>
    You have requested to log in with a recovery code. This login will not be remembered until you provide
    an authenticator app code at log in or disable 2FA and log in again.
</p>
<div class="row">
    <div class="col-md-4">
        <EditForm Model="Input" FormName="login-with-recovery-code" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" role="alert" />
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.RecoveryCode" class="form-control" autocomplete="off" placeholder="RecoveryCode" />
                <label for="recovery-code" class="form-label">Recovery Code</label>
                <ValidationMessage For="() => Input.RecoveryCode" class="text-danger" />
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
        </EditForm>
    </div>
</div>

@code {
    private string? message;
    private ApplicationUser user = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // Ensure the user has gone through the username & password screen first
        user = await SignInManager.GetTwoFactorAuthenticationUserAsync() ??
            throw new InvalidOperationException("Unable to load two-factor authentication user.");
    }

    private async Task OnValidSubmitAsync()
    {
        var recoveryCode = Input.RecoveryCode.Replace(" ", string.Empty);

        var result = await SignInManager.TwoFactorRecoveryCodeSignInAsync(recoveryCode);

        var userId = await UserManager.GetUserIdAsync(user);

        if (result.Succeeded)
        {
            Logger.LogInformation("User with ID '{UserId}' logged in with a recovery code.", userId);
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User account locked out.");
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            Logger.LogWarning("Invalid recovery code entered for user with ID '{UserId}' ", userId);
            message = "Error: Invalid recovery code entered.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [DataType(DataType.Text)]
        [Display(Name = "Recovery Code")]
        public string RecoveryCode { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\Register.razor ---


@page "/Account/Register"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IUserStore<ApplicationUser> UserStore
@inject SignInManager<ApplicationUser> SignInManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject ILogger<Register> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Register</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Register</MudText>

<MudGrid>
    <MudItem md="6">
        <StatusMessage Message="@Message" />
        <EditForm Model="Input" asp-route-returnUrl="@ReturnUrl" method="post" OnValidSubmit="RegisterUser" FormName="register">
            <DataAnnotationsValidator />

            <MudText Typo="Typo.body1" GutterBottom="true">Create a new account.</MudText>

            <MudGrid>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email"
                                        Label="Email" Placeholder="name@example.com"
                                        UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } } )" />
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.Password)" @bind-Value="Input.Password"
                                        Label="Password" InputType="InputType.Password" Placeholder="password"
                                        UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } } )" />
                </MudItem>
                <MudItem md="12">
                    <MudStaticTextField For="@(() => Input.ConfirmPassword)" @bind-Value="Input.ConfirmPassword"
                                        Label="Confirm Password" InputType="InputType.Password" Placeholder="confirm password"
                                        UserAttributes="@(new() { { "autocomplete", "new-password" }, { "aria-required", "true" } } )" />
                </MudItem>
                <MudItem md="12">
                    <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Register</MudStaticButton>
                </MudItem>
            </MudGrid>
        </EditForm>
    </MudItem>
    <MudItem md="6">
        <MudText Typo="Typo.body1" GutterBottom="true">Use another service to register.</MudText>
        <ExternalLoginPicker />
    </MudItem>
</MudGrid>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    public async Task RegisterUser(EditContext editContext)
    {
        var user = CreateUser();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);
        var emailStore = GetEmailStore();
        await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);
        var result = await UserManager.CreateAsync(user, Input.Password);

        if (!result.Succeeded)
        {
            identityErrors = result.Errors;
            return;
        }

        Logger.LogInformation("User created a new account with password.");

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code, ["returnUrl"] = ReturnUrl });

        await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        if (UserManager.Options.SignIn.RequireConfirmedAccount)
        {
            RedirectManager.RedirectTo(
                "Account/RegisterConfirmation",
                new() { ["email"] = Input.Email, ["returnUrl"] = ReturnUrl });
        }

        await SignInManager.SignInAsync(user, isPersistent: false);
        RedirectManager.RedirectTo(ReturnUrl);
    }

    private static ApplicationUser CreateUser()
    {
        try
        {
            return Activator.CreateInstance<ApplicationUser>();
        }
        catch
        {
            throw new InvalidOperationException($"Can't create an instance of '{nameof(ApplicationUser)}'. " +
                $"Ensure that '{nameof(ApplicationUser)}' is not an abstract class and has a parameterless constructor.");
        }
    }

    private IUserEmailStore<ApplicationUser> GetEmailStore()
    {
        if (!UserManager.SupportsUserEmail)
        {
            throw new NotSupportedException("The default UI requires a user store with email support.");
        }
        return (IUserEmailStore<ApplicationUser>)UserStore;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        [Display(Name = "Email")]
        public string Email { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        [Display(Name = "Password")]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\RegisterConfirmation.razor ---


@page "/Account/RegisterConfirmation"

@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Register confirmation</PageTitle>

<h1>Register confirmation</h1>

<StatusMessage Message="@statusMessage" />

@if (emailConfirmationLink is not null)
{
    <p>
        This app does not currently have a real email sender registered, see <a class="mud-link mud-primary-text mud-link-underline-hover" href="https://aka.ms/aspaccountconf">these docs</a> for how to configure a real email sender.
        Normally this would be emailed: <a class="mud-link mud-primary-text mud-link-underline-hover" href="@emailConfirmationLink">Click here to confirm your account</a>
    </p>
}
else
{
    <p role="alert">Please check your email to confirm your account.</p>
}

@code {
    private string? emailConfirmationLink;
    private string? statusMessage;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromQuery]
    private string? Email { get; set; }

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (Email is null)
        {
            RedirectManager.RedirectTo("");
        }

        var user = await UserManager.FindByEmailAsync(Email);
        if (user is null)
        {
            HttpContext.Response.StatusCode = StatusCodes.Status404NotFound;
            statusMessage = "Error finding user for unspecified email";
        }
        else if (EmailSender is IdentityNoOpEmailSender)
        {
            // Once you add a real email sender, you should remove this code that lets you confirm the account
            var userId = await UserManager.GetUserIdAsync(user);
            var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
            code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
            emailConfirmationLink = NavigationManager.GetUriWithQueryParameters(
                NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
                new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code, ["returnUrl"] = ReturnUrl });
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ResendEmailConfirmation.razor ---


@page "/Account/ResendEmailConfirmation"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using System.Text.Encodings.Web
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject UserManager<ApplicationUser> UserManager
@inject IEmailSender<ApplicationUser> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Resend email confirmation</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Resend email confirmation</MudText>

<MudText Typo="Typo.body1" GutterBottom="true">Enter your email.</MudText>

<StatusMessage Message="@message" />

<EditForm Model="Input" FormName="resend-email-confirmation" OnValidSubmit="OnValidSubmitAsync" method="post">
    <DataAnnotationsValidator />

    <MudGrid>
        <MudItem md="12">
            <MudStaticTextField For="@(() => Input.Email)" @bind-Value="Input.Email"
                                Label="Email" Placeholder="name@example.com"
                                UserAttributes="@(new() { { "autocomplete", "username" }, { "aria-required", "true" } } )" />
        </MudItem>
        <MudItem md="12">
            <MudStaticButton Variant="Variant.Filled" Color="Color.Primary" FullWidth="true" FormAction="FormAction.Submit">Resend</MudStaticButton>
        </MudItem>
    </MudGrid>
</EditForm>

@code {
    private string? message;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email!);
        if (user is null)
        {
            message = "Verification email sent. Please check your email.";
            return;
        }

        var userId = await UserManager.GetUserIdAsync(user);
        var code = await UserManager.GenerateEmailConfirmationTokenAsync(user);
        code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));
        var callbackUrl = NavigationManager.GetUriWithQueryParameters(
            NavigationManager.ToAbsoluteUri("Account/ConfirmEmail").AbsoluteUri,
            new Dictionary<string, object?> { ["userId"] = userId, ["code"] = code });
        await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

        message = "Verification email sent. Please check your email.";
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ResetPassword.razor ---


@page "/Account/ResetPassword"

@using System.ComponentModel.DataAnnotations
@using System.Text
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.WebUtilities
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject IdentityRedirectManager RedirectManager
@inject UserManager<ApplicationUser> UserManager

<PageTitle>Reset password</PageTitle>

<h1>Reset password</h1>
<h2>Reset your password.</h2>
<MudDivider />
<div class="row">
    <div class="col-md-4">
        <StatusMessage Message="@Message" />
        <EditForm Model="Input" FormName="reset-password" OnValidSubmit="OnValidSubmitAsync" method="post">
            <DataAnnotationsValidator />
            <ValidationSummary class="text-danger" role="alert" />

            <input type="hidden" name="Input.Code" value="@Input.Code" />
            <div class="form-floating mb-3">
                <InputText @bind-Value="Input.Email" id="Input.Email" class="form-control" autocomplete="username" aria-required="true" placeholder="name@example.com" />
                <label for="Input.Email" class="form-label">Email</label>
                <ValidationMessage For="() => Input.Email" class="text-danger" />
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.Password" id="Input.Password" class="form-control" autocomplete="new-password" aria-required="true" placeholder="Please enter your password." />
                <label for="Input.Password" class="form-label">Password</label>
                <ValidationMessage For="() => Input.Password" class="text-danger" />
            </div>
            <div class="form-floating mb-3">
                <InputText type="password" @bind-Value="Input.ConfirmPassword" id="Input.ConfirmPassword" class="form-control" autocomplete="new-password" aria-required="true" placeholder="Please confirm your password." />
                <label for="Input.ConfirmPassword" class="form-label">Confirm password</label>
                <ValidationMessage For="() => Input.ConfirmPassword" class="text-danger" />
            </div>
            <button type="submit" class="w-100 btn btn-lg btn-primary">Reset</button>
        </EditForm>
    </div>
</div>

@code {
    private IEnumerable<IdentityError>? identityErrors;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? Code { get; set; }

    private string? Message => identityErrors is null ? null : $"Error: {string.Join(", ", identityErrors.Select(error => error.Description))}";

    protected override void OnInitialized()
    {
        if (Code is null)
        {
            RedirectManager.RedirectTo("Account/InvalidPasswordReset");
        }

        Input.Code = Encoding.UTF8.GetString(WebEncoders.Base64UrlDecode(Code));
    }

    private async Task OnValidSubmitAsync()
    {
        var user = await UserManager.FindByEmailAsync(Input.Email);
        if (user is null)
        {
            // Don't reveal that the user does not exist
            RedirectManager.RedirectTo("Account/ResetPasswordConfirmation");
        }

        var result = await UserManager.ResetPasswordAsync(user, Input.Code, Input.Password);
        if (result.Succeeded)
        {
            RedirectManager.RedirectTo("Account/ResetPasswordConfirmation");
        }

        identityErrors = result.Errors;
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";

        [Required]
        [StringLength(100, ErrorMessage = "The {0} must be at least {2} and at max {1} characters long.", MinimumLength = 6)]
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";

        [DataType(DataType.Password)]
        [Display(Name = "Confirm password")]
        [Compare("Password", ErrorMessage = "The password and confirmation password do not match.")]
        public string ConfirmPassword { get; set; } = "";

        [Required]
        public string Code { get; set; } = "";
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Pages\ResetPasswordConfirmation.razor ---


@page "/Account/ResetPasswordConfirmation"
<PageTitle>Reset password confirmation</PageTitle>

<h1>Reset password confirmation</h1>
<p role="alert">
    Your password has been reset. Please <a class="mud-link mud-primary-text mud-link-underline-hover" href="Account/Login">click here to log in</a>.
</p>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\ExternalLoginPicker.razor ---


@using Microsoft.AspNetCore.Authentication
@using Microsoft.AspNetCore.Identity
@using MudBlazor
@using MicroPluberd.Examples.Blazor.Identity.Data
@using MudBlazor.StaticInput

@inject SignInManager<ApplicationUser> SignInManager
@inject IdentityRedirectManager RedirectManager

@if (externalLogins.Length == 0)
{
    <MudAlert Variant="Variant.Text" Severity="Severity.Warning">There are no external authentication services configured.</MudAlert>
    <MudText Typo="Typo.body1" Class="pt-4">
        See <MudLink Target="_blank" Href="https://go.microsoft.com/fwlink/?LinkID=532715">this article</MudLink>
        about setting up this ASP.NET application to support logging in via external services
    </MudText>
}
else
{
    <form class="form-horizontal" action="Account/PerformExternalLogin" method="post">
        <div>
            <AntiforgeryToken />
            <input type="hidden" name="ReturnUrl" value="@ReturnUrl" />
            <p>
                @foreach (var provider in externalLogins)
                {
                    <button type="submit" class="btn btn-primary" name="provider" value="@provider.Name" title="Log in using your @provider.DisplayName account">@provider.DisplayName</button>
                }
            </p>
        </div>
    </form>
}

@code {
    private AuthenticationScheme[] externalLogins = [];

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        externalLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync()).ToArray();
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\ManageLayout.razor ---


@inherits LayoutComponentBase
@layout MicroPluberd.Examples.Blazor.Identity.Components.Layout.MainLayout

<MudText Typo="Typo.h3" GutterBottom="true">Manage your account</MudText>

<MudGrid>
    <MudItem md="5">
        <MudText Typo="Typo.h6" GutterBottom="true">Change your account settings</MudText>
        <ManageNavMenu />
    </MudItem>
    <MudItem md="7">
        @Body
    </MudItem>
</MudGrid>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\ManageNavMenu.razor ---


@using Microsoft.AspNetCore.Identity
@using MicroPluberd.Examples.Blazor.Identity.Data

@inject SignInManager<ApplicationUser> SignInManager

<MudNavMenu>
    <MudNavLink Href="Account/Manage" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Person">Profile</MudNavLink>
    <MudNavLink Href="Account/Manage/Email" Icon="@Icons.Material.Filled.Email">Email</MudNavLink>
    <MudNavLink Href="Account/Manage/ChangePassword" Icon="@Icons.Material.Filled.Lock">Password</MudNavLink>
    @if (hasExternalLogins)
    {
        <MudNavLink Href="Account/Manage/ExternalLogins" Icon="@Icons.Material.Filled.PhoneLocked">External logins</MudNavLink>
    }
    <MudNavLink Href="Account/Manage/TwoFactorAuthentication" Icon="@Icons.Material.Filled.LockClock">Two-factor authentication</MudNavLink>
    <MudNavLink Href="Account/Manage/PersonalData" Icon="@Icons.Material.Filled.PersonRemove">Personal data</MudNavLink>
</MudNavMenu>

@code {
    private bool hasExternalLogins;

    protected override async Task OnInitializedAsync()
    {
        hasExternalLogins = (await SignInManager.GetExternalAuthenticationSchemesAsync()).Any();
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\RedirectToLogin.razor ---


@inject NavigationManager NavigationManager

@code {
    protected override void OnInitialized()
    {
        NavigationManager.NavigateTo($"Account/Login?returnUrl={Uri.EscapeDataString(NavigationManager.Uri)}", forceLoad: true);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\ShowRecoveryCodes.razor ---


<StatusMessage Message="@StatusMessage" />
<h3>Recovery codes</h3>
<div class="alert alert-warning" role="alert">
    <p>
        <strong>Put these codes in a safe place.</strong>
    </p>
    <p>
        If you lose your device and don't have the recovery codes you will lose access to your account.
    </p>
</div>
<div class="row">
    <div class="col-md-12">
        @foreach (var recoveryCode in RecoveryCodes)
        {
            <div>
                <code class="recovery-code">@recoveryCode</code>
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public string[] RecoveryCodes { get; set; } = [];

    [Parameter]
    public string? StatusMessage { get; set; }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\Shared\StatusMessage.razor ---


@if (!string.IsNullOrEmpty(DisplayMessage))
{
    var severity = DisplayMessage.StartsWith("Error") ? Severity.Error : Severity.Success;

    <MudAlert Variant="Variant.Outlined" Severity="@severity">@DisplayMessage</MudAlert>
}

@code {
    private string? messageFromCookie;

    [Parameter]
    public string? Message { get; set; }

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    private string? DisplayMessage => Message ?? messageFromCookie;

    protected override void OnInitialized()
    {
        messageFromCookie = HttpContext.Request.Cookies[IdentityRedirectManager.StatusCookieName];

        if (messageFromCookie is not null)
        {
            HttpContext.Response.Cookies.Delete(IdentityRedirectManager.StatusCookieName);
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\IdentityComponentsEndpointRouteBuilderExtensions.cs ---


using System.Security.Claims;
using System.Text.Json;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Http.Extensions;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Primitives;
using MicroPluberd.Examples.Blazor.Identity.Components.Account.Pages;
using MicroPluberd.Examples.Blazor.Identity.Components.Account.Pages.Manage;
using MicroPluberd.Examples.Blazor.Identity.Data;

namespace Microsoft.AspNetCore.Routing;

internal static class IdentityComponentsEndpointRouteBuilderExtensions
{
    // These endpoints are required by the Identity Razor components defined in the /Components/Account/Pages directory of this project.
    public static IEndpointConventionBuilder MapAdditionalIdentityEndpoints(this IEndpointRouteBuilder endpoints)
    {
        ArgumentNullException.ThrowIfNull(endpoints);

        var accountGroup = endpoints.MapGroup("/Account");

        accountGroup.MapPost("/PerformExternalLogin", (
            HttpContext context,
            [FromServices] SignInManager<ApplicationUser> signInManager,
            [FromForm] string provider,
            [FromForm] string returnUrl) =>
        {
            IEnumerable<KeyValuePair<string, StringValues>> query = [
                new("ReturnUrl", returnUrl),
                new("Action", ExternalLogin.LoginCallbackAction)];

            var redirectUrl = UriHelper.BuildRelative(
                context.Request.PathBase,
                "/Account/ExternalLogin",
                QueryString.Create(query));

            var properties = signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl);
            return TypedResults.Challenge(properties, [provider]);
        });

        accountGroup.MapPost("/Logout", async (
            ClaimsPrincipal user,
            [FromServices] SignInManager<ApplicationUser> signInManager,
            [FromForm] string returnUrl) =>
        {
            await signInManager.SignOutAsync();
            return TypedResults.LocalRedirect($"~/{returnUrl}");
        });

        var manageGroup = accountGroup.MapGroup("/Manage").RequireAuthorization();

        manageGroup.MapPost("/LinkExternalLogin", async (
            HttpContext context,
            [FromServices] SignInManager<ApplicationUser> signInManager,
            [FromForm] string provider) =>
        {
            // Clear the existing external cookie to ensure a clean login process
            await context.SignOutAsync(IdentityConstants.ExternalScheme);

            var redirectUrl = UriHelper.BuildRelative(
                context.Request.PathBase,
                "/Account/Manage/ExternalLogins",
                QueryString.Create("Action", ExternalLogins.LinkLoginCallbackAction));

            var properties = signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl, signInManager.UserManager.GetUserId(context.User));
            return TypedResults.Challenge(properties, [provider]);
        });

        var loggerFactory = endpoints.ServiceProvider.GetRequiredService<ILoggerFactory>();
        var downloadLogger = loggerFactory.CreateLogger("DownloadPersonalData");

        manageGroup.MapPost("/DownloadPersonalData", async (
            HttpContext context,
            [FromServices] UserManager<ApplicationUser> userManager,
            [FromServices] AuthenticationStateProvider authenticationStateProvider) =>
        {
            var user = await userManager.GetUserAsync(context.User);
            if (user is null)
            {
                return Results.NotFound($"Unable to load user with ID '{userManager.GetUserId(context.User)}'.");
            }

            var userId = await userManager.GetUserIdAsync(user);
            downloadLogger.LogInformation("User with ID '{UserId}' asked for their personal data.", userId);

            // Only include personal data for download
            var personalData = new Dictionary<string, string>();
            var personalDataProps = typeof(ApplicationUser).GetProperties().Where(
                prop => Attribute.IsDefined(prop, typeof(PersonalDataAttribute)));
            foreach (var p in personalDataProps)
            {
                personalData.Add(p.Name, p.GetValue(user)?.ToString() ?? "null");
            }

            var logins = await userManager.GetLoginsAsync(user);
            foreach (var l in logins)
            {
                personalData.Add($"{l.LoginProvider} external login provider key", l.ProviderKey);
            }

            personalData.Add("Authenticator Key", (await userManager.GetAuthenticatorKeyAsync(user))!);
            var fileBytes = JsonSerializer.SerializeToUtf8Bytes(personalData);

            context.Response.Headers.TryAdd("Content-Disposition", "attachment; filename=PersonalData.json");
            return TypedResults.File(fileBytes, contentType: "application/json", fileDownloadName: "PersonalData.json");
        });

        return accountGroup;
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\IdentityNoOpEmailSender.cs ---


using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.UI.Services;
using MicroPluberd.Examples.Blazor.Identity.Data;

namespace MicroPluberd.Examples.Blazor.Identity.Components.Account;

// Remove the "else if (EmailSender is IdentityNoOpEmailSender)" block from RegisterConfirmation.razor after updating with a real implementation.
internal sealed class IdentityNoOpEmailSender : IEmailSender<ApplicationUser>
{
    private readonly IEmailSender emailSender = new NoOpEmailSender();

    public Task SendConfirmationLinkAsync(ApplicationUser user, string email, string confirmationLink) =>
        emailSender.SendEmailAsync(email, "Confirm your email", $"Please confirm your account by <a href='{confirmationLink}'>clicking here</a>.");
 
    public Task SendPasswordResetLinkAsync(ApplicationUser user, string email, string resetLink) =>
        emailSender.SendEmailAsync(email, "Reset your password", $"Please reset your password by <a href='{resetLink}'>clicking here</a>.");
 
    public Task SendPasswordResetCodeAsync(ApplicationUser user, string email, string resetCode) =>
        emailSender.SendEmailAsync(email, "Reset your password", $"Please reset your password using the following code: {resetCode}");
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\IdentityRedirectManager.cs ---


using System.Diagnostics.CodeAnalysis;
using Microsoft.AspNetCore.Components;

namespace MicroPluberd.Examples.Blazor.Identity.Components.Account;

internal sealed class IdentityRedirectManager(NavigationManager navigationManager)
{
    public const string StatusCookieName = "Identity.StatusMessage";

    private static readonly CookieBuilder StatusCookieBuilder = new()
    {
        SameSite = SameSiteMode.Strict,
        HttpOnly = true,
        IsEssential = true,
        MaxAge = TimeSpan.FromSeconds(5),
    };

    [DoesNotReturn]
    public void RedirectTo(string? uri)
    {
        uri ??= "";

        // Prevent open redirects.
        if (!Uri.IsWellFormedUriString(uri, UriKind.Relative))
        {
            uri = navigationManager.ToBaseRelativePath(uri);
        }

        // During static rendering, NavigateTo throws a NavigationException which is handled by the framework as a redirect.
        // So as long as this is called from a statically rendered Identity component, the InvalidOperationException is never thrown.
        navigationManager.NavigateTo(uri);
        throw new InvalidOperationException($"{nameof(IdentityRedirectManager)} can only be used during static rendering.");
    }

    [DoesNotReturn]
    public void RedirectTo(string uri, Dictionary<string, object?> queryParameters)
    {
        var uriWithoutQuery = navigationManager.ToAbsoluteUri(uri).GetLeftPart(UriPartial.Path);
        var newUri = navigationManager.GetUriWithQueryParameters(uriWithoutQuery, queryParameters);
        RedirectTo(newUri);
    }

    [DoesNotReturn]
    public void RedirectToWithStatus(string uri, string message, HttpContext context)
    {
        context.Response.Cookies.Append(StatusCookieName, message, StatusCookieBuilder.Build(context));
        RedirectTo(uri);
    }

    private string CurrentPath => navigationManager.ToAbsoluteUri(navigationManager.Uri).GetLeftPart(UriPartial.Path);

    [DoesNotReturn]
    public void RedirectToCurrentPage() => RedirectTo(CurrentPath);

    [DoesNotReturn]
    public void RedirectToCurrentPageWithStatus(string message, HttpContext context)
        => RedirectToWithStatus(CurrentPath, message, context);
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\IdentityRevalidatingAuthenticationStateProvider.cs ---


using System.Security.Claims;
using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Components.Server;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.Options;
using MicroPluberd.Examples.Blazor.Identity.Data;

namespace MicroPluberd.Examples.Blazor.Identity.Components.Account;

// This is a server-side AuthenticationStateProvider that revalidates the security stamp for the connected user
// every 30 minutes an interactive circuit is connected.
internal sealed class IdentityRevalidatingAuthenticationStateProvider(
        ILoggerFactory loggerFactory,
        IServiceScopeFactory scopeFactory,
        IOptions<IdentityOptions> options)
    : RevalidatingServerAuthenticationStateProvider(loggerFactory)
{
    protected override TimeSpan RevalidationInterval => TimeSpan.FromMinutes(30);

    protected override async Task<bool> ValidateAuthenticationStateAsync(
        AuthenticationState authenticationState, CancellationToken cancellationToken)
    {
        // Get the user manager from a new scope to ensure it fetches fresh data
        await using var scope = scopeFactory.CreateAsyncScope();
        var userManager = scope.ServiceProvider.GetRequiredService<UserManager<ApplicationUser>>();
        return await ValidateSecurityStampAsync(userManager, authenticationState.User);
    }

    private async Task<bool> ValidateSecurityStampAsync(UserManager<ApplicationUser> userManager, ClaimsPrincipal principal)
    {
        var user = await userManager.GetUserAsync(principal);
        if (user is null)
        {
            return false;
        }
        else if (!userManager.SupportsUserSecurityStamp)
        {
            return true;
        }
        else
        {
            var principalStamp = principal.FindFirstValue(options.Value.ClaimsIdentity.SecurityStampClaimType);
            var userStamp = await userManager.GetSecurityStampAsync(user);
            return principalStamp == userStamp;
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Account\IdentityUserAccessor.cs ---


using Microsoft.AspNetCore.Identity;
using MicroPluberd.Examples.Blazor.Identity.Data;

namespace MicroPluberd.Examples.Blazor.Identity.Components.Account;

internal sealed class IdentityUserAccessor(UserManager<ApplicationUser> userManager, IdentityRedirectManager redirectManager)
{
    public async Task<ApplicationUser> GetRequiredUserAsync(HttpContext context)
    {
        var user = await userManager.GetUserAsync(context.User);

        if (user is null)
        {
            redirectManager.RedirectToWithStatus("Account/InvalidUser", $"Error: Unable to load user with ID '{userManager.GetUserId(context.User)}'.", context);
        }

        return user;
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Layout\MainLayout.razor ---


@inherits LayoutComponentBase

<MudThemeProvider />
<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />
<MudLayout>
    <MudAppBar Elevation="1">
        <MudStaticNavDrawerToggle DrawerId="nav-drawer" Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start" />
        <MudText Typo="Typo.h5" Class="ml-3">Application</MudText>
        <MudSpacer />
        <MudIconButton Icon="@Icons.Material.Filled.MoreVert" Color="Color.Inherit" Edge="Edge.End" />
    </MudAppBar>
    <MudDrawer id="nav-drawer" @bind-Open="_drawerOpen" ClipMode="DrawerClipMode.Always" Elevation="2">
        <NavMenu />
    </MudDrawer>
    <MudMainContent Class="mt-16 pa-4">
        @Body
    </MudMainContent>
</MudLayout>


<div id="blazor-error-ui" data-nosnippet>
    An unhandled error has occurred.
    <a href="." class="reload">Reload</a>
    <span class="dismiss"></span>
</div>

@code {
    private bool _drawerOpen = true;
}





// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Layout\NavMenu.razor ---


@implements IDisposable

@inject NavigationManager NavigationManager

<MudNavMenu>
    <MudNavLink Href="" Match="NavLinkMatch.All" Icon="@Icons.Material.Filled.Home">Home</MudNavLink>
    <MudNavLink Href="counter" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Add">Counter</MudNavLink>
    
    <MudNavLink Href="weather" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.List">Weather</MudNavLink>

    <MudNavLink Href="auth" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Lock">Auth Required</MudNavLink>
    <AuthorizeView>
        <Authorized>
            <MudNavLink Href="Account/Manage" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Person">@context.User.Identity?.Name</MudNavLink>
            <form action="Account/Logout" method="post">
                <AntiforgeryToken />
                <input type="hidden" name="ReturnUrl" value="@currentUrl" />
                <button type="submit" class="mud-nav-link mud-ripple">
                    <MudIcon Icon="@Icons.Material.Filled.Logout" Color="Color.Info" Class="mr-3"></MudIcon> Logout
                </button>
            </form>
        </Authorized>
        <NotAuthorized>
            <MudNavLink Href="Account/Register" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Person">Register</MudNavLink>
            <MudNavLink Href="Account/Login" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Password">Login</MudNavLink>
        </NotAuthorized>
    </AuthorizeView>
</MudNavMenu>


@code {
    private string? currentUrl;

    protected override void OnInitialized()
    {
        currentUrl = NavigationManager.ToBaseRelativePath(NavigationManager.Uri);
        NavigationManager.LocationChanged += OnLocationChanged;
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        currentUrl = NavigationManager.ToBaseRelativePath(e.Location);
        StateHasChanged();
    }

    public void Dispose()
    {
        NavigationManager.LocationChanged -= OnLocationChanged;
    }
}




// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Pages\Auth.razor ---


@page "/auth"

@using Microsoft.AspNetCore.Authorization

@attribute [Authorize]

<PageTitle>Auth</PageTitle>


<MudText Typo="Typo.h3" GutterBottom="true">You are authenticated!</MudText>

<AuthorizeView>
    <MudText Class="mb-4">Hello @context.User.Identity?.Name!</MudText>
</AuthorizeView>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Pages\Counter.razor ---


@page "/counter"

<PageTitle>Counter</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Counter</MudText>

<MudText Typo="Typo.body1" Class="mb-4">Current count: @currentCount</MudText>

<MudButton Color="Color.Primary" Variant="Variant.Filled" @onclick="IncrementCount">Click me</MudButton>

@code {
    private int currentCount = 0;

    private void IncrementCount()
    {
        currentCount++;
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Pages\Error.razor ---


@page "/Error"
@using System.Diagnostics

<PageTitle>Error</PageTitle>

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to <strong>Development</strong> environment will display more detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>

@code{
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? RequestId { get; set; }
    private bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    protected override void OnInitialized() =>
        RequestId = Activity.Current?.Id ?? HttpContext?.TraceIdentifier;
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Pages\Home.razor ---


@page "/"

<PageTitle>Home</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Hello, world!</MudText>
<MudText Class="mb-8">Welcome to your new app, powered by MudBlazor and the .NET 9 Template!</MudText>

<MudAlert Severity="Severity.Normal">
    You can find documentation and examples on our website here:
    <MudLink Href="https://mudblazor.com" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        <b>www.mudblazor.com</b>
    </MudLink>
</MudAlert>

<br />
<MudText Typo="Typo.h5" GutterBottom="true">Interactivity in this Template</MudText>
<br />
<MudText Typo="Typo.body2">
    When you opt for the "Global" Interactivity Location, <br />
    the render modes are defined in App.razor and consequently apply to all child components.<br />
    In this case, providers are globally set in the MainLayout.<br />
    <br />
    On the other hand, if you choose the "Per page/component" Interactivity Location,<br />
    it is necessary to include the <br />
    <br />
    &lt;MudPopoverProvider /&gt; <br />
    &lt;MudDialogProvider /&gt; <br />
    &lt;MudSnackbarProvider /&gt; <br />
    <br />
    components on every interactive page.<br />
    <br />
    If a render mode is not specified for a page, it defaults to Server-Side Rendering (SSR),<br />
    similar to this page. While MudBlazor allows pages to be rendered in SSR,<br />
    please note that interactive features, such as buttons and dropdown menus, will not be functional.
</MudText>

<br />
<MudText Typo="Typo.h5" GutterBottom="true">What's New in Blazor with the Release of .NET 9</MudText>
<br />

<MudText Typo="Typo.h6" GutterBottom="true">Prerendering</MudText>
<MudText Typo="Typo.body2" GutterBottom="true">
    If you're exploring the features of .NET 9 Blazor,<br /> you might be pleasantly surprised to learn that each page is prerendered on the server,<br /> regardless of the selected render mode.<br /><br />
    This means that you'll need to inject all necessary services on the server,<br /> even when opting for the wasm (WebAssembly) render mode.<br /><br />
    This prerendering functionality is crucial to ensuring that WebAssembly mode feels fast and responsive,<br /> especially when it comes to initial page load times.<br /><br />
    For more information on how to detect prerendering and leverage the RenderContext, you can refer to the following link:
    <MudLink Href="https://github.com/dotnet/aspnetcore/issues/51468#issuecomment-1783568121" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        More details
    </MudLink>
</MudText>

<br />
<MudText Typo="Typo.h6" GutterBottom="true">InteractiveAuto</MudText>
<MudText Typo="Typo.body2">
    A discussion on how to achieve this can be found here:
    <MudLink Href="https://github.com/dotnet/aspnetcore/issues/51468#issue-1950424116" Target="_blank" Typo="Typo.body2" Color="Color.Primary">
        More details
    </MudLink>
</MudText>



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Pages\Weather.razor ---


@page "/weather"



<PageTitle>Weather</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Weather forecast</MudText>
<MudText Typo="Typo.body1" Class="mb-8">This component demonstrates fetching data from the server.</MudText>

@if (forecasts == null)
{
    <MudProgressCircular Color="Color.Default" Indeterminate="true" />
}
else
{
  <MudTable Items="forecasts" Hover="true" SortLabel="Sort By" Elevation="0" AllowUnsorted="false">
        <HeaderContent>
            <MudTh><MudTableSortLabel InitialDirection="SortDirection.Ascending" SortBy="new Func<WeatherForecast, object>(x=>x.Date)">Date</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.TemperatureC)">Temp. (C)</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.TemperatureF)">Temp. (F)</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel SortBy="new Func<WeatherForecast, object>(x=>x.Summary!)">Summary</MudTableSortLabel></MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Date">@context.Date</MudTd>
            <MudTd DataLabel="Temp. (C)">@context.TemperatureC</MudTd>
            <MudTd DataLabel="Temp. (F)">@context.TemperatureF</MudTd>
            <MudTd DataLabel="Summary">@context.Summary</MudTd>
        </RowTemplate>
        <PagerContent>
            <MudTablePager PageSizeOptions="new int[]{50, 100}" />
        </PagerContent>
    </MudTable>
}

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate a loading indicator
        await Task.Delay(500);

        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        forecasts = Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }

    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\_Imports.razor ---


@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Authorization
@using MudBlazor.StaticInput
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MudBlazor
@using MudBlazor.Services
@using MicroPluberd.Examples.Blazor.Identity
@using MicroPluberd.Examples.Blazor.Identity.Components



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\App.razor ---


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />  
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href=@Assets["_content/MudBlazor/MudBlazor.min.css"] rel="stylesheet" />
    <ImportMap />
    <link rel="icon" type="image/ico" href="favicon.ico" />
    <HeadOutlet @rendermode="PageRenderMode" />
</head>

<body>
    <Routes @rendermode="PageRenderMode" />
    <script src="_framework/blazor.web.js"></script>
    <script src=@Assets["_content/MudBlazor/MudBlazor.min.js"]></script>
    <script src=@Assets["_content/Extensions.MudBlazor.StaticInput/NavigationObserver.js"]></script>
</body>

</html>

@code {
    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    private IComponentRenderMode? PageRenderMode =>
        HttpContext.AcceptsInteractiveRouting() ? InteractiveServer : null;
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Components\Routes.razor ---


@using MicroPluberd.Examples.Blazor.Identity.Components.Account.Shared
<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <AuthorizeRouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)">
            <NotAuthorized>
                <RedirectToLogin />
            </NotAuthorized>
        </AuthorizeRouteView>
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>



// --- File: MicroPluberd.Examples.Blazor.Identity\Data\Migrations\00000000000000_CreateIdentitySchema.cs ---


using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MicroPluberd.Examples.Blazor.Identity.Migrations
{
    /// <inheritdoc />
    public partial class CreateIdentitySchema : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "AspNetRoles",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    NormalizedName = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    ConcurrencyStamp = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetRoles", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUsers",
                columns: table => new
                {
                    Id = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    UserName = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    NormalizedUserName = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    Email = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    NormalizedEmail = table.Column<string>(type: "nvarchar(256)", maxLength: 256, nullable: true),
                    EmailConfirmed = table.Column<bool>(type: "bit", nullable: false),
                    PasswordHash = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    SecurityStamp = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ConcurrencyStamp = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    PhoneNumber = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    PhoneNumberConfirmed = table.Column<bool>(type: "bit", nullable: false),
                    TwoFactorEnabled = table.Column<bool>(type: "bit", nullable: false),
                    LockoutEnd = table.Column<DateTimeOffset>(type: "datetimeoffset", nullable: true),
                    LockoutEnabled = table.Column<bool>(type: "bit", nullable: false),
                    AccessFailedCount = table.Column<int>(type: "int", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUsers", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "AspNetRoleClaims",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    RoleId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    ClaimType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ClaimValue = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetRoleClaims", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AspNetRoleClaims_AspNetRoles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "AspNetRoles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserClaims",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    ClaimType = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ClaimValue = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserClaims", x => x.Id);
                    table.ForeignKey(
                        name: "FK_AspNetUserClaims_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserLogins",
                columns: table => new
                {
                    LoginProvider = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    ProviderKey = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    ProviderDisplayName = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserLogins", x => new { x.LoginProvider, x.ProviderKey });
                    table.ForeignKey(
                        name: "FK_AspNetUserLogins_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserRoles",
                columns: table => new
                {
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    RoleId = table.Column<string>(type: "nvarchar(450)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserRoles", x => new { x.UserId, x.RoleId });
                    table.ForeignKey(
                        name: "FK_AspNetUserRoles_AspNetRoles_RoleId",
                        column: x => x.RoleId,
                        principalTable: "AspNetRoles",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                    table.ForeignKey(
                        name: "FK_AspNetUserRoles_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "AspNetUserTokens",
                columns: table => new
                {
                    UserId = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    LoginProvider = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Name = table.Column<string>(type: "nvarchar(450)", nullable: false),
                    Value = table.Column<string>(type: "nvarchar(max)", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_AspNetUserTokens", x => new { x.UserId, x.LoginProvider, x.Name });
                    table.ForeignKey(
                        name: "FK_AspNetUserTokens_AspNetUsers_UserId",
                        column: x => x.UserId,
                        principalTable: "AspNetUsers",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_AspNetRoleClaims_RoleId",
                table: "AspNetRoleClaims",
                column: "RoleId");

            migrationBuilder.CreateIndex(
                name: "RoleNameIndex",
                table: "AspNetRoles",
                column: "NormalizedName",
                unique: true,
                filter: "[NormalizedName] IS NOT NULL");

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserClaims_UserId",
                table: "AspNetUserClaims",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserLogins_UserId",
                table: "AspNetUserLogins",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_AspNetUserRoles_RoleId",
                table: "AspNetUserRoles",
                column: "RoleId");

            migrationBuilder.CreateIndex(
                name: "EmailIndex",
                table: "AspNetUsers",
                column: "NormalizedEmail");

            migrationBuilder.CreateIndex(
                name: "UserNameIndex",
                table: "AspNetUsers",
                column: "NormalizedUserName",
                unique: true,
                filter: "[NormalizedUserName] IS NOT NULL");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "AspNetRoleClaims");

            migrationBuilder.DropTable(
                name: "AspNetUserClaims");

            migrationBuilder.DropTable(
                name: "AspNetUserLogins");

            migrationBuilder.DropTable(
                name: "AspNetUserRoles");

            migrationBuilder.DropTable(
                name: "AspNetUserTokens");

            migrationBuilder.DropTable(
                name: "AspNetRoles");

            migrationBuilder.DropTable(
                name: "AspNetUsers");
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Data\Migrations\ApplicationDbContextModelSnapshot.cs ---


// <auto-generated />
using System;
using MicroPluberd.Examples.Blazor.Identity.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

#nullable disable

namespace MicroPluberd.Examples.Blazor.Identity.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 128);

            SqlServerModelBuilderExtensions.UseIdentityColumns(modelBuilder);

            modelBuilder.Entity("MicroPluberd.Examples.Blazor.Identity.Data.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("int");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Email")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("bit");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("bit");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("datetimeoffset");

                    b.Property<string>("NormalizedEmail")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.Property<string>("NormalizedUserName")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("bit");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("nvarchar(max)");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("bit");

                    b.Property<string>("UserName")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedEmail")
                        .HasDatabaseName("EmailIndex");

                    b.HasIndex("NormalizedUserName")
                        .IsUnique()
                        .HasDatabaseName("UserNameIndex")
                        .HasFilter("[NormalizedUserName] IS NOT NULL");

                    b.ToTable("AspNetUsers", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRole", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("ConcurrencyStamp")
                        .IsConcurrencyToken()
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("Name")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.Property<string>("NormalizedName")
                        .HasMaxLength(256)
                        .HasColumnType("nvarchar(256)");

                    b.HasKey("Id");

                    b.HasIndex("NormalizedName")
                        .IsUnique()
                        .HasDatabaseName("RoleNameIndex")
                        .HasFilter("[NormalizedName] IS NOT NULL");

                    b.ToTable("AspNetRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("ClaimType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("RoleId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetRoleClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.Property<int>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("int");

                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));

                    b.Property<string>("ClaimType")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("ClaimValue")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("Id");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserClaims", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.Property<string>("LoginProvider")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("ProviderKey")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("ProviderDisplayName")
                        .HasColumnType("nvarchar(max)");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("LoginProvider", "ProviderKey");

                    b.HasIndex("UserId");

                    b.ToTable("AspNetUserLogins", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("RoleId")
                        .HasColumnType("nvarchar(450)");

                    b.HasKey("UserId", "RoleId");

                    b.HasIndex("RoleId");

                    b.ToTable("AspNetUserRoles", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.Property<string>("UserId")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("LoginProvider")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Name")
                        .HasColumnType("nvarchar(450)");

                    b.Property<string>("Value")
                        .HasColumnType("nvarchar(max)");

                    b.HasKey("UserId", "LoginProvider", "Name");

                    b.ToTable("AspNetUserTokens", (string)null);
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityRoleClaim<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserClaim<string>", b =>
                {
                    b.HasOne("MicroPluberd.Examples.Blazor.Identity.Data.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserLogin<string>", b =>
                {
                    b.HasOne("MicroPluberd.Examples.Blazor.Identity.Data.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserRole<string>", b =>
                {
                    b.HasOne("Microsoft.AspNetCore.Identity.IdentityRole", null)
                        .WithMany()
                        .HasForeignKey("RoleId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.HasOne("MicroPluberd.Examples.Blazor.Identity.Data.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("Microsoft.AspNetCore.Identity.IdentityUserToken<string>", b =>
                {
                    b.HasOne("MicroPluberd.Examples.Blazor.Identity.Data.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });
#pragma warning restore 612, 618
        }
    }
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Data\ApplicationDbContext.cs ---


using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;

namespace MicroPluberd.Examples.Blazor.Identity.Data;

public class ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : IdentityDbContext<ApplicationUser>(options)
{
}



// --- File: MicroPluberd.Examples.Blazor.Identity\Data\ApplicationUser.cs ---


using Microsoft.AspNetCore.Identity;

namespace MicroPluberd.Examples.Blazor.Identity.Data;

// Add profile data for application users by adding properties to the ApplicationUser class
public class ApplicationUser : IdentityUser
{
}




// --- File: MicroPluberd.Examples.Blazor.Identity\Program.cs ---


using Microsoft.AspNetCore.Components.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using MudBlazor.Services;
using MicroPluberd.Examples.Blazor.Identity.Components;
using MicroPluberd.Examples.Blazor.Identity.Components.Account;
using MicroPluberd.Examples.Blazor.Identity.Data;

namespace MicroPluberd.Examples.Blazor.Identity;

public class Program
{
    public static void Main(string[] args)
    {
        var builder = WebApplication.CreateBuilder(args);

        // Add MudBlazor services
        builder.Services.AddMudServices();

        // Add services to the container.
        builder.Services.AddRazorComponents()
            .AddInteractiveServerComponents();

        builder.Services.AddCascadingAuthenticationState();
        builder.Services.AddScoped<IdentityUserAccessor>();
        builder.Services.AddScoped<IdentityRedirectManager>();
        builder.Services.AddScoped<AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider>();

        builder.Services.AddAuthentication(options =>
            {
                options.DefaultScheme = IdentityConstants.ApplicationScheme;
                options.DefaultSignInScheme = IdentityConstants.ExternalScheme;
            })
            .AddIdentityCookies();

        var connectionString = builder.Configuration.GetConnectionString("DefaultConnection") ?? throw new InvalidOperationException("Connection string 'DefaultConnection' not found.");
        builder.Services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlServer(connectionString));
        builder.Services.AddDatabaseDeveloperPageExceptionFilter();
            
        
        builder.Services.AddIdentityCore<ApplicationUser>(options => options.SignIn.RequireConfirmedAccount = true)
            .AddEntityFrameworkStores<ApplicationDbContext>()
            .AddSignInManager()
            .AddDefaultTokenProviders();

        builder.Services.AddSingleton<IEmailSender<ApplicationUser>, IdentityNoOpEmailSender>();

        var app = builder.Build();

        // Configure the HTTP request pipeline.
        if (app.Environment.IsDevelopment())
        {
            app.UseMigrationsEndPoint();
        }
        else
        {
            app.UseExceptionHandler("/Error");
        }

        app.UseAntiforgery();

        app.MapStaticAssets();
        app.MapRazorComponents<App>()
            .AddInteractiveServerRenderMode();

        // Add additional endpoints required by the Identity /Account Razor components.
        app.MapAdditionalIdentityEndpoints();

        app.Run();
    }
}



// --- File: MicroPlumberd\Abstractions\AcceptedTypeAttribute.cs ---


namespace MicroPlumberd;

/// <summary>
/// Attribute used to decorate dispatching method to list possible concrete types. It is when code gets generated by source generators.
/// </summary>
/// <seealso cref="System.Attribute" />
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public class AcceptedTypeAttribute : Attribute
{
    public AcceptedTypeAttribute(Type acceptedType)
    {
        AcceptedType = acceptedType;
    }
    /// <summary>
    /// Gets or sets the accepted type of dispatching method.
    /// </summary>
    /// <value>
    /// The type that is accepted by dispatching method.
    /// </value>
    public Type AcceptedType { get; init; }
}


// --- File: MicroPlumberd\Abstractions\AggregateAttribute.cs ---


namespace MicroPlumberd;

/// <summary>
/// Attribute that is used on aggregates. When a class is marked with this attribute, source generators will generate partial class
/// that contains all boring dispatching code and metadata for plumberd to do its job.
/// </summary>
/// <seealso cref="System.Attribute" />
[AttributeUsage(AttributeTargets.Class)]
public class AggregateAttribute : Attribute
{
    private int _snapshotEvery = -1;
    private long _snapshotAfter = -1;
    public Type? SnaphotPolicy { get; set; }

    /// <summary>
    /// Gets or sets the number of events from the last snapshot before a new one is performed.
    /// </summary>
    /// <value>
    /// The snapshot every.
    /// </value>
    public int SnapshotEvery
    {
        get => _snapshotEvery;
        set { _snapshotEvery = value;
            SnaphotPolicy = typeof(ISnapshotPolicy<>);
        }
    }
    /// <summary>
    /// Gets or sets the time from last snapshots (in seconds) before a new one is performed.
    /// </summary>
    public long SnapshotAfter
    {
        get => _snapshotAfter;
        set
        {
            _snapshotAfter = value;
            SnaphotPolicy = typeof(ISnapshotPolicy<>);
        }
    }
}

/// <summary>
/// Interface for creating snapshot policies, that manage when a snapshot is performed on an aggregate.
/// </summary>
/// <typeparam name="T"></typeparam>
public interface ISnapshotPolicy<in T> : ISnapshotPolicy
{
    bool ShouldMakeSnapshot(T aggregate, StateInfo? info);
}


// --- File: MicroPlumberd\Abstractions\AttributeSnaphotPolicy.cs ---


using System.Reflection;

namespace MicroPlumberd;

/// <summary>
/// Standard snapshot policy that takes into the account time and minimal event occurence from the last taken snapshot.
/// </summary>
/// <typeparam name="T"></typeparam>
/// <seealso cref="MicroPlumberd.ISnapshotPolicy&lt;T&gt;" />
public class AttributeSnaphotPolicy<T> : ISnapshotPolicy<T>
    where T:IAggregate
{
    public AttributeSnaphotPolicy()
    {
        var att = typeof(T).GetCustomAttribute<AggregateAttribute>();
        this.MinTime = att.SnapshotAfter > 0 ? TimeSpan.FromSeconds(att.SnapshotAfter) : null;
        this.MinEventCount = att.SnapshotEvery > 0 ? att.SnapshotEvery : null;
    }

    public int? MinEventCount { get; }

    public TimeSpan? MinTime { get; }

    public virtual bool ShouldMakeSnapshot(T aggregate, StateInfo? info)
    {
        var n = DateTimeOffset.Now;
        var i = info ?? new StateInfo(-1, n);
        return MinEventCount.HasValue && aggregate.Version - i.Version >= MinEventCount.Value || 
               MinTime.HasValue && n.Subtract(i.Created) >= MinTime.Value;
    }

    public bool ShouldMakeSnapshot(object owner, StateInfo? info) => this.ShouldMakeSnapshot((T)owner, info);
}


// --- File: MicroPlumberd\Abstractions\EventHandlerAttribute.cs ---


namespace MicroPlumberd;

/// <summary>
/// Attribute that marks a class that is an EventHandler for code-generation. This is usually a read-model or a processor.
/// </summary>
/// <seealso cref="System.Attribute" />
[AttributeUsage(AttributeTargets.Class)]
public class EventHandlerAttribute : Attribute { }




// --- File: MicroPlumberd\Abstractions\IAggregate.cs ---


using System;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Security.Cryptography;
using System.Text;
using Grpc.Core;
using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd;

/// <summary>
/// A named delegate used for recognizing event type from a string.
/// </summary>
/// <param name="type">The type.</param>
/// <param name="t">The t.</param>
/// <returns></returns>
public delegate bool TypeEventConverter(string type, out Type t);

/// <summary>
/// ITypeRegister is used to indicate which event types are supported by the class.
/// </summary>
public interface ITypeRegister
{
    /// <summary>
    /// Supported event types.
    /// </summary>
    /// <value>
    /// Supported types.
    /// </value>
    static abstract IEnumerable<Type> Types { get; }
    
}


/// <summary>
/// Interface for an aggregate.
/// </summary>
/// <seealso cref="MicroPlumberd.IId" />
/// <seealso cref="MicroPlumberd.IVersioned" />
public interface IAggregate : IVersioned
{
    /// <summary>
    /// Pending events.
    /// </summary>
    /// <value>
    /// The pending events.
    /// </value>
    IReadOnlyList<object> PendingEvents { get; }

    /// <summary>
    /// Rehydrates aggregate with specified events.
    /// </summary>
    /// <param name="events">The events.</param>
    /// <returns></returns>
    Task Rehydrate(IAsyncEnumerable<object> events);

    /// <summary>
    /// Is used when all pending events are saved in eventstore.
    /// </summary>
    void AckCommitted();
}

/// <summary>
/// Simple interface for versioned objects.
/// </summary>
public interface IVersioned
{
    /// <summary>
    /// Gets the current version.
    /// </summary>
    /// <value>
    /// The version.
    /// </value>
    long Version { get; }
}


/// <summary>
/// Interface for increasing the version.
/// </summary>
/// <seealso cref="MicroPlumberd.IVersioned" />
public interface IVersionAware : IVersioned
{
    long Version { get; set; }
    void Increase() => this.Version += 1;
}
static class Extensions
{
    public static string Remove(this string t, string word) => t.Replace(word, string.Empty);
    public static byte[] ToHash(this string t)
    {
        using (SHA256 shA256 = SHA256.Create())
        {
            byte[] hash = shA256.ComputeHash(Encoding.Default.GetBytes(t));
            ulong uint64_1 = BitConverter.ToUInt64(hash, 0);
            ulong uint64_2 = BitConverter.ToUInt64(hash, 8);
            ulong uint64_3 = BitConverter.ToUInt64(hash, 16);
            ulong uint64_4 = BitConverter.ToUInt64(hash, 24);
            ulong num1 = uint64_1 ^ uint64_3;
            ulong num2 = uint64_2 ^ uint64_4;
            Memory<byte> memory = new Memory<byte>(new byte[16]);
            BitConverter.TryWriteBytes(memory.Span, num1);
            BitConverter.TryWriteBytes(memory.Slice(8, 8).Span, num2);
            return memory.ToArray();
        }
    }

    public static Guid ToGuid(this string t) => new Guid(t.ToHash());

    public static byte[] NameHash(this Type t1)
    {
        return _hashCache.GetOrAdd(t1, (Func<Type, byte[]>)(t2 => t2.FullName.ToHash()));
    }
    private static ConcurrentDictionary<Type, byte[]> _hashCache = new ConcurrentDictionary<Type, byte[]>();

    public static Guid NameId(this Type t) => new Guid(t.NameHash());
}
public interface IId
{
    object Id { get; }

    Guid Uuid
    {
        get
        {
            if(Id is Guid g) return g;
            if(Id == null) return Guid.Empty;
            return Id.ToString().ToGuid();
        }
    }
}


public interface IId<out T>  : IId
    where T:IParsable<T>
{
    new T Id { get; }
    object IId.Id => Id;
}

public interface IIdAware 
{
    object Id { get; set; }
}

public interface IIdAware<T> : IIdAware
    where T : IParsable<T>
{
    new T Id { get; set; }
    
    object IIdAware.Id
    {
        get => Id;
        set => Id = (T)value;
    }
}

/// <summary>
/// Generic version of IAggregate interface that contains factory method.
/// </summary>
/// <typeparam name="TSelf">The type of the self.</typeparam>
/// <seealso cref="MicroPlumberd.IVersioned" />
public interface IAggregate<out TSelf> : IAggregate
{
    /// <summary>
    /// Factory method to create new Aggregates based on identifiers.
    /// </summary>
    /// <param name="id">The identifier.</param>
    /// <returns></returns>
    static abstract TSelf Empty(object id);
   
}


// --- File: MicroPlumberd\Abstractions\IObjectSerializer.cs ---


using System.Text.Json;

namespace MicroPlumberd;

/// <summary>
/// Object serializer used for event data and metadata serialization.
/// </summary>
public interface IObjectSerializer
{
    /// <summary>
    /// Deserializes the specified span for event's data.
    /// </summary>
    /// <param name="span">The span.</param>
    /// <param name="t">The t.</param>
    /// <returns></returns>
    object? Deserialize(ReadOnlySpan<byte> span, Type t);
    /// <summary>
    /// Parses span a JsonElement of the metadata.
    /// </summary>
    /// <param name="span">The span.</param>
    /// <returns></returns>
    JsonElement ParseMetadata(ReadOnlySpan<byte> span);

    /// <summary>
    /// Serializes the specified object.
    /// </summary>
    /// <param name="t">The t.</param>
    /// <returns></returns>
    byte[] Serialize(object? t);
    /// <summary>
    /// Gets the type of the content. (application/json or application/octet-stream)
    /// </summary>
    /// <value>
    /// The type of the content.
    /// </value>
    string ContentType { get; }
}


// --- File: MicroPlumberd\Abstractions\IPlumber.cs ---


using EventStore.Client;
namespace MicroPlumberd;

/// <summary>
/// Represents a snapshot object used in Plumberd.
/// </summary>
public interface ISnapshot
{
    /// <summary>
    /// Gets the data of the snapshot.
    /// </summary>
    object Data { get; }
    
    /// <summary>
    /// Gets the creation date of the snapshot.
    /// </summary>
    DateTimeOffset Created { get; }
    
    /// <summary>
    /// Gets the version of the snapshot.
    /// </summary>
    long Version { get; }
}

public record SubscriptionRunnerState<T>(T Value, Metadata Metadata)
{
    public static implicit operator T?(SubscriptionRunnerState<T>? st) => st != null ? st.Value : default;
}
/// <summary>
/// Represents a snapshot object used in Plumberd.
/// </summary>
public abstract record Snapshot
{
    internal abstract object Value { get; set; }
    
    /// <summary>
    /// Gets the creation date of the snapshot.
    /// </summary>
    public DateTimeOffset Created { get; internal set; }
    
    /// <summary>
    /// Gets the version of the snapshot.
    /// </summary>
    public long Version { get; internal set; }
}

/// <summary>
/// Represents a generic snapshot object used in Plumberd.
/// </summary>
/// <typeparam name="T">The type of the snapshot data.</typeparam>
public sealed record Snapshot<T> : Snapshot, ISnapshot
{
    object ISnapshot.Data => Data;
    
    /// <summary>
    /// Gets the data of the snapshot.
    /// </summary>
    public T Data { get; internal set; }

    public static implicit operator T(Snapshot<T> st) => st.Data;
    internal override object Value
    {
        get => Data;
        set => Data = (T)value;
    }
}


/// <summary>
/// Root interface for plumberd
/// </summary>
public interface IPlumber
{
    /// <summary>
    /// Plubers configuration.
    /// </summary>
    IPlumberReadOnlyConfig Config { get; }
    
    /// <summary>
    /// EventStore's client
    /// </summary>
    EventStoreClient Client { get; }
    /// <summary>
    /// EventStore's persistent subsctiption client
    /// </summary>
    EventStorePersistentSubscriptionsClient PersistentSubscriptionClient { get; }
    /// <summary>
    /// EventStore's projection managemenet client
    /// </summary>
    EventStoreProjectionManagementClient ProjectionManagementClient { get; }
    /// <summary>
    /// Projection's register, responsible for caching information about projection from EventStore.
    /// </summary>
    IProjectionRegister ProjectionRegister { get; }
    /// <summary>
    /// Metadata information about registered event-handlers.
    /// </summary>
    ITypeHandlerRegisters TypeHandlerRegisters { get; }
    
    /// <summary>
    /// Appends event to a stream, uses relevant convention to create metadata.
    /// </summary>
    /// <param name="streamId">Full stream id, typically in format {category}-{id}</param>
    /// <param name="rev">Expected stream revision</param>
    /// <param name="events">Events that are going to be serialized and appended</param>
    /// <param name="metadata">Metadata that will be merged with metadata created from conventions</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendEvents(string streamId, StreamRevision rev, IEnumerable<object> events,
        object? metadata = null, CancellationToken token = default);

    /// <summary>
    /// Appends event to a stream, uses relevant convention to create metadata.
    /// </summary>
    /// <param name="streamId">Full name of streamId for example: 'TicketBooked-b27f9322-7d73-4d98-a605-a731a2c373c6'</param>
    /// <param name="evt">Event object</param>
    /// <param name="state">Expected state of the stream</param>
    /// <param name="evtName">Name of the event</param>
    /// <param name="metadata">Additional metadata, can be null</param>
    /// <returns></returns>
    Task<IWriteResult> AppendEventToStream(string streamId, object evt, StreamState? state = null, string? evtName = null,
        object? metadata = null, CancellationToken token = default);

    /// <summary>
    /// Appends event to a stream, uses relevant convention to create metadata.
    /// </summary>
    /// <param name="streamId">Full stream id, typically in format {category}-{id}</param>
    /// <param name="state">State of the stream</param>
    /// <param name="events">Events that are going to be serialized and appended</param>
    /// <param name="metadata">Metadata that will be merged with metadata created from conventions</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendEvents(string streamId, StreamState state, IEnumerable<object> events,
        object? metadata = null, CancellationToken token = default);

    /// <summary>
    /// Appends event to a stream, uses relevant convention to create metadata.
    /// </summary>
    /// <param name="streamId">Full name of streamId for example: 'TicketBooked-b27f9322-7d73-4d98-a605-a731a2c373c6'</param>
    /// <param name="state"></param>
    /// <param name="events"></param>
    /// <returns></returns>
    Task AppendEvents(string streamId, StreamState state, params object[] events) => AppendEvents(streamId, state, events,null);

    /// <summary>
    /// Finds the event in the stream.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="streamId">The stream identifier.</param>
    /// <param name="id">The identifier of the event.</param>
    /// <param name="eventMapping">The event mapping.</param>
    /// <param name="scanDirection">The scan direction.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IEventRecord<T>?> FindEventInStream<T>(string streamId, Guid id, TypeEventConverter eventMapping = null,
        Direction scanDirection = Direction.Backwards, CancellationToken token = default);

    /// <summary>
    /// Finds the event in the stream.
    /// </summary>
    /// <param name="streamId">The stream identifier.</param>
    /// <param name="id">The identifier of the event.</param>
    /// <param name="eventMapping">The event mapping.</param>
    /// <param name="scanDirection">The scan direction.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IEventRecord?> FindEventInStream(string streamId, Guid id, TypeEventConverter eventMapping,
        Direction scanDirection = Direction.Backwards, CancellationToken token = default);

    /// <summary>
    /// Returns a builder for creating composition of projections subscribed to a stream.
    /// </summary>
    /// <returns></returns>
    ISubscriptionSet SubscribeSet();

    /// <summary>
    /// Subscribes the specified stream name.
    /// </summary>
    /// <param name="streamName">Name of the stream.</param>
    /// <param name="start">The start position</param>
    /// <param name="userCredentials">The user credentials.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns></returns>
    ISubscriptionRunner Subscribe(string streamName, FromRelativeStreamPosition start, UserCredentials? userCredentials = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Subscribes the event handler. EventHandler is a class that contains many overloaded 'Given' methods. A projection will be created at EventStore that creates a joined stream from all supported event-types by EventHandler.
    /// Then EventHandler subscribe the the output stream.
    /// </summary>
    /// <typeparam name="TEventHandler">The type of the event handler.</typeparam>
    /// <param name="mapFunc">The map function.</param>
    /// <param name="eventTypes">Supported event types.</param>
    /// <param name="eh">The event-handler</param>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="start">The start of the stream</param>
    /// <param name="ensureOutputStreamProjection">if set to <c>true</c> [ensure output stream projection].</param>
    /// <returns></returns>
    Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TypeEventConverter mapFunc,
        IEnumerable<string>? eventTypes,
        TEventHandler? eh = default, string? outputStream = null,
        FromStream? start = null, 
        bool ensureOutputStreamProjection = true) 
        where TEventHandler:class,IEventHandler;


    /// <summary>
    /// Subscribes the event handler. EventHandler is a class that contains many overloaded 'Given' methods. A projection will be created at EventStore that creates a joined stream from all supported event-types by EventHandler.
    /// Then EventHandler subscribe the output stream.
    /// </summary>
    /// <typeparam name="TEventHandler">The type of the event handler.</typeparam>
    /// <param name="eh">The event-handler/model</param>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="start">The start.</param>
    /// <param name="ensureOutputStreamProjection">if set to <c>true</c> [ensure output stream projection].</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TEventHandler? eh = default, string? outputStream = null, FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true, CancellationToken token = default)
        where TEventHandler : class, IEventHandler, ITypeRegister;


    /// <summary>
    /// Subscribes the event handler persistently. EventHandler is a class that contains many overloaded 'Given' methods. A projection will be created at EventStore that creates a joined stream from all supported event-types by EventHandler.
    /// Then EventHandler subscribe the the output stream.
    /// </summary>
    /// <typeparam name="TEventHandler">The type of the event handler.</typeparam>
    /// <param name="model">Optional event-handler/model.</param>
    /// <param name="outputStream">Optional output stream.</param>
    /// <param name="groupName">Optional group name.</param>
    /// <param name="startFrom">Optional start of the stream.</param>
    /// <param name="ensureOutputStreamProjection">when true creates projection that creates output's stream</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TEventHandler? model=null, string? outputStream = null, string? groupName = null, IPosition? startFrom = null, bool ensureOutputStreamProjection = true, int minCheckPointCount=1, CancellationToken token = default) 
        where TEventHandler : class,IEventHandler, ITypeRegister;

    /// <summary>
    /// Returns a subscription builder that will subscribe model persistently.
    /// </summary>
    /// <param name="streamName">Name of the stream.</param>
    /// <param name="groupName">Name of the group.</param>
    /// <param name="bufferSize">Size of the buffer.</param>
    /// <param name="userCredentials">The user credentials.</param>
    /// <param name="cancellationToken">The cancellation token.</param>
    /// <returns></returns>
    ISubscriptionRunner SubscribePersistently(string streamName, string groupName, int bufferSize = 10, UserCredentials? userCredentials = null,CancellationToken cancellationToken = new CancellationToken());

    /// <summary>
    /// Rehydrates the specified model.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="model">The model.</param>
    /// <param name="stream">The stream.</param>
    /// <param name="position">The position.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task Rehydrate<T>(T model, string stream, StreamPosition? position = null, CancellationToken token = default) where T : IEventHandler, ITypeRegister;

    /// <summary>
    /// Rehydrates the specified model
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="model">The model.</param>
    /// <param name="id">The identifier.</param>
    /// <param name="position">The position from which reply events.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task Rehydrate<T>(T model, Guid id, StreamPosition? position = null,  CancellationToken token = default) where T : IEventHandler, ITypeRegister;

    Task Rehydrate<T>(T model, string streamId, TypeEventConverter converter, StreamPosition? position = null,
        CancellationToken token = default)
        where T : IEventHandler;

    /// <summary>
    /// Returns the aggregate identified by id.
    /// This usually mean that all the event will be loaded from the EventStoreDB and executed through 'Given' method on it's instance. 
    /// If the aggregate supports snapshoting, it's state will be loaded from latest snapshot and relevant events from that time will be replied on it's instance.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="id">The identifier.</param>
    /// <param name="token"></param>
    /// <returns></returns>
   Task<T> Get<T>(object id, CancellationToken token = default) where T : IAggregate<T>, ITypeRegister,IId;

    /// <summary>
    /// Saves all pending events from the aggregate. Uses optimistic concurrency.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="aggregate">The aggregate.</param>
    /// <param name="metadata">The optional metadata.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> SaveChanges<T>(T aggregate, object? metadata = null, CancellationToken token = default) where T : IAggregate<T>, IId;

    /// <summary>
    /// Saves the aggregate. Expects that no aggregate exists. 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="aggregate">The aggregate.</param>
    /// <param name="metadata">The optional metadata.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> SaveNew<T>(T aggregate, object? metadata = null, CancellationToken token = default) where T : IAggregate<T>, IId;

    /// <summary>
    /// Gets the snapshot - deserializes snapshot from the stream. Stream is identified by typeof(T). Deserialization is done from the latest event (snaphost) in the stream.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="id">The identifier.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<Snapshot<T>?> GetSnapshot<T>(Guid id, CancellationToken token = default);

    /// <summary>
    /// Gets the snapshot - deserializes snapshot from the stream. Stream is identified by snaphostType. Deserialization is done from the latest event (snaphost) in the stream.
    /// </summary>
    /// <param name="id">The identifier.</param>
    /// <param name="snapshotType">Type of the snapshot.</param>
    /// <param name="token"></param>
    /// <returns>The snapshot information containing the snaphost and relevant metadata.</returns>
    Task<Snapshot?> GetSnapshot(object id, Type snapshotType, CancellationToken token = default);

    /// <summary>
    /// Appends the link to a stream.
    /// </summary>
    /// <param name="streamId">The stream identifier.</param>
    /// <param name="metadata">The metadata.</param>
    /// <param name="state">The expected state of the stream</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendLink(string streamId, Metadata metadata, StreamState? state = null,
        CancellationToken token = default);

    /// <summary>
    /// Subscribes the event handler persistently. This means that at least once an event is processed successfully, it wont be processed anymore.
    /// </summary>
    /// <typeparam name="TEventHandler">The type of the event handler.</typeparam>
    /// <param name="mapFunc">The map function.</param>
    /// <param name="events">The events.</param>
    /// <param name="model">The model.</param>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="groupName">Name of the group.</param>
    /// <param name="startFrom">The start from.</param>
    /// <param name="ensureOutputStreamProjection">if set to <c>true</c> [ensure output stream projection].</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TypeEventConverter mapFunc,
        IEnumerable<string>? events,
        TEventHandler? model,
        string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
        bool ensureOutputStreamProjection = true,int minCheckPointCount=1, CancellationToken token = default)
        where TEventHandler : class, IEventHandler;

    /// <summary>
    /// Reads stream and returns events.
    /// Conventions used:
    /// ProjectionCategoryStreamConvention - to construct streamId that shall be read.
    /// </summary>
    /// <typeparam name="TOwner">The type of the owner (aggregate).</typeparam>
    /// <param name="id">The identifier (of the aggregate).</param>
    /// <param name="start">The stream start position.</param>
    /// <param name="direction">The direction of the reading.</param>
    /// <param name="maxCount">The maximum number of read events.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    IAsyncEnumerable<object> Read<TOwner>(object id, StreamPosition? start = null, Direction? direction = null,
        long maxCount = 9223372036854775807L, CancellationToken token = default) where TOwner : ITypeRegister;

    /// <summary>
    /// Reads stream and returns events.
    /// Conventions used:
    /// ProjectionCategoryStreamConvention - to construct streamId that shall be read.
    /// </summary>
    /// <typeparam name="TOwner">The type of the owner(aggregate).</typeparam>
    /// <param name="start">The stream start position.</param>
    /// <param name="direction">The direction of the reading.</param>
    /// <param name="maxCount">The maximum number of read events.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    IAsyncEnumerable<object> Read<TOwner>(StreamPosition? start = null, Direction? direction = null,
        long maxCount = 9223372036854775807L, CancellationToken token = default) where TOwner : ITypeRegister;

    /// <summary>
    /// Reads stream and returns events.
    /// </summary>
    /// <param name="streamId">The full stream name</param>
    /// <param name="converter">The event-map converter.</param>
    /// <param name="start">The stream start position.</param>
    /// <param name="direction">The direction of the reading.</param>
    /// <param name="maxCount">The maximum number of read events.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    IAsyncEnumerable<object> Read(string streamId, TypeEventConverter converter, StreamPosition? start = null,
        Direction? direction = null, long maxCount = 9223372036854775807L, CancellationToken token = default);

    /// <summary>
    /// Reads stream and returns event and metadata information.
    /// </summary>
    /// <param name="streamId">The full stream name</param>
    /// <param name="converter">The event-map converter.</param>
    /// <param name="start">The stream start position.</param>
    /// <param name="direction">The direction of the reading.</param>
    /// <param name="maxCount">The maximum number of read events.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    IAsyncEnumerable<(object, Metadata)> ReadFull(string streamId, TypeEventConverter converter,
        StreamPosition? start = null, Direction? direction = null, long maxCount = 9223372036854775807L,
        CancellationToken token = default);


    /// <summary>
    /// Appends the snapshot to a stream determined by the type of the snapshot/state.
    /// </summary>
    /// <param name="snapshot">The snapshot.</param>
    /// <param name="id">The identifier of the snapshot/state.</param>
    /// <param name="version">The expected version.</param>
    /// <param name="state">The expected state of the stream.</param>
    /// <returns></returns>
    Task<IWriteResult> AppendSnapshot(object snapshot, object id, long version, StreamState? state = null, CancellationToken token = default);

    /// <summary>
    /// Appends the event. StreamId is determined using conventions.
    /// </summary>
    /// <param name="evt">The evt.</param>
    /// <param name="id">The identifier of stream.(second segment of typical streamId, So if streamId is 'foo-123', 123 would be the id.)</param>
    /// <param name="metadata">Optional metadata.</param>
    /// <param name="state">Expected state.</param>
    /// <param name="evtName">Optional name of the event.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendEvent(object evt, object? id = null, object? metadata = null, StreamState? state = null,
        string? evtName = null, CancellationToken token = default);

    /// <summary>
    /// Appends the link.
    /// </summary>
    /// <param name="streamId">The stream identifier.</param>
    /// <param name="streamPosition">Stream position in original stream</param>
    /// <param name="streamSourceId">The stream source identifier.</param>
    /// <param name="state">Optional expected stream state.</param>
    /// <returns></returns>
    Task<IWriteResult> AppendLink(string streamId, ulong streamPosition, string streamSourceId,
        StreamState? state = null, CancellationToken token = default);

    /// <summary>
    /// Updates or adds simple entity/state. Be aware, that rdb constraints are not possible.
    /// </summary>
    /// <param name="state">The entity.</param>
    /// <param name="id">The identifier.</param>
    /// <param name="version">The version.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendState(object state, object id, long? version = null, CancellationToken token = default);

    /// <summary>
    /// Updates or adds simple entity/state. Be aware, that rdb constraints are not possible.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="state">The entity.</param>
    /// <param name="token"></param>
    /// <returns></returns>
    Task<IWriteResult> AppendState<T>(T state, CancellationToken token = default);

    Task<SubscriptionRunnerState<T>?> GetState<T>(object id, string? streamId = null, CancellationToken token = default) where T:class;

    IAsyncEnumerable<(T, Metadata)> ReadEventsOfType<T>(string? streamId = null,
        StreamPosition? start = null, Direction? direction = null, long maxCount = 9223372036854775807L,
        CancellationToken token = default);

    Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(
        IEnumerable<string>? eventTypes, 
        TEventHandler? eh = default,
        string? outputStream = null,
        FromRelativeStreamPosition? start = null, 
        bool ensureOutputStreamProjection = true, 
        CancellationToken token = default)
        where TEventHandler : class, IEventHandler, ITypeRegister;

    Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(TEventHandler? eh = null,
        string? outputStream = null,
        FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
        CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister;

    /// <summary>
    /// Ensures that a join projection is created or updated for the specified output stream and event types.
    /// </summary>
    /// <param name="outputStream">
    /// The name of the output stream where the projection results will be written.
    /// </param>
    /// <param name="eventTypes">
    /// A collection of event type names to be included in the join projection.
    /// </param>
    /// <param name="token">
    /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
    /// </param>
    /// <returns>
    /// A <see cref="Task"/> representing the asynchronous operation.
    /// </returns>
    Task TryCreateJoinProjection(string outputStream, IEnumerable<string> eventTypes, CancellationToken token = default);

    /// <summary>
    /// Ensures that a join projection is created for the specified event handler type.
    /// </summary>
    /// <typeparam name="TEventHandler">
    /// The type of the event handler, which must implement both <see cref="IEventHandler"/> and <see cref="ITypeRegister"/>.
    /// </typeparam>
    /// <param name="outputStream">
    /// The name of the output stream for the join projection. If <c>null</c>, the output stream name is determined
    /// using the <see cref="IReadOnlyConventions.OutputStreamModelConvention"/> for the specified event handler type.
    /// </param>
    /// <param name="token">
    /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
    /// </param>
    /// <returns>
    /// A <see cref="Task"/> representing the asynchronous operation.
    /// </returns>
    Task TryCreateJoinProjection<TEventHandler>(string? outputStream=null, CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister;

    /// <summary>
    /// Appends metadata to a stream derived from the specified event type and identifier.
    /// </summary>
    /// <typeparam name="TEvent">The type of the event associated with the stream.</typeparam>
    /// <param name="id">The identifier of the event, used to derive the stream name.</param>
    /// <param name="state">The optional state of the stream (e.g., existing or new).</param>
    /// <param name="maxAge">The optional maximum age for events in the stream.</param>
    /// <param name="truncateBefore">The optional position before which events should be truncated.</param>
    /// <param name="cacheControl">The optional cache control duration for the stream.</param>
    /// <param name="acl">The optional access control list for the stream.</param>
    /// <param name="maxCount">The optional maximum number of events allowed in the stream.</param>
    /// <returns>A task that represents the asynchronous operation, containing the result of the write operation.</returns>
    /// <remarks>
    /// The stream name is derived using the <see cref="IReadOnlyConventions.StreamNameFromEventConvention"/> convention.
    /// </remarks>
    Task<IWriteResult> AppendStreamMetadataFromEvent<TEvent>(
        object id,
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null);

    /// <summary>
    /// Appends metadata to a stream based on the specified handler type.
    /// </summary>
    /// <typeparam name="THandler">
    /// The type of the handler that determines the stream for which metadata will be appended.
    /// </typeparam>
    /// <param name="state">
    /// The <see cref="StreamState"/> indicating the expected state of the stream. 
    /// If <c>null</c>, the operation will not check the stream's state.
    /// </param>
    /// <param name="maxAge">
    /// The maximum age of events in the stream. Events older than this value will be removed.
    /// </param>
    /// <param name="truncateBefore">
    /// The <see cref="StreamPosition"/> before which events will be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The duration for which the stream metadata can be cached.
    /// </param>
    /// <param name="acl">
    /// The access control list (<see cref="StreamAcl"/>) specifying permissions for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The maximum number of events allowed in the stream. Events exceeding this count will be removed.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains an <see cref="IWriteResult"/> 
    /// indicating the outcome of the operation.
    /// </returns>
    Task<IWriteResult> AppendStreamMetadataFromHandler<THandler>(
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null);

    /// <summary>
    /// Appends metadata to a stream associated with a specified aggregate type and identifier.
    /// </summary>
    /// <typeparam name="TAggregate">
    /// The type of the aggregate associated with the stream.
    /// </typeparam>
    /// <param name="id">
    /// The identifier of the aggregate.
    /// </param>
    /// <param name="state">
    /// The optional state of the stream, such as <see cref="StreamState"/>.
    /// </param>
    /// <param name="maxAge">
    /// The optional maximum age for events in the stream.
    /// </param>
    /// <param name="truncateBefore">
    /// The optional position before which events in the stream should be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The optional cache control duration for the stream.
    /// </param>
    /// <param name="acl">
    /// The optional access control list (ACL) for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The optional maximum number of events allowed in the stream.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains an <see cref="IWriteResult"/> 
    /// indicating the outcome of the operation.
    /// </returns>
    /// <remarks>
    /// This method uses the conventions defined in <see cref="IReadOnlyConventions"/> to determine the stream ID 
    /// based on the aggregate type and identifier.
    /// </remarks>
    Task<IWriteResult> AppendStreamMetadataFromAggregate<TAggregate>(
        object id,
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null);

    /// <summary>
    /// Appends metadata to a specified stream in the EventStore.
    /// </summary>
    /// <param name="streamId">The identifier of the stream to which metadata will be appended.</param>
    /// <param name="state">
    /// The expected state of the stream. If <c>null</c>, defaults to <see cref="StreamState.Any"/>.
    /// </param>
    /// <param name="maxAge">
    /// The maximum age of events in the stream. Events older than this value will be removed.
    /// </param>
    /// <param name="truncateBefore">
    /// The position in the stream before which events will be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The duration for which the stream metadata can be cached.
    /// </param>
    /// <param name="acl">
    /// The access control list (ACL) defining permissions for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The maximum number of events allowed in the stream. Events exceeding this count will be removed.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains the write result of the operation.
    /// </returns>
    Task<IWriteResult> AppendStreamMetadata(string streamId, StreamState? state, TimeSpan? maxAge, StreamPosition? truncateBefore,
        TimeSpan? cacheControl, StreamAcl? acl, int? maxCount);
}


// --- File: MicroPlumberd\Abstractions\IReadModel.cs ---


using EventStore.Client;

namespace MicroPlumberd;


/// <summary>
/// Interface for EventHandlers.
/// </summary>
/// <typeparam name="TOwner">The type of the owner.</typeparam>
/// <seealso cref="MicroPlumberd.IEventHandler" />
public interface IEventHandler<TOwner> : IEventHandler 
where TOwner:IEventHandler{ }

/// <summary>
/// Dispatching interface for EventHandlers.
/// </summary>
/// <seealso cref="MicroPlumberd.IEventHandler" />
public interface IEventHandler
{
    /// <summary>
    /// Dispatching method. Handles the specified metadata and event.
    /// </summary>
    /// <param name="m">The m.</param>
    /// <param name="ev">The ev.</param>
    /// <returns></returns>
    Task Handle(Metadata m, object ev);
}

/// <summary>
/// Interface for event-handlers to be invoke when a subscription has catchup.
/// </summary>
public interface ICaughtUpHandler
{
    Task CaughtUp();
}

/// <summary>
/// Subscription set builder.
/// </summary>
public interface ISubscriptionSet
{
    /// <summary>
    /// Withes the specified model.
    /// </summary>
    /// <typeparam name="TModel">The type of the model.</typeparam>
    /// <param name="model">The model.</param>
    /// <returns></returns>
    ISubscriptionSet With<TModel>(TModel model)
        where TModel : IEventHandler, ITypeRegister;

    /// <summary>
    /// Subscribes persistently.
    /// </summary>
    /// <param name="outputStream">The output stream.</param>
    /// <param name="groupName">Name of the group.</param>
    /// <returns></returns>
    Task SubscribePersistentlyAsync(string outputStream, string? groupName = null);

    /// <summary>
    /// Subscribes to stream.
    /// </summary>
    /// <param name="name">The name of the stream.</param>
    /// <param name="start">The start.</param>
    /// <returns></returns>
    Task SubscribeAsync(string name, FromStream start);
}


// --- File: MicroPlumberd\Abstractions\ISnapshotPolicy.cs ---


namespace MicroPlumberd;

/// <summary>
/// Interface for creating snapshot policies, that manage when a snapshot is performed on an aggregate.
/// </summary>
public interface ISnapshotPolicy
{
    bool ShouldMakeSnapshot(object owner, StateInfo? info);
}


// --- File: MicroPlumberd\Abstractions\ISubscriptionRunner.cs ---


namespace MicroPlumberd;

public interface ISubscriptionRunner : IAsyncDisposable
{
    Task<T> WithHandler<T>(T model) where T : IEventHandler, ITypeRegister;
    Task<T> WithHandler<T>(T model, TypeEventConverter mapFunc) where T : IEventHandler;
    Task<IEventHandler> WithHandler<T>() where T : IEventHandler, ITypeRegister;
    Task<IEventHandler> WithHandler<T>(TypeEventConverter mapFunc) where T : IEventHandler;
    Task<IEventHandler> WithHandler<T>(ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister;
    Task<IEventHandler> WithSnapshotHandler<T>() where T : IEventHandler, ITypeRegister;
    Task<IEventHandler> WithSnapshotHandler<T>(T model) where T : IEventHandler, ITypeRegister;
    Task<IEventHandler> WithHandler<T>(T model, ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister;
}


// --- File: MicroPlumberd\Abstractions\OutputStreamAttribute.cs ---


namespace MicroPlumberd;

/// <summary>
/// Use this attribute on Models where you want to override stream name convention. 
/// </summary>
/// <remarks>
/// Your read-models/event-handlers typically subscribe to a stream that comes from a merge of event-type streams.
/// If you have a FooModel:
/// <code>
/// [EventHandler]
/// [OutputStream("Foo")]
/// class FooModel {
/// public async Task Given(Metadata m, FooEvent1 ev) { }
/// public async Task Given(Metadata m, FooEvent2 ev) { }
/// }
/// </code>
/// Without the OutputStream attribute a projection would be made in EventStoreDB that produces FooModel stream out of
/// $et-FooEvent1 and $et-FooEvent2. But, since there is the attribute the produced stream will be named 'Foo'.
/// </remarks>
/// <seealso cref="System.Attribute" />
[AttributeUsage(AttributeTargets.Class)]
public class OutputStreamAttribute : Attribute
{
    public OutputStreamAttribute(string outputStreamName)
    {
        if (string.IsNullOrWhiteSpace(outputStreamName))
            throw new ArgumentException(nameof(outputStreamName));
        this.OutputStreamName = outputStreamName;
    }
    /// <summary>
    /// Gets or sets the name of the output stream, that is a joined stream from all event types used in model.
    /// </summary>
    /// <value>
    /// The name of the output stream.
    /// </value>
    public string OutputStreamName { get; }
}


// --- File: MicroPlumberd\Abstractions\StreamRelativePosition.cs ---


using EventStore.Client;

namespace MicroPlumberd;

public readonly struct FromRelativeStreamPosition
{
    private readonly FromStream _start;
    private readonly long _delta;
    public FromStream StartPosition => _start;
    public Direction Direction => _delta >= 0 ? Direction.Forwards : Direction.Backwards;
    public ulong Count => (ulong)(_delta >= 0 ? _delta : -_delta);
    public FromRelativeStreamPosition(FromStream start, long delta)
    {
        this._start = start;
        this._delta = delta;
    }

    public static implicit operator FromRelativeStreamPosition(FromStream st) => new FromRelativeStreamPosition(st, 0);
    public static FromRelativeStreamPosition Start => new FromRelativeStreamPosition(FromStream.Start, 0);
    public static FromRelativeStreamPosition End => new FromRelativeStreamPosition(FromStream.End, 0);
    public static FromRelativeStreamPosition operator ++(FromRelativeStreamPosition p) => new(p._start, p._delta + 1);
    public static FromRelativeStreamPosition operator --(FromRelativeStreamPosition p) => new(p._start, p._delta - 1);
    public static FromRelativeStreamPosition operator +(FromRelativeStreamPosition p, long d) =>
        new FromRelativeStreamPosition(p._start, p._delta + d);
    public static FromRelativeStreamPosition operator -(FromRelativeStreamPosition p, long d) =>
        new FromRelativeStreamPosition(p._start, p._delta - d);
}


// --- File: MicroPlumberd\Collections\ConcurrentHashSet.cs ---


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MicroPlumberd.Collections
{
    /// <summary>
    /// Represents a thread-safe hash-based unique collection.
    /// </summary>
    /// <typeparam name="T">The type of the items in the collection.</typeparam>
    /// <remarks>
    /// All public members of <see cref="ConcurrentHashSet{T}"/> are thread-safe and may be used
    /// concurrently from multiple threads.
    /// </remarks>
    [DebuggerDisplay("Count = {Count}")]
    public class ConcurrentHashSet<T> : IReadOnlyCollection<T>, ICollection<T>
    {
        private const int DefaultCapacity = 31;
        private const int MaxLockNumber = 1024;

        private readonly IEqualityComparer<T> _comparer;
        private readonly bool _growLockArray;

        private int _budget;
        private volatile Tables _tables;

        private static int DefaultConcurrencyLevel => Environment.ProcessorCount;

        /// <summary>
        /// Gets the <see cref="IEqualityComparer{T}" />
        /// that is used to determine equality for the values in the set.
        /// </summary>
        /// <value>
        /// The <see cref="IEqualityComparer{T}" /> generic interface implementation that is used to 
        /// provide hash values and determine equality for the values in the current <see cref="ConcurrentHashSet{T}" />.
        /// </value>
        /// <remarks>
        /// <see cref="ConcurrentHashSet{T}" /> requires an equality implementation to determine
        /// whether values are equal. You can specify an implementation of the <see cref="IEqualityComparer{T}" />
        /// generic interface by using a constructor that accepts a comparer parameter;
        /// if you do not specify one, the default generic equality comparer <see cref="EqualityComparer{T}.Default" /> is used.
        /// </remarks>
        public IEqualityComparer<T> Comparer => _comparer;

        /// <summary>
        /// Gets the number of items contained in the <see
        /// cref="ConcurrentHashSet{T}"/>.
        /// </summary>
        /// <value>The number of items contained in the <see
        /// cref="ConcurrentHashSet{T}"/>.</value>
        /// <remarks>Count has snapshot semantics and represents the number of items in the <see
        /// cref="ConcurrentHashSet{T}"/>
        /// at the moment when Count was accessed.</remarks>
        public int Count
        {
            get
            {
                var count = 0;
                var acquiredLocks = 0;
                try
                {
                    AcquireAllLocks(ref acquiredLocks);

                    var countPerLocks = _tables.CountPerLock;
                    for (var i = 0; i < countPerLocks.Length; i++)
                    {
                        count += countPerLocks[i];
                    }
                }
                finally
                {
                    ReleaseLocks(0, acquiredLocks);
                }

                return count;
            }
        }

        /// <summary>
        /// Gets a value that indicates whether the <see cref="ConcurrentHashSet{T}"/> is empty.
        /// </summary>
        /// <value>true if the <see cref="ConcurrentHashSet{T}"/> is empty; otherwise,
        /// false.</value>
        public bool IsEmpty
        {
            get
            {
                if (!AreAllBucketsEmpty())
                {
                    return false;
                }

                var acquiredLocks = 0;
                try
                {
                    AcquireAllLocks(ref acquiredLocks);

                    return AreAllBucketsEmpty();
                }
                finally
                {
                    ReleaseLocks(0, acquiredLocks);
                }
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see
        /// cref="ConcurrentHashSet{T}"/>
        /// class that is empty, has the default concurrency level, has the default initial capacity, and
        /// uses the default comparer for the item type.
        /// </summary>
        public ConcurrentHashSet()
            : this(DefaultConcurrencyLevel, DefaultCapacity, true, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see
        /// cref="ConcurrentHashSet{T}"/>
        /// class that is empty, has the specified concurrency level and capacity, and uses the default
        /// comparer for the item type.
        /// </summary>
        /// <param name="concurrencyLevel">The estimated number of threads that will update the
        /// <see cref="ConcurrentHashSet{T}"/> concurrently.</param>
        /// <param name="capacity">The initial number of elements that the <see
        /// cref="ConcurrentHashSet{T}"/>
        /// can contain.</param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is
        /// less than 1.</exception>
        /// <exception cref="ArgumentOutOfRangeException"> <paramref name="capacity"/> is less than
        /// 0.</exception>
        public ConcurrentHashSet(int concurrencyLevel, int capacity)
            : this(concurrencyLevel, capacity, false, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrentHashSet{T}"/>
        /// class that contains elements copied from the specified <see
        /// cref="IEnumerable{T}"/>, has the default concurrency
        /// level, has the default initial capacity, and uses the default comparer for the item type.
        /// </summary>
        /// <param name="collection">The <see
        /// cref="IEnumerable{T}"/> whose elements are copied to
        /// the new
        /// <see cref="ConcurrentHashSet{T}"/>.</param>
        /// <exception cref="ArgumentNullException"><paramref name="collection"/> is a null reference.</exception>
        public ConcurrentHashSet(IEnumerable<T> collection)
            : this(collection, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrentHashSet{T}"/>
        /// class that is empty, has the specified concurrency level and capacity, and uses the specified
        /// <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <param name="comparer">The <see cref="IEqualityComparer{T}"/>
        /// implementation to use when comparing items.</param>
        public ConcurrentHashSet(IEqualityComparer<T>? comparer)
            : this(DefaultConcurrencyLevel, DefaultCapacity, true, comparer)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrentHashSet{T}"/>
        /// class that contains elements copied from the specified <see
        /// cref="IEnumerable"/>, has the default concurrency level, has the default
        /// initial capacity, and uses the specified
        /// <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <param name="collection">The <see
        /// cref="IEnumerable{T}"/> whose elements are copied to
        /// the new
        /// <see cref="ConcurrentHashSet{T}"/>.</param>
        /// <param name="comparer">The <see cref="IEqualityComparer{T}"/>
        /// implementation to use when comparing items.</param>
        /// <exception cref="ArgumentNullException"><paramref name="collection"/> is a null reference
        /// (Nothing in Visual Basic).
        /// </exception>
        public ConcurrentHashSet(IEnumerable<T> collection, IEqualityComparer<T>? comparer)
            : this(comparer)
        {
            if (collection == null) throw new ArgumentNullException(nameof(collection));

            InitializeFromCollection(collection);
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrentHashSet{T}"/> 
        /// class that contains elements copied from the specified <see cref="IEnumerable"/>, 
        /// has the specified concurrency level, has the specified initial capacity, and uses the specified 
        /// <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <param name="concurrencyLevel">The estimated number of threads that will update the 
        /// <see cref="ConcurrentHashSet{T}"/> concurrently.</param>
        /// <param name="collection">The <see cref="IEnumerable{T}"/> whose elements are copied to the new 
        /// <see cref="ConcurrentHashSet{T}"/>.</param>
        /// <param name="comparer">The <see cref="IEqualityComparer{T}"/> implementation to use 
        /// when comparing items.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="concurrencyLevel"/> is less than 1.
        /// </exception>
        public ConcurrentHashSet(int concurrencyLevel, IEnumerable<T> collection, IEqualityComparer<T>? comparer)
            : this(concurrencyLevel, DefaultCapacity, false, comparer)
        {
            if (collection == null) throw new ArgumentNullException(nameof(collection));

            InitializeFromCollection(collection);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConcurrentHashSet{T}"/>
        /// class that is empty, has the specified concurrency level, has the specified initial capacity, and
        /// uses the specified <see cref="IEqualityComparer{T}"/>.
        /// </summary>
        /// <param name="concurrencyLevel">The estimated number of threads that will update the
        /// <see cref="ConcurrentHashSet{T}"/> concurrently.</param>
        /// <param name="capacity">The initial number of elements that the <see
        /// cref="ConcurrentHashSet{T}"/>
        /// can contain.</param>
        /// <param name="comparer">The <see cref="IEqualityComparer{T}"/>
        /// implementation to use when comparing items.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="concurrencyLevel"/> is less than 1. -or-
        /// <paramref name="capacity"/> is less than 0.
        /// </exception>
        public ConcurrentHashSet(int concurrencyLevel, int capacity, IEqualityComparer<T>? comparer)
            : this(concurrencyLevel, capacity, false, comparer)
        {
        }

        private ConcurrentHashSet(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer<T>? comparer)
        {
            if (concurrencyLevel < 1) throw new ArgumentOutOfRangeException(nameof(concurrencyLevel));
            if (capacity < 0) throw new ArgumentOutOfRangeException(nameof(capacity));

            // The capacity should be at least as large as the concurrency level. Otherwise, we would have locks that don't guard
            // any buckets.
            if (capacity < concurrencyLevel)
            {
                capacity = concurrencyLevel;
            }

            var locks = new object[concurrencyLevel];
            for (var i = 0; i < locks.Length; i++)
            {
                locks[i] = new object();
            }

            var countPerLock = new int[locks.Length];
            var buckets = new Node[capacity];
            _tables = new Tables(buckets, locks, countPerLock);

            _growLockArray = growLockArray;
            _budget = buckets.Length / locks.Length;
            _comparer = comparer ?? EqualityComparer<T>.Default;
        }

        /// <summary>
        /// Adds the specified item to the <see cref="ConcurrentHashSet{T}"/>.
        /// </summary>
        /// <param name="item">The item to add.</param>
        /// <returns>true if the items was added to the <see cref="ConcurrentHashSet{T}"/>
        /// successfully; false if it already exists.</returns>
        /// <exception cref="OverflowException">The <see cref="ConcurrentHashSet{T}"/>
        /// contains too many items.</exception>
        public bool Add(T item) =>
            AddInternal(item, _comparer.GetHashCode(item), true);

        /// <summary>
        /// Removes all items from the <see cref="ConcurrentHashSet{T}"/>.
        /// </summary>
        public void Clear()
        {
            var locksAcquired = 0;
            try
            {
                AcquireAllLocks(ref locksAcquired);

                if (AreAllBucketsEmpty())
                {
                    return;
                }

                var tables = _tables;
                var newTables = new Tables(new Node[DefaultCapacity], tables.Locks, new int[tables.CountPerLock.Length]);
                _tables = newTables;
                _budget = Math.Max(1, newTables.Buckets.Length / newTables.Locks.Length);
            }
            finally
            {
                ReleaseLocks(0, locksAcquired);
            }
        }

        /// <summary>
        /// Determines whether the <see cref="ConcurrentHashSet{T}"/> contains the specified
        /// item.
        /// </summary>
        /// <param name="item">The item to locate in the <see cref="ConcurrentHashSet{T}"/>.</param>
        /// <returns>true if the <see cref="ConcurrentHashSet{T}"/> contains the item; otherwise, false.</returns>
        public bool Contains(T item) => TryGetValue(item, out _);

        /// <summary>
        /// Searches the <see cref="ConcurrentHashSet{T}"/> for a given value and returns the equal value it finds, if any.
        /// </summary>
        /// <param name="equalValue">The value to search for.</param>
        /// <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
        /// <returns>A value indicating whether the search was successful.</returns>
        /// <remarks>
        /// This can be useful when you want to reuse a previously stored reference instead of
        /// a newly constructed one (so that more sharing of references can occur) or to look up
        /// a value that has more complete data than the value you currently have, although their
        /// comparer functions indicate they are equal.
        /// </remarks>
        public bool TryGetValue(T equalValue, [MaybeNullWhen(false)] out T actualValue)
        {
            var hashcode = _comparer.GetHashCode(equalValue);

            // We must capture the _buckets field in a local variable. It is set to a new table on each table resize.
            var tables = _tables;

            var bucketNo = GetBucket(hashcode, tables.Buckets.Length);

            // We can get away w/out a lock here.
            // The Volatile.Read ensures that the load of the fields of 'n' doesn't move before the load from buckets[i].
            var current = Volatile.Read(ref tables.Buckets[bucketNo]);

            while (current != null)
            {
                if (hashcode == current.Hashcode && _comparer.Equals(current.Item, equalValue))
                {
                    actualValue = current.Item;
                    return true;
                }

                current = current.Next;
            }

            actualValue = default;
            return false;
        }

        /// <summary>
        /// Attempts to remove the item from the <see cref="ConcurrentHashSet{T}"/>.
        /// </summary>
        /// <param name="item">The item to remove.</param>
        /// <returns>true if an item was removed successfully; otherwise, false.</returns>
        public bool TryRemove(T item)
        {
            var hashcode = _comparer.GetHashCode(item);
            while (true)
            {
                var tables = _tables;

                GetBucketAndLockNo(hashcode, out int bucketNo, out int lockNo, tables.Buckets.Length, tables.Locks.Length);

                lock (tables.Locks[lockNo])
                {
                    // If the table just got resized, we may not be holding the right lock, and must retry.
                    // This should be a rare occurrence.
                    if (tables != _tables)
                    {
                        continue;
                    }

                    Node? previous = null;
                    for (var current = tables.Buckets[bucketNo]; current != null; current = current.Next)
                    {
                        Debug.Assert((previous == null && current == tables.Buckets[bucketNo]) || previous!.Next == current);

                        if (hashcode == current.Hashcode && _comparer.Equals(current.Item, item))
                        {
                            if (previous == null)
                            {
                                Volatile.Write(ref tables.Buckets[bucketNo], current.Next);
                            }
                            else
                            {
                                previous.Next = current.Next;
                            }

                            tables.CountPerLock[lockNo]--;
                            return true;
                        }
                        previous = current;
                    }
                }

                return false;
            }
        }

        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<T>)this).GetEnumerator();

        /// <summary>Returns an enumerator that iterates through the <see
        /// cref="ConcurrentHashSet{T}"/>.</summary>
        /// <returns>An enumerator for the <see cref="ConcurrentHashSet{T}"/>.</returns>
        /// <remarks>
        /// The enumerator returned from the collection is safe to use concurrently with
        /// reads and writes to the collection, however it does not represent a moment-in-time snapshot
        /// of the collection.  The contents exposed through the enumerator may contain modifications
        /// made to the collection after <see cref="IEnumerable{T}.GetEnumerator"/> was called.
        /// </remarks>
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);

        /// <summary>Returns a value-type enumerator that iterates through the <see
        /// cref="ConcurrentHashSet{T}"/>.</summary>
        /// <returns>An enumerator for the <see cref="ConcurrentHashSet{T}"/>.</returns>
        /// <remarks>
        /// The enumerator returned from the collection is safe to use concurrently with
        /// reads and writes to the collection, however it does not represent a moment-in-time snapshot
        /// of the collection.  The contents exposed through the enumerator may contain modifications
        /// made to the collection after <see cref="GetEnumerator"/> was called.
        /// </remarks>
        public Enumerator GetEnumerator() => new Enumerator(this);

        /// <summary>
        /// Represents an enumerator for <see cref="ConcurrentHashSet{T}" />.
        /// </summary>
        public struct Enumerator : IEnumerator<T>
        {
            // Provides a manually-implemented version of (approximately) this iterator:
            //     Node?[] buckets = _tables.Buckets;
            //     for (int i = 0; i < buckets.Length; i++)
            //         for (Node? current = Volatile.Read(ref buckets[i]); current != null; current = current.Next)
            //             yield return new current.Item;

            private readonly ConcurrentHashSet<T> _set;

            private Node?[]? _buckets;
            private Node? _node;
            private int _i;
            private int _state;

            private const int StateUninitialized = 0;
            private const int StateOuterloop = 1;
            private const int StateInnerLoop = 2;
            private const int StateDone = 3;

            /// <summary>
            /// Constructs an enumerator for <see cref="ConcurrentHashSet{T}" />.
            /// </summary>
            public Enumerator(ConcurrentHashSet<T> set)
            {
                _set = set;
                _buckets = null;
                _node = null;
                Current = default!;
                _i = -1;
                _state = StateUninitialized;
            }

            /// <summary>
            /// Gets the element in the collection at the current position of the enumerator.
            /// </summary>
            /// <value>The element in the collection at the current position of the enumerator.</value>
            public T Current { get; private set; }

            object? IEnumerator.Current => Current;

            /// <summary>
            /// Sets the enumerator to its initial position, which is before the first element in the collection.
            /// </summary>
            public void Reset()
            {
                _buckets = null;
                _node = null;
                Current = default!;
                _i = -1;
                _state = StateUninitialized;
            }

            /// <summary>
            /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            /// <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.</returns>
            public bool MoveNext()
            {
                switch (_state)
                {
                    case StateUninitialized:
                        _buckets = _set._tables.Buckets;
                        _i = -1;
                        goto case StateOuterloop;

                    case StateOuterloop:
                        Node?[]? buckets = _buckets;
                        Debug.Assert(buckets != null);

                        int i = ++_i;
                        if ((uint)i < (uint)buckets!.Length)
                        {
                            // The Volatile.Read ensures that we have a copy of the reference to buckets[i]:
                            // this protects us from reading fields ('_key', '_value' and '_next') of different instances.
                            _node = Volatile.Read(ref buckets[i]);
                            _state = StateInnerLoop;
                            goto case StateInnerLoop;
                        }
                        goto default;

                    case StateInnerLoop:
                        Node? node = _node;
                        if (node != null)
                        {
                            Current = node.Item;
                            _node = node.Next;
                            return true;
                        }
                        goto case StateOuterloop;

                    default:
                        _state = StateDone;
                        return false;
                }
            }
        }

        void ICollection<T>.Add(T item) => Add(item);

        bool ICollection<T>.IsReadOnly => false;

        void ICollection<T>.CopyTo(T[] array, int arrayIndex)
        {
            if (array == null) throw new ArgumentNullException(nameof(array));
            if (arrayIndex < 0) throw new ArgumentOutOfRangeException(nameof(arrayIndex));

            var locksAcquired = 0;
            try
            {
                AcquireAllLocks(ref locksAcquired);

                var count = 0;

                var countPerLock = _tables.CountPerLock;
                for (var i = 0; i < countPerLock.Length && count >= 0; i++)
                {
                    count += countPerLock[i];
                }

                if (array.Length - count < arrayIndex || count < 0) //"count" itself or "count + arrayIndex" can overflow
                {
                    throw new ArgumentException("The index is equal to or greater than the length of the array, or the number of elements in the set is greater than the available space from index to the end of the destination array.");
                }

                CopyToItems(array, arrayIndex);
            }
            finally
            {
                ReleaseLocks(0, locksAcquired);
            }
        }

        bool ICollection<T>.Remove(T item) => TryRemove(item);

        private void InitializeFromCollection(IEnumerable<T> collection)
        {
            foreach (var item in collection)
            {
                AddInternal(item, _comparer.GetHashCode(item), false);
            }

            if (_budget == 0)
            {
                var tables = _tables;
                _budget = tables.Buckets.Length / tables.Locks.Length;
            }
        }

        private bool AddInternal(T item, int hashcode, bool acquireLock)
        {
            while (true)
            {
                var tables = _tables;

                GetBucketAndLockNo(hashcode, out int bucketNo, out int lockNo, tables.Buckets.Length, tables.Locks.Length);

                var resizeDesired = false;
                var lockTaken = false;
                try
                {
                    if (acquireLock)
                        Monitor.Enter(tables.Locks[lockNo], ref lockTaken);

                    // If the table just got resized, we may not be holding the right lock, and must retry.
                    // This should be a rare occurrence.
                    if (tables != _tables)
                    {
                        continue;
                    }

                    // Try to find this item in the bucket
                    Node? previous = null;
                    for (var current = tables.Buckets[bucketNo]; current != null; current = current.Next)
                    {
                        Debug.Assert(previous == null && current == tables.Buckets[bucketNo] || previous!.Next == current);
                        if (hashcode == current.Hashcode && _comparer.Equals(current.Item, item))
                        {
                            return false;
                        }
                        previous = current;
                    }

                    // The item was not found in the bucket. Insert the new item.
                    Volatile.Write(ref tables.Buckets[bucketNo], new Node(item, hashcode, tables.Buckets[bucketNo]));
                    checked
                    {
                        tables.CountPerLock[lockNo]++;
                    }

                    //
                    // If the number of elements guarded by this lock has exceeded the budget, resize the bucket table.
                    // It is also possible that GrowTable will increase the budget but won't resize the bucket table.
                    // That happens if the bucket table is found to be poorly utilized due to a bad hash function.
                    //
                    if (tables.CountPerLock[lockNo] > _budget)
                    {
                        resizeDesired = true;
                    }
                }
                finally
                {
                    if (lockTaken)
                        Monitor.Exit(tables.Locks[lockNo]);
                }

                //
                // The fact that we got here means that we just performed an insertion. If necessary, we will grow the table.
                //
                // Concurrency notes:
                // - Notice that we are not holding any locks at when calling GrowTable. This is necessary to prevent deadlocks.
                // - As a result, it is possible that GrowTable will be called unnecessarily. But, GrowTable will obtain lock 0
                //   and then verify that the table we passed to it as the argument is still the current table.
                //
                if (resizeDesired)
                {
                    GrowTable(tables);
                }

                return true;
            }
        }

        private static int GetBucket(int hashcode, int bucketCount)
        {
            var bucketNo = (hashcode & 0x7fffffff) % bucketCount;
            Debug.Assert(bucketNo >= 0 && bucketNo < bucketCount);
            return bucketNo;
        }

        private static void GetBucketAndLockNo(int hashcode, out int bucketNo, out int lockNo, int bucketCount, int lockCount)
        {
            bucketNo = (hashcode & 0x7fffffff) % bucketCount;
            lockNo = bucketNo % lockCount;

            Debug.Assert(bucketNo >= 0 && bucketNo < bucketCount);
            Debug.Assert(lockNo >= 0 && lockNo < lockCount);
        }

        private bool AreAllBucketsEmpty()
        {
            var countPerLock = _tables.CountPerLock;
            for (var i = 0; i < countPerLock.Length; i++)
            {
                if (countPerLock[i] != 0)
                {
                    return false;
                }
            }

            return true;
        }

        private void GrowTable(Tables tables)
        {
            const int maxArrayLength = 0X7FEFFFFF;
            var locksAcquired = 0;
            try
            {
                // The thread that first obtains _locks[0] will be the one doing the resize operation
                AcquireLocks(0, 1, ref locksAcquired);

                // Make sure nobody resized the table while we were waiting for lock 0:
                if (tables != _tables)
                {
                    // We assume that since the table reference is different, it was already resized (or the budget
                    // was adjusted). If we ever decide to do table shrinking, or replace the table for other reasons,
                    // we will have to revisit this logic.
                    return;
                }

                // Compute the (approx.) total size. Use an Int64 accumulation variable to avoid an overflow.
                long approxCount = 0;
                for (var i = 0; i < tables.CountPerLock.Length; i++)
                {
                    approxCount += tables.CountPerLock[i];
                }

                //
                // If the bucket array is too empty, double the budget instead of resizing the table
                //
                if (approxCount < tables.Buckets.Length / 4)
                {
                    _budget = 2 * _budget;
                    if (_budget < 0)
                    {
                        _budget = int.MaxValue;
                    }
                    return;
                }

                // Compute the new table size. We find the smallest integer larger than twice the previous table size, and not divisible by
                // 2,3,5 or 7. We can consider a different table-sizing policy in the future.
                var newLength = 0;
                var maximizeTableSize = false;
                try
                {
                    checked
                    {
                        // Double the size of the buckets table and add one, so that we have an odd integer.
                        newLength = tables.Buckets.Length * 2 + 1;

                        // Now, we only need to check odd integers, and find the first that is not divisible
                        // by 3, 5 or 7.
                        while (newLength % 3 == 0 || newLength % 5 == 0 || newLength % 7 == 0)
                        {
                            newLength += 2;
                        }

                        Debug.Assert(newLength % 2 != 0);

                        if (newLength > maxArrayLength)
                        {
                            maximizeTableSize = true;
                        }
                    }
                }
                catch (OverflowException)
                {
                    maximizeTableSize = true;
                }

                if (maximizeTableSize)
                {
                    newLength = maxArrayLength;

                    // We want to make sure that GrowTable will not be called again, since table is at the maximum size.
                    // To achieve that, we set the budget to int.MaxValue.
                    //
                    // (There is one special case that would allow GrowTable() to be called in the future: 
                    // calling Clear() on the ConcurrentHashSet will shrink the table and lower the budget.)
                    _budget = int.MaxValue;
                }

                // Now acquire all other locks for the table
                AcquireLocks(1, tables.Locks.Length, ref locksAcquired);

                var newLocks = tables.Locks;

                // Add more locks
                if (_growLockArray && tables.Locks.Length < MaxLockNumber)
                {
                    newLocks = new object[tables.Locks.Length * 2];
                    Array.Copy(tables.Locks, newLocks, tables.Locks.Length);
                    for (var i = tables.Locks.Length; i < newLocks.Length; i++)
                    {
                        newLocks[i] = new object();
                    }
                }

                var newBuckets = new Node[newLength];
                var newCountPerLock = new int[newLocks.Length];

                // Copy all data into a new table, creating new nodes for all elements
                for (var i = 0; i < tables.Buckets.Length; i++)
                {
                    var current = tables.Buckets[i];
                    while (current != null)
                    {
                        var next = current.Next;
                        GetBucketAndLockNo(current.Hashcode, out int newBucketNo, out int newLockNo, newBuckets.Length, newLocks.Length);

                        newBuckets[newBucketNo] = new Node(current.Item, current.Hashcode, newBuckets[newBucketNo]);

                        checked
                        {
                            newCountPerLock[newLockNo]++;
                        }

                        current = next;
                    }
                }

                // Adjust the budget
                _budget = Math.Max(1, newBuckets.Length / newLocks.Length);

                // Replace tables with the new versions
                _tables = new Tables(newBuckets, newLocks, newCountPerLock);
            }
            finally
            {
                // Release all locks that we took earlier
                ReleaseLocks(0, locksAcquired);
            }
        }

        private void AcquireAllLocks(ref int locksAcquired)
        {
            // First, acquire lock 0
            AcquireLocks(0, 1, ref locksAcquired);

            // Now that we have lock 0, the _locks array will not change (i.e., grow),
            // and so we can safely read _locks.Length.
            AcquireLocks(1, _tables.Locks.Length, ref locksAcquired);
            Debug.Assert(locksAcquired == _tables.Locks.Length);
        }

        private void AcquireLocks(int fromInclusive, int toExclusive, ref int locksAcquired)
        {
            Debug.Assert(fromInclusive <= toExclusive);
            var locks = _tables.Locks;

            for (var i = fromInclusive; i < toExclusive; i++)
            {
                var lockTaken = false;
                try
                {
                    Monitor.Enter(locks[i], ref lockTaken);
                }
                finally
                {
                    if (lockTaken)
                    {
                        locksAcquired++;
                    }
                }
            }
        }

        private void ReleaseLocks(int fromInclusive, int toExclusive)
        {
            Debug.Assert(fromInclusive <= toExclusive);

            for (var i = fromInclusive; i < toExclusive; i++)
            {
                Monitor.Exit(_tables.Locks[i]);
            }
        }

        private void CopyToItems(T[] array, int index)
        {
            var buckets = _tables.Buckets;
            for (var i = 0; i < buckets.Length; i++)
            {
                for (var current = buckets[i]; current != null; current = current.Next)
                {
                    array[index] = current.Item;
                    index++; //this should never flow, CopyToItems is only called when there's no overflow risk
                }
            }
        }

        private class Tables(Node?[] buckets, object[] locks, int[] countPerLock)
        {
            public readonly Node?[] Buckets = buckets;
            public readonly object[] Locks = locks;

            public readonly int[] CountPerLock = countPerLock;
        }

        private class Node(T item, int hashcode, Node? next)
        {
            public readonly T Item = item;
            public readonly int Hashcode = hashcode;

            public volatile Node? Next = next;
        }
    }
}



// --- File: MicroPlumberd\Serialization\Metadata.cs ---


using System.Text.Json;

namespace MicroPlumberd;

/// <summary>
/// Metadata structure.
/// </summary>
public readonly struct Metadata
{
    private readonly Guid _id;
    private readonly Guid _eventId;
    private readonly JsonElement _data;

    /// <summary>
    /// Metadata structure.
    /// </summary>
    public Metadata(Guid id,Guid eventId, long sourceStreamPosition, long? linkStreamPosition, string sourceStreamId, JsonElement data)
    {
        _id = id;
        _eventId = eventId;
        _data = data;
        SourceStreamPosition = sourceStreamPosition;
        SourceStreamId = sourceStreamId;
        LinkStreamPosition = linkStreamPosition;
    }

    /// <summary>
    /// Gets the identifier or the stream. This is the second segment of the streamId (category-id).
    /// </summary>
    /// <value>
    /// The identifier.
    /// </value>
    public Guid Id => _id;
    /// <summary>
    /// Data from metadata is deserialized in JsonElement.
    /// </summary>
    /// <value>
    /// The data.
    /// </value>
    public JsonElement Data => _data;
    /// <summary>
    /// Gets the source stream position.
    /// </summary>
    /// <value>
    /// The source stream position.
    /// </value>
    public long SourceStreamPosition { get; }
    public long? LinkStreamPosition { get; }
    /// <summary>
    /// Gets the full source stream-id
    /// </summary>
    /// <value>
    /// The source stream identifier.
    /// </value>
    public string SourceStreamId { get; }
    /// <summary>
    /// Gets the event identifier.
    /// </summary>
    /// <value>
    /// The event identifier.
    /// </value>
    public Guid EventId => _eventId;


    /// <summary>
    /// Extracts and parses the stream identifier.
    /// </summary>
    /// <typeparam name="T">The type to which the stream identifier will be parsed. Must implement <see cref="IParsable{T}"/>.</typeparam>
    /// <returns>The parsed stream identifier as an instance of type <typeparamref name="T"/>.</returns>
    /// <exception cref="ArgumentNullException">Thrown if the parsed identifier is null or invalid for type <typeparamref name="T"/>.</exception>
    /// <exception cref="FormatException">Thrown if the format of the identifier is invalid for type <typeparamref name="T"/>.</exception>
    /// <exception cref="ArgumentOutOfRangeException">Thrown if the <see cref="SourceStreamId"/> does not contain a valid separator ('-').</exception>
    public T StreamId<T>() where T : IParsable<T>
    {
        if (Data.TryGetProperty("SourceStreamId", out var j) && j.ValueKind == JsonValueKind.String)
            return StreamIdFromStr<T>(j.GetString()!);

        return StreamIdFromStr<T>(SourceStreamId);
    }

    private static T StreamIdFromStr<T>(string str) where T : IParsable<T>
    {
        int index = str.IndexOf('-');
        string id = str.Substring(index + 1);
        return T.Parse(id, null);
    }
}



// --- File: MicroPlumberd\Serialization\ObjectSerializer.cs ---


using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Dynamic;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MicroPlumberd;

class OptionJsonConverter<T> : JsonConverter<Option<T>>
{
    public override Option<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.Null)
            return new Option<T> { IsDefined = true };

        return JsonSerializer.Deserialize<T>(ref reader, options);
    }

    public override void Write(Utf8JsonWriter writer, Option<T> value, JsonSerializerOptions options)
    {
        if (!value.IsDefined)
        {
            writer.WriteNullValue();
        }
        else
        {
            JsonSerializer.Serialize(writer, value.Value, options);
        }
    }
}
/// <summary>
/// Json Option factory used to support Option<T> struct deserialization/serialization.
/// </summary>
/// <seealso cref="System.Text.Json.Serialization.JsonConverterFactory" />
public class OptionConverterFactory : JsonConverterFactory
{
    public override bool CanConvert(Type typeToConvert)
    {
        if (!typeToConvert.IsGenericType) return false;

        return typeToConvert.GetGenericTypeDefinition() == typeof(Option<>);
    }

    public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
    {
        Type valueType = typeToConvert.GetGenericArguments()[0];

        var specificType = typeof(OptionJsonConverter<>).MakeGenericType(valueType);
        JsonConverter converter = (JsonConverter)Activator.CreateInstance(specificType)!;

        return converter;
    }
}

class OptionTypeConverter<T> : TypeConverter
{
    public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
    {
        if (sourceType == typeof(T))
        {
            return true;
        }

        return base.CanConvertFrom(context, sourceType);
    }

    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
    {
        if (value is T s)
            return new Option<T> { Value = s, IsDefined = true };

        return base.ConvertFrom(context, culture, value);
    }
}


/// <summary>
/// For command/event properties usefull to get rid of property-sourcing.
/// </summary>
/// <typeparam name="T"></typeparam>
public readonly record struct Option<T> 
{
    public static Option<T> Empty { get; } = new Option<T>();
    public T Value { get; init; }
    public static implicit operator T(Option<T> v)
    {
        if (!v.IsDefined) throw new InvalidOperationException("Option was not defined.");

        return v.Value;
    }
    public static implicit operator Option<T>(T value) => new Option<T>() { Value = value, IsDefined = true };

    public bool IsDefined { get; init; }

}

public sealed class JsonObjectSerializer : IObjectSerializer
{
    public static readonly JsonSerializerOptions Options = new() { Converters = { new ExpandoObjectConverter(), new OptionConverterFactory() } };
    private static JsonElement Empty = JsonSerializer.Deserialize<JsonElement>("{}");
    public object? Deserialize(ReadOnlySpan<byte> span, Type t)
    {
        return JsonSerializer.Deserialize(span, t, Options);
    }

    public JsonElement ParseMetadata(ReadOnlySpan<byte> span)
    {
        if(span.Length == 0) return Empty;
        return JsonSerializer.Deserialize<JsonElement>(span, Options);
    }

    public byte[] Serialize(object? t)
    {
        return t == null ? Array.Empty<byte>() : JsonSerializer.SerializeToUtf8Bytes(t, t.GetType(), Options);
    }

    public string ContentType => "application/json";
}
class ExpandoObjectConverter : JsonConverter<ExpandoObject>
{
    public override ExpandoObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return ReadValue(ref reader, options);
    }

    private ExpandoObject ReadValue(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
        {
            throw new JsonException();
        }

        var expando = new ExpandoObject();
        IDictionary<string, object> dictionary = expando!;

        while (reader.Read())
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.EndObject:
                    return expando;
                case JsonTokenType.PropertyName:
                    var propertyName = reader.GetString();
                    reader.Read();
                    dictionary[propertyName!] = ReadObject(ref reader, options)!;
                    break;
                default:
                    throw new JsonException();
            }
        }

        throw new JsonException("Expected EndObject token not found.");
    }

    private object? ReadObject(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.StartObject:
                return ReadValue(ref reader, options);
            case JsonTokenType.StartArray:
                return ReadArray(ref reader, options);
            case JsonTokenType.String:
                return reader.GetString();
            case JsonTokenType.Number:
                if (reader.TryGetInt32(out int intValue))
                {
                    return intValue;
                }
                else if (reader.TryGetDouble(out double doubleValue))
                {
                    return doubleValue;
                }
                break; // Could also handle other numeric types
            case JsonTokenType.True:
            case JsonTokenType.False:
                return reader.GetBoolean();
            case JsonTokenType.Null:
                return null;
            default:
                throw new JsonException($"Unexpected token: {reader.TokenType}");
        }

        return null;
    }

    private object ReadArray(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        var list = new List<object>();

        while (reader.Read())
        {
            if (reader.TokenType == JsonTokenType.EndArray)
            {
                return list;
            }

            list.Add(ReadObject(ref reader, options)!);
        }

        throw new JsonException("Expected EndArray token not found.");
    }

    public override void Write(Utf8JsonWriter writer, ExpandoObject value, JsonSerializerOptions options)
    {
        writer.WriteStartObject(); // Start writing the object

        foreach (var kvp in value)
        {
            writer.WritePropertyName(kvp.Key);
            WriteValue(writer, kvp.Value!, options);
        }

        writer.WriteEndObject(); // End writing the object
    }

    private void WriteValue(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case null:
                writer.WriteNullValue();
                break;
            case ExpandoObject expando:
                Write(writer, expando, options); // Recursive call for nested objects
                break;
            case IList list:
                WriteArray(writer, list, options);
                break;
            case string str:
                writer.WriteStringValue(str);
                break;
            case bool boolVal:
                writer.WriteBooleanValue(boolVal);
                break;
            case int intVal:
                writer.WriteNumberValue(intVal);
                break;
            case long longVal:
                writer.WriteNumberValue(longVal);
                break;
            case float floatVal:
                writer.WriteNumberValue(floatVal);
                break;
            case double doubleVal:
                writer.WriteNumberValue(doubleVal);
                break;
            case DateTime dateTime:
                writer.WriteStringValue(dateTime);
                break;
            // Add other types as necessary
            default:
                JsonSerializer.Serialize(writer, value, value.GetType(), options);
                break;
        }
    }

    private void WriteArray(Utf8JsonWriter writer, IList list, JsonSerializerOptions options)
    {
        writer.WriteStartArray();

        foreach (var item in list)
        {
            WriteValue(writer, item, options);
        }

        writer.WriteEndArray();
    }
}


// --- File: MicroPlumberd\Utils\AsyncDisposableCollection.cs ---


using System.Collections.Concurrent;
using System.ComponentModel;
using System.Linq.Expressions;
using System.Reflection;
using Guid = System.Guid;

namespace MicroPlumberd.Utils;

public class AsyncDisposableCollection : IAsyncDisposable
{
    private readonly List<IAsyncDisposable> _items = new();
    public static AsyncDisposableCollection New() => new AsyncDisposableCollection();
    public static AsyncDisposableCollection operator +(AsyncDisposableCollection left, IAsyncDisposable right)
    {
        left._items.Add(right);
        return left;
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var i in _items)
            await i.DisposeAsync();
    }

}

class VersionDuckTyping
{
    private readonly ConcurrentDictionary<Type, Action<object, long>> _setters = new();
    private readonly ConcurrentDictionary<Type, Func<object, long>> _getters = new();

    public long GetVersion(object instance)
    {
        return _getters.GetOrAdd(instance.GetType(), x =>
        {
            var prop = x.GetProperty("Version");
            if (prop != null) return DelegateHelper.CreateLongGetter(prop);
            return null;
        })?.Invoke(instance) ?? -1;
    }


    public void SetVersion(object instance, long value)
    {
        _setters.GetOrAdd(instance.GetType(), x =>
        {
            var prop = x.GetProperty("Version");
            if (prop != null) return DelegateHelper.CreateLongSetter(prop);
            return null;
        })?.Invoke(instance, value);
    }
}
public class IdDuckTyping
{
    private readonly ConcurrentDictionary<Type, Action<object, object>> _setters = new();
    private readonly ConcurrentDictionary<Type, Func<object, object>> _getters = new();
    public static readonly IdDuckTyping Instance = new IdDuckTyping();
    public bool TryGetGuidId(object instance, out Guid id)
    {
        var tmp = GetId(instance);
        if (tmp == null)
        {
            id = Guid.Empty;
            return false;
        }
        id = (tmp is Guid guid ? guid : Guid.Parse(tmp.ToString()));
        return true;
    }
    public object? GetId(object instance)
    {
        return _getters.GetOrAdd(instance.GetType(), x =>
        {
            var prop = x.GetProperty("Id");
            if (prop != null) return DelegateHelper.CreateGetter(prop);
            return null;
        })?.Invoke(instance);
    }
    
    
    public void SetId(object instance, object value)
    {
        _setters.GetOrAdd(instance.GetType(), x =>
        {
            var prop = x.GetProperty("Id");
            if (prop != null) return DelegateHelper.CreateSetter(prop);
            return null;
        })?.Invoke(instance, value);
    }
}
internal static class DelegateHelper
{
    public static Action<object, long> CreateLongSetter(PropertyInfo propertyInfo)
    {
        // Create a parameter expression for the instance (object)
        var instanceParam = Expression.Parameter(typeof(object), "instance");

        // Create a parameter expression for the value (long)
        var valueParam = Expression.Parameter(typeof(long), "value");

        // Create a property expression
        var propertyExpr = Expression.Property(Expression.Convert(instanceParam, propertyInfo.DeclaringType), propertyInfo);

        // Create an assignment expression
        var assignExpr = Expression.Assign(propertyExpr, valueParam);

        // Compile the lambda expression to create the setter delegate
        return Expression.Lambda<Action<object, long>>(assignExpr, instanceParam, valueParam).Compile();
    }
    public static Func<object, long> CreateLongGetter(PropertyInfo propertyInfo)
    {
        // Create a parameter expression for the instance (object)
        var instanceParam = Expression.Parameter(typeof(object), "instance");

        // Create a property expression
        var propertyExpr = Expression.Property(Expression.Convert(instanceParam, propertyInfo.DeclaringType), propertyInfo);

        // Compile the lambda expression to create the getter delegate
        return Expression.Lambda<Func<object, long>>(propertyExpr, instanceParam).Compile();
    }
    public static Action<object, object> CreateSetter(PropertyInfo propertyInfo)
    {
        // Create a parameter expression for the instance (object)
        var instanceParam = Expression.Parameter(typeof(object), "instance");

        // Create a parameter expression for the value (object)
        var valueParam = Expression.Parameter(typeof(object), "value");

        // Create a property expression
        var propertyExpr = Expression.Property(Expression.Convert(instanceParam, propertyInfo.DeclaringType), propertyInfo);

        // Create an assignment expression
        var assignExpr = Expression.Assign(propertyExpr, Expression.Convert(valueParam, propertyInfo.PropertyType));

        // Compile the lambda expression to create the setter delegate
        return Expression.Lambda<Action<object, object>>(assignExpr, instanceParam, valueParam).Compile();
    }

    public static Func<object, object> CreateGetter(PropertyInfo propertyInfo)
    {
        // Create a parameter expression for the instance (object)
        var instanceParam = Expression.Parameter(typeof(object), "instance");

        // Create a property expression
        var propertyExpr = Expression.Property(Expression.Convert(instanceParam, propertyInfo.DeclaringType), propertyInfo);

        // Compile the lambda expression to create the getter delegate
        return Expression.Lambda<Func<object, object>>(Expression.Convert(propertyExpr, typeof(object)), instanceParam).Compile();
    }
}


// --- File: MicroPlumberd\ActivatorServiceProvider.cs ---


using Microsoft.Extensions.Logging;

namespace MicroPlumberd;

class ActivatorServiceProvider : IServiceProvider
{
    public object? GetService(Type serviceType)
    {
        if (serviceType == typeof(IServiceProvider))
            return this;

        if (serviceType.IsGenericType && serviceType.GetGenericTypeDefinition() == typeof(ILogger<>))
            return null;
        
        return Activator.CreateInstance(serviceType);
    }
}


// --- File: MicroPlumberd\AggregateBase.cs ---


using EventStore.Client;
using System.Linq;

namespace MicroPlumberd;

/// <summary>
/// Represents a stateful object.
/// </summary>
public interface IStatefull
{
    /// <summary>
    /// Gets the state of the object.
    /// </summary>
    object State { get; }
    
    /// <summary>
    /// Initializes the aggregate with the specified state and version information.
    /// </summary>
    /// <param name="state">The state object.</param>
    /// <param name="version">The version information.</param>
    void Initialize(object state, StateInfo version);
    
    /// <summary>
    /// Gets the type of the snapshot.
    /// </summary>
    Type SnapshotType { get;  }
    

    /// <summary>
    /// Gets the state information with which the aggregate was initialized.
    /// </summary>
    StateInfo? InitializedWith { get; }
}

/// <summary>
/// Represents the state information of an aggregate.
/// </summary>
public readonly struct StateInfo(long version, DateTimeOffset created)
{
    /// <summary>
    /// Gets or sets the version of the state.
    /// </summary>
    public long Version { get; init; } = version;

    /// <summary>
    /// Gets or sets the creation date and time of the state.
    /// </summary>
    public DateTimeOffset Created { get; init; } = created;
}

/// <summary>
/// Represents a stateful object that exposes a read-only state.
/// </summary>
/// <typeparam name="T">The type of the state.</typeparam>
public interface IStatefull<out T>
{
    /// <summary>
    /// Gets the current state of the object.
    /// </summary>
    T State { get; }
}

/// <summary>
/// Represents the base class for aggregate roots in the application.
/// </summary>
/// <typeparam name="TState">The type of the aggregate state.</typeparam>
/// <typeparam name="TId"></typeparam>
public abstract class AggregateBase<TId, TState>(TId id) : IVersioned, IId<TId>, IStatefull<TState>, IStatefull
    where TState : new() 
    where TId : IParsable<TId>

{
    private StateInfo? _initialized;
    object IStatefull.State => State;
    StateInfo? IStatefull.InitializedWith => _initialized;
    Type IStatefull.SnapshotType => typeof(TState);
    void IStatefull.Initialize(object state, StateInfo info)
    {
        State = (TState)state;
        Version = info.Version;
        _initialized = info;
    }
    private readonly List<object> _pendingEvents = new();
    
    /// <summary>
    /// Gets the state of the aggregate.
    /// </summary>
    protected TState State { get; private set; } = new();
    TState IStatefull<TState>.State => State;

    /// <summary>
    /// Gets the unique identifier of the aggregate.
    /// </summary>
    public TId Id { get; } = id;

    /// <summary>
    /// Gets the version of the aggregate.
    /// </summary>
    public long Version { get; private set; } = -1;

    /// <summary>
    /// Gets or sets the list of pending events for the aggregate.
    /// </summary>
    public IReadOnlyList<object> PendingEvents => _pendingEvents;
    public bool HasPendingChanges => _pendingEvents.Count > 0;


    /// <summary>
    /// Appends a pending change to the list of pending events and applies the change.
    /// </summary>
    /// <param name="ev">The pending change to append.</param>
    protected void AppendPendingChange(object ev)
    {
        _pendingEvents.Add(ev);
        Apply(ev);
    }

    /// <summary>
    /// Rehydrates the aggregate by applying a sequence of events.
    /// </summary>
    /// <param name="events">The sequence of events to apply.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    public async Task Rehydrate(IAsyncEnumerable<object> events)
    {
        await foreach (var e in events)
        {
            State = Apply(e);
            Version += 1;
        }
    }
    /// <summary>
    /// Acknowledges the committed events and clears the pending events.
    /// </summary>
    public void AckCommitted()
    {
        Version += _pendingEvents.Count;
        _pendingEvents.Clear();
    }
    /// <summary>
    /// Dispatches event to create a new state.
    /// </summary>
    /// <typeparam name="TState">The type of the aggregate state.</typeparam>
    protected abstract TState Given(TState state, object ev);

    private TState Apply(object ev)
    {
        return Given(State, ev);
    }
}


// --- File: MicroPlumberd\AsyncLazy.cs ---


using System.Runtime.CompilerServices;

namespace MicroPlumberd;

/// <summary>
/// Provides support for lazy initialization of a value in an async context
/// Uses TaskCompletionSource for efficient synchronization
/// </summary>
public class AsyncLazy<T>
{
    private readonly Func<Task<T>> _valueFactory;
    private T _value;
    private volatile bool _initialized;
    private readonly TaskCompletionSource<T> _tcs;

    /// <summary>
    /// Initializes a new instance of AsyncLazy with the specified value factory
    /// </summary>
    public AsyncLazy(Func<Task<T>> valueFactory)
    {
        _valueFactory = valueFactory ?? throw new ArgumentNullException(nameof(valueFactory));
        _tcs = new TaskCompletionSource<T>(TaskCreationOptions.RunContinuationsAsynchronously);
    }

    /// <summary>
    /// Gets whether the value has been created
    /// </summary>
    public bool IsValueCreated => _initialized;

    /// <summary>
    /// Gets the lazily initialized value.
    /// Returns immediately if already initialized.
    /// </summary>
    public ValueTask<T> Value
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            // Fast path - return immediately if initialized
            if (_initialized)
            {
                return new ValueTask<T>(_value);
            }

            return new ValueTask<T>(GetValueAsync());
        }
    }

    private async Task<T> GetValueAsync()
    {
        var currentAttempt = Interlocked.Increment(ref _initiatingThreads);

        // First thread handles initialization
        if (currentAttempt != 1) return await _tcs.Task;

        try
        {
            _value = await _valueFactory();
            _initialized = true;
            _tcs.SetResult(_value);
            return _value;
        }
        catch (Exception ex)
        {
            _tcs.SetException(ex);
            throw;
        }

    }

    private int _initiatingThreads = 0;
}


// --- File: MicroPlumberd\Conventions.cs ---


using System.Collections.Concurrent;
using System.Dynamic;
using System.Reflection;
using System.Reflection.Metadata.Ecma335;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using EventStore.Client;
using Grpc.Core;
using MicroPlumberd.Utils;
using static System.Formats.Asn1.AsnWriter;

namespace MicroPlumberd;

readonly struct SingleTypeConverter(Type snapshot)
{
    public bool Convert(string evName, out Type t)
    {
        t = snapshot;
        return true;
    }
}


/// <summary>
/// Represents a delegate that defines a convention for determining the stream category based on the aggregate type.
/// </summary>
/// <param name="aggregateType">The type of the aggregate.</param>
/// <returns>A string representing the stream category.</returns>
public delegate string StreamCategoryConvention(Type aggregateType);
/// <summary>
/// Represents a delegate that defines the convention for generating a steam name based on the aggregate type and aggregate ID.
/// </summary>
/// <param name="aggregateType">The type of the aggregate.</param>
/// <param name="aggregateId">The ID of the aggregate.</param>
/// <returns>A string representing the steam name.</returns>
public delegate string SteamNameConvention(Type aggregateType, object aggregateId);

/// <summary>
/// Represents a delegate that defines a convention for determining the stream category named based on event-type.
/// </summary>
/// <param name="eventType">Type of the event.</param>
/// <returns></returns>
public delegate string StreamNameFromEventConvention(Type eventType, object? id);

/// <summary>
/// Represents a delegate that defines the convention for determining the projection category stream for a given model type.
/// </summary>
/// <param name="type">The type of the model.</param>
/// <returns>The projection category stream.</returns>
public delegate string ProjectionCategoryStreamConvention(Type type);

/// <summary>
/// Represents a delegate that defines the convention for generating event names.
/// </summary>
/// <param name="ownerType">The type of the owner of the event.</param>
/// <param name="evtType">The type of the event.</param>
/// <returns>A string representing the generated event name.</returns>
public delegate string EventNameConvention(Type? ownerType, Type evtType);

/// <summary>
/// Represents a delegate that returns the name of a snapshot event for a given state type.
/// </summary>
/// <param name="stateType">The type of the state.</param>
/// <returns>The name of the snapshot event.</returns>
public delegate string SnapshotEventName(Type stateType);

/// <summary>
/// Represents a policy for creating snapshots of a specific type.
/// </summary>
public delegate ISnapshotPolicy SnapshotPolicyFactory(Type owner);
/// <summary>
/// Represents a delegate that defines a convention for handling metadata in an event.
/// </summary>
/// <param name="metadata">The dynamic metadata associated with the event.</param>
/// <param name="aggregate">The optional aggregate associated with the event.</param>
/// <param name="evt">The event object.</param>
public delegate void MetadataConvention(dynamic metadata, IAggregate? aggregate, object evt);

public delegate void BuildInvocationContext(InvocationContext context, Metadata m);
/// <summary>
/// Represents delegate that creates Uuid from an event and optinally aggregate instance.
/// </summary>
public delegate Uuid EventIdConvention(IAggregate? aggregator, object evt);

public delegate Uuid EventIdStateConvention(object state, object id, long? version);

/// <summary>
/// Represents a delegate that defines the convention for generating the output stream name based on the model type.
/// </summary>
/// <param name="model">The model type.</param>
/// <returns>The output stream name.</returns>
public delegate string OutputStreamModelConvention(Type model);
/// <summary>
/// Represents a delegate that defines a naming convention for group name used in persistent subscription.
/// </summary>
/// <param name="model">The type of the model.</param>
/// <returns>A string representing the group name for the model.</returns>
public delegate string GroupNameModelConvention(Type model);

/// <summary>
/// Represents a set of read-only conventions used by the MicroPlumberd framework.
/// </summary>
public interface IReadOnlyConventions : IExtension
{
    /// <summary>
    /// Gets the projection category stream convention. Used in plumber.Read operations to find out full stream-id from TOwner and Id.
    /// </summary>
    /// <value>
    /// The projection category stream convention.
    /// </value>
    ProjectionCategoryStreamConvention ProjectionCategoryStreamConvention { get; }

    /// <summary>
    /// Gets the stream name from event convention. This is used only in AppendEvent. The default searches for [OutputStreamAttribute]. If not found than the last segment of the namespace is used as category, that is not named "Events". 
    /// </summary>
    /// <value>
    /// The stream name from event convention.
    /// </value>
    StreamNameFromEventConvention StreamNameFromEventConvention { get;}
    /// <summary>
    /// Gets the get stream category convention. 
    /// </summary>
    /// <value>
    /// The get stream category convention.
    /// </value>
    StreamCategoryConvention GetStreamCategoryConvention { get;  }
    /// <summary>
    /// Gets or sets the get stream id convention. The default searches for [OutputStreamAttribute], if not present will return name of class and make it friendly (Generic names will be nicely formated).
    /// Used in:
    /// <list type="bullet">
    /// <item>Rehydrate</item>
    /// <item>Read</item>
    /// <item>SaveChanges</item>
    /// <item>SaveNew</item>
    /// </list>
    /// </summary>
    /// <value>
    /// The get stream identifier convention.
    /// </value>
    SteamNameConvention GetStreamIdConvention { get; }
    /// <summary>
    /// Gets or sets the get stream identifier snapshot convention. The default appends "Snapshot" suffix to the name found in [OutputStreamAttribute], if not present then will append to the name of class.
    /// Used in:
    /// <list type="bullet">
    /// <item>GetSnapshot</item>
    /// <item>AppendSnapshot</item>
    /// </list>
    /// </summary>
    /// <value>
    /// The get stream identifier snapshot convention.
    /// </value>
    SteamNameConvention GetStreamIdSnapshotConvention { get;  }

    /// <summary>
    /// Gets the stream identifier state convention. The default searches for [OutputStreamAttribute], if not present will return name of class and make it friendly (Generic names will be nicely formated).
    /// <list type="bullet">
    /// <item>AppendState</item>
    /// <item>GetState</item>
    /// </list>
    /// </summary>
    /// <value>
    /// The get stream identifier state convention.
    /// </value>
    SteamNameConvention GetStreamIdStateConvention { get; }
    /// <summary>
    /// Gets the snapshot event name convention. It appends to the name of the event suffix: "SnapShotted"
    /// </summary>
    /// <value>
    /// The snapshot event name convention.
    /// </value>
    SnapshotEventName SnapshotEventNameConvention { get;  }
    /// <summary>
    /// Gets the get event name convention. Used almost everywhere an event is saved to EventStoreDB.
    /// </summary>
    /// <value>
    /// The get event name convention.
    /// </value>
    EventNameConvention GetEventNameConvention { get; }
    BuildInvocationContext BuildInvocationContext { get;  }
    MetadataConvention? MetadataEnrichers { get;  }

    EventIdStateConvention GetEventIdStateConvention { get; }
    EventIdConvention GetEventIdConvention { get; }
    OutputStreamModelConvention OutputStreamModelConvention { get;  }
    GroupNameModelConvention GroupNameModelConvention { get;  }
    SnapshotPolicyFactory SnapshotPolicyFactoryConvention { get;  }
    StandardMetadataEnricherTypes StandardMetadataEnricherTypes { get;  }
    object GetMetadata(IAggregate? aggregate, object evt, object? metadata);

}
/// <summary>
/// An interface used to configure and provide conventions for Plumber.
/// </summary>
/// <seealso cref="MicroPlumberd.IExtension" />
public interface IConventions : IExtension
{
    /// <summary>
    /// Gets or sets the projection category stream convention. Used in plumber.Read operations to find out full stream-id from TOwner and Id.
    /// </summary>
    /// <value>
    /// The projection category stream convention.
    /// </value>
    ProjectionCategoryStreamConvention ProjectionCategoryStreamConvention { get; set; }
    /// <summary>
    /// Gets or sets the stream category convention. 
    /// </summary>
    /// <value>
    /// The get stream category convention.
    /// </value>
    StreamCategoryConvention GetStreamCategoryConvention { get; set; }
    /// <summary>
    /// Gets or sets the stream id convention. The default searches for [OutputStreamAttribute], if not present will return name of class and make it friendly (Generic names will be nicely formated).
    /// Used in:
    /// <list type="bullet">
    /// <item>Rehydrate</item>
    /// <item>Read</item>
    /// <item>SaveChanges</item>
    /// <item>SaveNew</item>
    /// </list>
    /// </summary>
    /// <value>
    /// The get stream identifier convention.
    /// </value>
    SteamNameConvention GetStreamIdConvention { get; set; }
    /// <summary>
    /// Gets or sets the stream identifier snapshot convention. The default appends "Snapshot" suffix to the name found in [OutputStreamAttribute], if not present then will append to the name of class.
    /// Used in:
    /// <list type="bullet">
    /// <item>GetSnapshot</item>
    /// <item>AppendSnapshot</item>
    /// </list>
    /// </summary>
    /// <value>
    /// The get stream identifier snapshot convention.
    /// </value>
    SteamNameConvention GetStreamIdSnapshotConvention { get; set; }
    /// <summary>
    /// Gets or sets the snapshot event name convention. It appends to the name of the event suffix: "SnapShotted"
    /// </summary>
    /// <value>
    /// The snapshot event name convention.
    /// </value>
    SnapshotEventName SnapshotEventNameConvention { get; set; }
    /// <summary>
    /// Gets or sets the event name convention. Used almost everywhere an event is saved to EventStoreDB.
    /// </summary>
    /// <value>
    /// The get event name convention.
    /// </value>
    EventNameConvention GetEventNameConvention { get; set; }

    BuildInvocationContext BuildInvocationContext { get; set; }
    MetadataConvention? MetadataEnrichers { get; set; }
    EventIdConvention GetEventIdConvention { get; set; }
    OutputStreamModelConvention OutputStreamModelConvention { get; set; }
    GroupNameModelConvention GroupNameModelConvention { get; set; }
    SnapshotPolicyFactory SnapshotPolicyFactoryConvention { get; set; }
    StandardMetadataEnricherTypes StandardMetadataEnricherTypes { get; set; }
    object GetMetadata(IAggregate? aggregate, object evt, object? metadata);
    /// <summary>
    /// Gets or sets the stream name from event convention. This is used only in AppendEvent. The default searches for [OutputStreamAttribute]. If not found than the last segment of the namespace is used as category, that is not named "Events". 
    /// </summary>
    /// <value>
    /// The stream name from event convention.
    /// </value>
    StreamNameFromEventConvention StreamNameFromEventConvention { get; set; }

}

public interface IExtension
{
    T GetExtension<T>() where T : new();
}
public static class GuidExtensions
{
    [StructLayout(LayoutKind.Explicit)]
    private struct GuidLongOverlay
    {
        [FieldOffset(0)]
        public Guid Guid;

        [FieldOffset(0)]
        public long Long;
    }

    public static Guid Xor(this in Guid guid, long value)
    {
        var overlay = new GuidLongOverlay { Guid = guid };
        overlay.Long ^= value;
        return overlay.Guid;
    }
}
class Conventions : IConventions, IReadOnlyConventions
{
    private readonly ConcurrentDictionary<Type,object> _extension = new();
    public T GetExtension<T>() where T : new() => (T)_extension.GetOrAdd(typeof(T), x => new T());
    private StandardMetadataEnricherTypes _standardMetadataEnricherTypes = StandardMetadataEnricherTypes.All;
    public SteamNameConvention GetStreamIdConvention { get; set; }
    public SteamNameConvention GetStreamIdSnapshotConvention { get; set; }
    public SteamNameConvention GetStreamIdStateConvention { get; set; }
    public SnapshotEventName SnapshotEventNameConvention { get; set; } = t => $"{t.GetFriendlyName()}SnapShotted";
    public StreamCategoryConvention GetStreamCategoryConvention { get; set; } = OutputStreamOrFriendlyTypeName;
    public EventNameConvention GetEventNameConvention { get; set; } = (aggregate, evt) => evt.GetFriendlyName();
    public MetadataConvention? MetadataEnrichers { get; set; }
    public BuildInvocationContext BuildInvocationContext { get; set; } = InvocationContext.Build;
    public EventIdConvention GetEventIdConvention { get; set; } = EventIdConvention;
    public EventIdStateConvention GetEventIdStateConvention { get; set; } = EventIdStateConvention;

    private static Uuid EventIdStateConvention(object state, object? id, long? version)
    {
        Guid g = Guid.Empty;
        if (id == null) return Uuid.NewUuid();
        
        if(id is Guid guid)
            g = guid;
        else if (!Guid.TryParse(id.ToString(), out g))
            g = id.ToString().ToGuid();
            
        if(version != null)
            g = g.Xor(version.Value);

        if (g == Guid.Empty) throw new InvalidOperationException("Guid cannot be empty");
        
        return g == Guid.Empty ? Uuid.NewUuid() : Uuid.FromGuid(g);
    }

    private static Uuid EventIdConvention(IAggregate? aggregate, object evt)
    {
        if (!IdDuckTyping.Instance.TryGetGuidId(evt, out var g)) return Uuid.NewUuid();
        
        if (g == Guid.Empty) throw new InvalidOperationException("Guid cannot be empty");
        return Uuid.FromGuid(g);

    }

    public OutputStreamModelConvention OutputStreamModelConvention { get; set; } = OutputStreamOrFriendlyTypeName;
    public GroupNameModelConvention GroupNameModelConvention { get; set; } = (t) => t.GetFriendlyName();
    public SnapshotPolicyFactory SnapshotPolicyFactoryConvention { get; set; }
    public ProjectionCategoryStreamConvention ProjectionCategoryStreamConvention { get; set; }
    public StreamNameFromEventConvention StreamNameFromEventConvention { get; set; }
    public StandardMetadataEnricherTypes StandardMetadataEnricherTypes
    {
        get => _standardMetadataEnricherTypes;
        set
        {
            if (_standardMetadataEnricherTypes == value) return;

            AdjustEnrichersFromFlag(StandardMetadataEnricherTypes.Created, value,StandardMetadataEnrichers.CreatedTimeMetadata);
            AdjustEnrichersFromFlag(StandardMetadataEnricherTypes.InvocationContext, value, StandardMetadataEnrichers.InvocationContextMetadata);

            _standardMetadataEnricherTypes = value;
        }
    }

    private void AdjustEnrichersFromFlag(StandardMetadataEnricherTypes flag, StandardMetadataEnricherTypes value, MetadataConvention mth)
    {
        var isOn = value.HasFlag(flag);
        var wasOn = _standardMetadataEnricherTypes.HasFlag(flag);
        if (!(wasOn ^ isOn)) return;
        
        if (wasOn) MetadataEnrichers -= mth;
        else MetadataEnrichers += mth;
    }

    public Conventions()
    {
        MetadataEnrichers += StandardMetadataEnrichers.CreatedTimeMetadata;
        MetadataEnrichers += StandardMetadataEnrichers.InvocationContextMetadata;
        GetStreamIdConvention = (aggregateType,id) => $"{GetStreamCategoryConvention(aggregateType)}-{id}";
        GetStreamIdSnapshotConvention = (aggregateType, id) => $"{GetStreamCategoryConvention(aggregateType)}Snapshot-{id}";
        GetStreamIdStateConvention = (aggregateType, id) => $"{GetStreamCategoryConvention(aggregateType)}-{id}";
        ProjectionCategoryStreamConvention =(t) => $"$ce-{GetStreamCategoryConvention(t)}";
        StreamNameFromEventConvention = ComputeStreamName;
    }

    private static string ComputeStreamName(Type eventType, object? id)
    {
        var o = eventType.GetCustomAttribute<OutputStreamAttribute>();
        var category = o != null
            ? o.OutputStreamName
            : eventType.Namespace?.Split('.').LastOrDefault(x => x != "Events") ?? "None";

        return id != null ? $"{category}-{id}" : category;
    }

    private static string OutputStreamOrFriendlyTypeName(Type model) => model.GetCustomAttribute<OutputStreamAttribute>()?.OutputStreamName ?? model.GetFriendlyName();

    public object GetMetadata(IAggregate? aggregate, object evt, object? metadata)
    {
        ExpandoObject obj = new ExpandoObject();
        MetadataEnrichers?.Invoke(obj, aggregate, evt);
        if (metadata == null) return obj;

        IDictionary<string, object> kv = obj!;
        foreach (var i in metadata.GetType().GetProperties().Where(x => x.CanRead))
        {
            string prop = i.Name
                .Replace("CorrelationId", "$correlationId")
                .Replace("CausationId", "$causationId");
            var value = i.GetGetMethod(false)!.Invoke(metadata, null)!;
            kv[prop] = value;
        }
        return obj;
    }

    
}
[Flags]
public enum StandardMetadataEnricherTypes
{
    None = 0x0,
    Created = 0x1,
    InvocationContext = 0x2,
    All = 0x3
}
static class StandardMetadataEnrichers
{
    public static void CreatedTimeMetadata(dynamic metadata, IAggregate? aggregate, object evt)
    {
        metadata.Created = DateTimeOffset.Now;

    }

    public static void InvocationContextMetadata(dynamic metadata, IAggregate? aggregate, object evt)
    {
        var src = (IDictionary<string, object>)InvocationContext.Current.Value;
        var dst = (IDictionary<string, object>)metadata;
        foreach(var i in src)
            dst.Add(i.Key, i.Value);
    }
}

public class InvocationScope : IDisposable
{
    public InvocationScope() { }

    public InvocationScope(InvocationContext copy) => InvocationContext.Current = copy;
    public InvocationContext Context => InvocationContext.Current;
    public InvocationContext SetCorrelation(Guid correlationId) => Context.SetCorrelation(correlationId);
    public InvocationContext SetCausation(Guid causationId) => Context.SetCausation(causationId);
    public InvocationContext SetUserId(Guid userId) => Context.SetUserId(userId);
    public InvocationContext Set(string key, object value) => Context.Set(key, value);
    public bool ContainsProperty(string propertyName) => Context.ContainsProperty(propertyName);
    public void Dispose() => InvocationContext.Current.Clear();
}

public static class TypeExtensions
{
    public static string GetFriendlyName(this Type type)
    {
        if (!type.IsGenericType)
        {
            return type.Name;
        }

        StringBuilder builder = new StringBuilder();
        string name = type.Name;
        int index = name.IndexOf('`');
        if (index > 0)
        {
            name = name.Substring(0, index);
        }

        builder.Append(name);
        builder.Append('<');

        Type[] genericArguments = type.GetGenericArguments();
        for (int i = 0; i < genericArguments.Length; i++)
        {
            string argumentName = GetFriendlyName(genericArguments[i]);
            if (i > 0)
            {
                builder.Append(", ");
            }
            builder.Append(argumentName);
        }
        builder.Append('>');

        return builder.ToString();
    }
}
public static class MetadataExtensions
{
    public static DateTimeOffset? Created(this Metadata m)
    {

        if (m.Data.TryGetProperty("Created", out var v))
            return DateTimeOffset.Parse(v.GetString()!);
        return null;
    }

    public static long? SnapshotVersion(this Metadata m)
    {
        if (m.Data.TryGetProperty("SnapshotVersion", out var v))
            return v.GetInt64();
        return null;
    }
    public static Guid? CorrelationId(this Metadata m)
    {
        if (m.Data.TryGetProperty("$correlationId", out var v))
            return Guid.Parse(v.GetString()!);
        return null;
    }
    public static Guid? CausationId(this Metadata m)
    {
        if (m.Data.TryGetProperty("$causationId", out var v))
            return Guid.Parse(v.GetString()!);
        return null;
    }
    public static bool TryGetValue<TValue>(this Metadata m, string propertyName, out TValue value)
    {
        if (m.Data.TryGetProperty(propertyName, out var v))
        {
            value = JsonSerializer.Deserialize<TValue>(v);
            return true;
        }

        value = default;
        return false;
    }
}
public class InvocationContext
{
    public InvocationContext SetCorrelation(Guid correlationId) => Set("$correlationId", correlationId);

    public InvocationContext SetCausation(Guid causationId) => Set("$causationId", causationId);
    public InvocationContext SetUserId(Guid userId)
    {
        Value.UserId = userId;
        return this;
    }

    public Guid? CausactionId() => TryGetValue<Guid>("$causationId", out var v) ? v : null;
    
    private static AsyncLocal<InvocationContext> _current = new AsyncLocal<InvocationContext>();
    public static InvocationContext Current
    {
        get => _current.Value ?? (_current.Value = new InvocationContext());
        set => _current.Value = value;
    }

    private readonly ExpandoObject _data;
    private InvocationContext()
    {
        _data = new ExpandoObject();
    }
    private InvocationContext(ExpandoObject data)
    {
        _data = data;
    }

    public dynamic Value => _data;
    
    public InvocationContext Set(string key, object value)
    {
        var dict  = (IDictionary<string, object>)_data!;
        dict[key] = value;
        return this;
    }
    public bool ContainsProperty(string propertyName) => ((IDictionary<string, object>)_data!).ContainsKey(propertyName);

    public bool TryGetValue<TValue>(string propertyName, out TValue value)
    {
        var dict = (IDictionary<string, object>)_data!;
        if (dict.TryGetValue(propertyName, out var v))
        {
            value = (TValue)v;
            return true;
        }

        value = default;
        return false;
    }

    
    public void Clear()
    {
        IDictionary<string, object> obj = _data!;
        obj.Clear();
    }

    public void ClearCorrelation()
    {
        var dict = (IDictionary<string, object>)_data!;
        dict.Remove("$correlationId");
    }

    public Guid? CorrelationId() => TryGetValue<Guid>("$correlationId", out var v) ? v : null;

    public static void Build(InvocationContext context, Metadata metadata)
    {
        if (metadata.CorrelationId() != null)
            context.SetCorrelation(metadata.CorrelationId()!.Value);
        else context.ClearCorrelation();
        context.SetCausation(metadata.CausationId() != null ? metadata.CausationId()!.Value : metadata.EventId);
    }

    public InvocationContext Clone()
    {
        var dictOriginal = _data as IDictionary<string, object>; // ExpandoObject supports IDictionary
        var dst = new ExpandoObject();
        var dictClone = dst as IDictionary<string, object>;

        // Shallow copy, for deep copy you need a different approach
        foreach (var kvp in dictOriginal) dictClone[kvp.Key] = kvp.Value; 

        return new InvocationContext(dst);
    }
}


// --- File: MicroPlumberd\EventRecord.cs ---


namespace MicroPlumberd;

public interface IEventRecord<out TEvent> : IEventRecord
{
    new TEvent Event { get; }
}

record EventRecord<TEvent> : IEventRecord<TEvent>
{
    public Metadata Metadata { get; init; }
    public TEvent Event { get; init; }
    object IEventRecord.Event => Event;
}


// --- File: MicroPlumberd\EventStoreProjectionManagementClientExtensions.cs ---


using EventStore.Client;
using Grpc.Core;
using Microsoft.Win32;

namespace MicroPlumberd;

public static class EventStoreProjectionManagementClientExtensions
{
    public static async Task TryCreateJoinProjection(this EventStoreProjectionManagementClient client,
        string outputStream, IEnumerable<string> eventTypes)
    {
        var query = CreateQuery(outputStream, eventTypes);

        if (await client.ListContinuousAsync().AnyAsync(x => x.Name == outputStream))
            await Update(client, outputStream, query);
        else
            await client.CreateContinuousAsync(outputStream, query, true);
    }

    private static async Task Update(EventStoreProjectionManagementClient client, string outputStream, string query,
        CancellationToken token = default)
    {
        for (int i = 0; i < PROJECTION_UPDATE_RETRY_COUNT; i++)
        {
            try
            {
                var state = await client.GetStatusAsync(outputStream, cancellationToken: token);
                if (state!.Status != "Stopped")
                    await client.DisableAsync(outputStream, cancellationToken: token);
                await client.UpdateAsync(outputStream, query, true, cancellationToken: token);
                await client.EnableAsync(outputStream, cancellationToken: token);
                return;
            }
            catch (RpcException ex)
            {
                if (ex.Status.StatusCode != StatusCode.DeadlineExceeded) throw;
                if (i == PROJECTION_UPDATE_RETRY_COUNT - 1)
                    throw;
                
                await Task.Delay(Random.Shared.Next(1000), token);
            }
        }
        // We'll never reach this place, because of if in catch.
    }

    /// <summary>
    /// Ensures the existence and proper configuration of a lookup projection in the EventStore.
    /// </summary>
    /// <param name="client">
    /// The <see cref="EventStoreProjectionManagementClient"/> instance used to manage projections.
    /// </param>
    /// <param name="register">
    /// The <see cref="IProjectionRegister"/> instance used to check the existence of the projection.
    /// </param>
    /// <param name="category">
    /// The category of events to be processed by the projection.
    /// </param>
    /// <param name="eventProperty">
    /// The property of the event used to determine the output stream.
    /// </param>
    /// <param name="outputStreamCategory">
    /// The category of the output stream to which events will be linked.
    /// </param>
    /// <param name="token">
    /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
    /// </param>
    /// <returns>
    /// A <see cref="Task"/> representing the asynchronous operation.
    /// </returns>
    /// <remarks>
    /// This method creates a continuous projection in the EventStore that links events from the specified category
    /// to output streams based on the value of the specified event property. If the projection already exists,
    /// it will be updated to ensure it matches the desired configuration.
    /// </remarks>
    public static async Task EnsureLookupProjection(this EventStoreProjectionManagementClient client, IProjectionRegister register, string category, string eventProperty, string outputStreamCategory, CancellationToken token = default)
    {
        string query =
            $"fromStreams(['$ce-{category}']).when( {{ \n    $any : function(s,e) {{ \n        if(e.body && e.body.{eventProperty}) {{\n            linkTo('{outputStreamCategory}-' + e.body.{eventProperty}, e) \n        }}\n        \n    }}\n}});";
        if ((await register.Get(outputStreamCategory)) != null)
            await Update(client, outputStreamCategory, query);
        else
        {
            await client.CreateContinuousAsync(outputStreamCategory, query, false, cancellationToken: token);
            await client.DisableAsync(outputStreamCategory, cancellationToken: token);
            await client.UpdateAsync(outputStreamCategory, query, true, cancellationToken: token);
            await client.EnableAsync(outputStreamCategory, cancellationToken: token);
        }
    }

    private const int PROJECTION_UPDATE_RETRY_COUNT = 10;
    /// <summary>
    /// Attempts to create or update a join projection in the EventStore.
    /// </summary>
    /// <param name="client">The <see cref="EventStoreProjectionManagementClient"/> used to manage projections.</param>
    /// <param name="outputStream">The name of the output stream for the join projection.</param>
    /// <param name="register">The projection register used to check for existing projections.</param>
    /// <param name="eventTypes">The collection of event types to include in the join projection.</param>
    /// <param name="token">An optional <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public static async Task TryCreateJoinProjection(this EventStoreProjectionManagementClient client,
        string outputStream, IProjectionRegister register, IEnumerable<string> eventTypes, CancellationToken token = default)
    {
        if (!eventTypes.Any())
            throw new ArgumentOutOfRangeException(
                $"There are not event type to create the output stream: {outputStream}");
        
        var query = CreateQuery(outputStream, eventTypes);


        if ((await register.Get(outputStream)) != null)
            await Update(client, outputStream, query, token);
        else
        {
            await client.CreateContinuousAsync(outputStream, query, false, cancellationToken: token);
            await client.DisableAsync(outputStream, cancellationToken: token);
            await client.UpdateAsync(outputStream, query, true, cancellationToken: token);
            await client.EnableAsync(outputStream, cancellationToken: token);
        }


    }

    private static string CreateQuery(string outputStream, IEnumerable<string> eventTypes)
    {
        string fromStreamsArg = string.Join(',', eventTypes.Select(x => $"'$et-{x}'"));
        string query = $"fromStreams([{fromStreamsArg}]).when( {{ " +
                       $"\n    $any : function(s,e) {{ linkTo('{outputStream}', e) }}" +
                       $"\n}});";
        return query;
    }
}


// --- File: MicroPlumberd\IEventRecord.cs ---


namespace MicroPlumberd;

public interface IEventRecord
{
    Metadata Metadata { get; }
    object Event { get; }
}


// --- File: MicroPlumberd\Internals.cs ---


using EventStore.Client;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("MicroPlumberd.Tests")]
//[assembly: InternalsVisibleTo("MicroPlumberd.Services")]

public static class EventStoreClientSettingsExtensions
{
    static readonly HttpClient client = new HttpClient();
    public static async Task WaitUntilReady(this EventStoreClientSettings settings, TimeSpan timeout, TimeSpan? delay = null)
    {

        DateTime until = DateTime.Now.Add(timeout);
        client.BaseAddress = settings.ConnectivitySettings.Address;
        client.Timeout = TimeSpan.FromMilliseconds(100);
        while (DateTime.Now < until)
        {
            try
            {
                var ret = await client.GetAsync("health/live");
                if (ret.IsSuccessStatusCode)
                    return;
            }
            catch { await Task.Delay(delay ?? TimeSpan.FromMilliseconds(100)); }
        }

        throw new TimeoutException("EventStore is not ready, check docker-containers.");
    }
}


// --- File: MicroPlumberd\IPlumberConfig.cs ---


using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd;

public interface IPlumberConfig : IExtension
{
    Func<Type, IObjectSerializer> SerializerFactory { get; set; }
    IConventions Conventions { get; }
    IServiceProvider ServiceProvider { get; set; }
    event Action<IPlumber> Created;

    void SetErrorHandlePolicy(Func<Exception, string, CancellationToken, Task<ErrorHandleDecision>> handler);
}

public interface IPlumberReadOnlyConfig : IExtension
{
    Func<Type, IObjectSerializer> SerializerFactory { get; }
    IReadOnlyConventions Conventions { get; }
    IServiceProvider ServiceProvider { get; }
    Task<ErrorHandleDecision> HandleError(Exception ex, string streamName, CancellationToken token);
}

public enum ErrorHandleDecision
{
    /// <summary>
    /// Will retry
    /// </summary>
    Retry,
    /// <summary>
    /// Will cancel subscription
    /// </summary>
    Cancel,
    /// <summary>
    /// Will ignore current error.
    /// </summary>
    Ignore
}


// --- File: MicroPlumberd\ITypeHandlerRegisters.cs ---


namespace MicroPlumberd;

public interface ITypeHandlerRegisters
{
    IEnumerable<Type> HandlerTypes { get; }
    TypeEventConverter GetEventNameConverterFor<THandler>() where THandler:ITypeRegister;
    IEnumerable<KeyValuePair<string, Type>> GetEventNameMappingsFor<THandler>() where THandler : ITypeRegister;
    IEnumerable<string> GetEventNamesFor<THandler>() where THandler : ITypeRegister;
}





// --- File: MicroPlumberd\JsonParsableConverter.cs ---


using System.Text.Json;
using System.Text.Json.Serialization;

namespace MicroPlumberd;

public class JsonParsableConverter<T> : JsonConverter<T> where T : IParsable<T>
{
    public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var str = reader.GetString();
        //Console.WriteLine($"Parsing: {str}");
        return T.Parse(str, null);
    }

    public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
    {
        writer.WriteStringValue(value.ToString());
    }
}


// --- File: MicroPlumberd\PersistentSubscriptionRunner.cs ---


using System.Diagnostics;
using EventStore.Client;
using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd;

class PersistentSubscriptionRunner(Plumber plumber, EventStorePersistentSubscriptionsClient.PersistentSubscriptionResult subscription) : ISubscriptionRunner
{
    public async Task<T> WithHandler<T>(T model)
        where T : IEventHandler, ITypeRegister
    {
        return await WithHandler<T>(model, plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());
    }

    public async Task<T> WithHandler<T>(T model, TypeEventConverter func)
        where T : IEventHandler
    {
        var state = new Tuple<EventStorePersistentSubscriptionsClient.PersistentSubscriptionResult, T>(subscription, model);
        await Task.Factory.StartNew(async (x) =>
        {
            var (sub, model) = (Tuple<EventStorePersistentSubscriptionsClient.PersistentSubscriptionResult, T>)x!;

            await foreach (var e in sub)
            {
                if (!func(e.Event.EventType, out var t)) continue;

                var (ev, metadata) = plumber.ReadEventData(e.Event,e.Link, t);

                using var scope = new InvocationScope();
                plumber.Conventions.BuildInvocationContext(scope.Context, metadata);
                await model.Handle(metadata, ev);
                await sub.Ack(e);
            }

        }, state, TaskCreationOptions.LongRunning);
        return model;
    }

    public async Task<IEventHandler> WithHandler<T>(TypeEventConverter func) where T : IEventHandler
    {
        var handler = plumber.ServiceProvider.GetService<IEventHandler<T>>() ?? (IEventHandler)plumber.ServiceProvider.GetRequiredService<T>();
        return (IEventHandler)await WithHandler(handler, func);
    }
    public async Task<IEventHandler> WithHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());

    public async ValueTask DisposeAsync() => await subscription.DisposeAsync();

    public async Task<IEventHandler> WithHandler<T>(ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithHandler<T>(T model, ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model,register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>(T model) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model, new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());

}


// --- File: MicroPlumberd\Plumber.cs ---


using System.Collections.Concurrent;
using System.Collections.Frozen;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Text;
using EventStore.Client;
using Grpc.Core;
using MicroPlumberd.Utils;

namespace MicroPlumberd;

/// <summary>
///     Root class for ED plumbing.
/// </summary>
public class Plumber : IPlumber, IPlumberReadOnlyConfig
{
    private readonly ConcurrentDictionary<Type, object> _extension = new();
    private readonly ConcurrentDictionary<Type, ISnapshotPolicy> _policies = new();
    private readonly TypeHandlerRegisters _typeHandlerRegisters;
    private readonly ConcurrentDictionary<Type, IObjectSerializer> _serializers = new();
    
    private readonly VersionDuckTyping _versionTyping = new();
    private readonly Func<Exception, string, CancellationToken, Task<ErrorHandleDecision>> _errorHandle;
    private ProjectionRegister? _projectionRegister;

    internal Plumber(EventStoreClientSettings settings, PlumberConfig? config = null)
    {
        config ??= new PlumberConfig();
        Client = new EventStoreClient(settings);
        PersistentSubscriptionClient = new EventStorePersistentSubscriptionsClient(settings);
        ProjectionManagementClient = new EventStoreProjectionManagementClient(settings);
        Conventions = config.Conventions;
        SerializerFactory = config.SerializerFactory;
        ServiceProvider = config.ServiceProvider;
        _extension = config.Extension; // Shouldn't we make a copy?
        _typeHandlerRegisters = new TypeHandlerRegisters(Conventions.GetEventNameConvention);
        this._errorHandle = config.ErrorHandlePolicy;
        config.OnCreated(this);
    }
    public IPlumberReadOnlyConfig Config => this;

    public ITypeHandlerRegisters TypeHandlerRegisters => _typeHandlerRegisters;
    public EventStoreClient Client { get; }

    public IProjectionRegister ProjectionRegister =>
        _projectionRegister ??= new ProjectionRegister(ProjectionManagementClient);

    public EventStorePersistentSubscriptionsClient PersistentSubscriptionClient { get; }
    public EventStoreProjectionManagementClient ProjectionManagementClient { get; }

    /// <summary>
    /// </summary>
    public IServiceProvider ServiceProvider { get; }

    public Task<ErrorHandleDecision> HandleError(Exception ex, string streamName, CancellationToken t) => _errorHandle(ex,streamName,t);
    public Func<Type, IObjectSerializer> SerializerFactory { get; }
    public IReadOnlyConventions Conventions { get; }

    public ISubscriptionRunner Subscribe(string streamName, FromRelativeStreamPosition start,
        UserCredentials? userCredentials = null, CancellationToken cancellationToken = default)
    {
        if (start.Count == 0)
            return new SubscriptionRunner(this,
                new SubscriptionRunnerState(start.StartPosition, Client, streamName, userCredentials, cancellationToken));
        return new SubscriptionSeeker(this, streamName, start, userCredentials, cancellationToken);
    }

    public Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TypeEventConverter mapFunc, IEnumerable<string>? eventTypes,
        TEventHandler? eh = default, string? outputStream = null, FromStream? start = null,
        bool ensureOutputStreamProjection = true) where TEventHandler : class, IEventHandler
    {
        return SubscribeEventHandler<TEventHandler>(mapFunc, eventTypes, eh, outputStream,
            start != null ? (FromRelativeStreamPosition)start.Value : null, ensureOutputStreamProjection);
    }

    /// <summary>
    /// Ensures that a join projection is created for the specified event handler type.
    /// </summary>
    /// <typeparam name="TEventHandler">
    /// The type of the event handler, which must implement both <see cref="IEventHandler"/> and <see cref="ITypeRegister"/>.
    /// </typeparam>
    /// <param name="outputStream">
    /// The name of the output stream for the join projection. If <c>null</c>, the output stream name is determined
    /// using the <see cref="IReadOnlyConventions.OutputStreamModelConvention"/> for the specified event handler type.
    /// </param>
    /// <param name="token">
    /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
    /// </param>
    /// <returns>
    /// A <see cref="Task"/> representing the asynchronous operation.
    /// </returns>
    public Task TryCreateJoinProjection<TEventHandler>(string? outputStream=null, CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
    {
        return TryCreateJoinProjection(outputStream ?? Conventions.OutputStreamModelConvention(typeof(TEventHandler)), _typeHandlerRegisters.GetEventNamesFor<TEventHandler>(), token);
    }

    /// <summary>
    /// Ensures that a join projection is created or updated for the specified output stream and event types.
    /// </summary>
    /// <param name="outputStream">
    /// The name of the output stream where the projection results will be written.
    /// </param>
    /// <param name="eventTypes">
    /// A collection of event type names to be included in the join projection.
    /// </param>
    /// <param name="token">
    /// A <see cref="CancellationToken"/> to observe while waiting for the task to complete.
    /// </param>
    /// <returns>
    /// A <see cref="Task"/> representing the asynchronous operation.
    /// </returns>
    public async Task TryCreateJoinProjection(string outputStream, IEnumerable<string> eventTypes, CancellationToken token = default)
    {
        await ProjectionManagementClient.TryCreateJoinProjection(outputStream, ProjectionRegister, eventTypes, token: token);
    }
    public async Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TEventHandler? eh = null,
        string? outputStream = null,
        FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
        CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
    {
        return await SubscribeEventHandler(_typeHandlerRegisters.GetEventNameConverterFor<TEventHandler>()!,
            _typeHandlerRegisters.GetEventNamesFor<TEventHandler>(),
            eh, outputStream, start, ensureOutputStreamProjection, token);
    }
    public async Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(TEventHandler? eh = null,
        string? outputStream = null,
        FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
        CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
    {
        var evts = TEventHandler.Types.Select(x => this.Conventions.SnapshotEventNameConvention(x)).ToArray();
        return await SubscribeStateEventHandler(evts, eh, outputStream, start, ensureOutputStreamProjection, token);
    }
    public async Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(
        IEnumerable<string>? eventTypes, 
        TEventHandler? eh = default,
        string? outputStream = null,
        FromRelativeStreamPosition? start = null, 
        bool ensureOutputStreamProjection = true, 
        CancellationToken token = default)
        where TEventHandler : class, IEventHandler, ITypeRegister
    {
        eventTypes ??= Array.Empty<string>();

        outputStream ??= Conventions.OutputStreamModelConvention(typeof(TEventHandler));
        if (ensureOutputStreamProjection)
            await ProjectionManagementClient.TryCreateJoinProjection(outputStream, ProjectionRegister, eventTypes, token: token);
        var sub = Subscribe(outputStream, start ?? FromStream.Start, cancellationToken: token);
        if (eh == null)
            await sub.WithSnapshotHandler<TEventHandler>();
        else
            await sub.WithSnapshotHandler(eh);
        return sub;
    }
    public async Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TypeEventConverter mapFunc,
        IEnumerable<string>? eventTypes, TEventHandler? eh = default, string? outputStream = null,
        FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true, CancellationToken token = default)
        where TEventHandler : class, IEventHandler
    {
        eventTypes ??= Array.Empty<string>();

        outputStream ??= Conventions.OutputStreamModelConvention(typeof(TEventHandler));
        if (ensureOutputStreamProjection)
            await ProjectionManagementClient.TryCreateJoinProjection(outputStream, ProjectionRegister, eventTypes, token: token);
        var sub = Subscribe(outputStream, start ?? FromStream.Start, cancellationToken:token);
        if (eh == null)
            await sub.WithHandler<TEventHandler>(mapFunc);
        else
            await sub.WithHandler(eh, mapFunc);
        return sub;
    }

    public async Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TypeEventConverter mapFunc,
        IEnumerable<string>? events,
        TEventHandler? model,
        string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
        bool ensureOutputStreamProjection = true, 
        int minCheckpointCount = 1,
        CancellationToken token = default)
        where TEventHandler : class, IEventHandler
    {
        var handlerType = typeof(TEventHandler);
        startFrom ??= StreamPosition.End;
        outputStream ??= Conventions.OutputStreamModelConvention(handlerType);
        groupName ??= Conventions.GroupNameModelConvention(handlerType);
        if (ensureOutputStreamProjection)
            await ProjectionManagementClient.TryCreateJoinProjection(outputStream, ProjectionRegister, events, token);

        try
        {
            await PersistentSubscriptionClient.GetInfoToStreamAsync(outputStream, groupName, cancellationToken: token);
        }
        catch (PersistentSubscriptionNotFoundException)
        {
            await PersistentSubscriptionClient.CreateToStreamAsync(outputStream, groupName,
                new PersistentSubscriptionSettings(true, startFrom, checkPointLowerBound: minCheckpointCount), cancellationToken: token);
        }

        var sub = SubscribePersistently(outputStream, groupName, cancellationToken:token);
        if (model == null)
            await sub.WithHandler<TEventHandler>(mapFunc);
        else
            await sub.WithHandler(model, mapFunc);
        return sub;
        return sub;
    }

    public Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TEventHandler? model,
        string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
        bool ensureOutputStreamProjection = true, int minCheckPointCount = 1, CancellationToken token = default)
        where TEventHandler : class, IEventHandler, ITypeRegister
    {
        return SubscribeEventHandlerPersistently(_typeHandlerRegisters.GetEventNameConverterFor<TEventHandler>(),
            _typeHandlerRegisters.GetEventNamesFor<TEventHandler>(),
            model, outputStream, groupName, startFrom, ensureOutputStreamProjection, minCheckPointCount, token);
    }


    public ISubscriptionRunner SubscribePersistently(string streamName, string groupName, int bufferSize = 10, 
        UserCredentials? userCredentials = null, CancellationToken cancellationToken = default)
    {
        return new PersistentSubscriptionRunner(this,
            PersistentSubscriptionClient.SubscribeToStream(streamName, groupName, bufferSize,  userCredentials,
                cancellationToken));
    }

    public async Task Rehydrate<T>(T model, Guid id, StreamPosition? position = null, CancellationToken token = default)
        where T : IEventHandler, ITypeRegister
    {
        var streamId = Conventions.GetStreamIdConvention(typeof(T), id);
        await Rehydrate(model, streamId, position, token);
    }

    public async Task Rehydrate<T>(T model, string streamId, StreamPosition? position = null, CancellationToken token = default)
        where T : IEventHandler, ITypeRegister
    {
        TypeEventConverter registry = _typeHandlerRegisters.GetEventNameConverterFor<T>();
        await Rehydrate(model, streamId, registry, position, token);
    }
    public async Task Rehydrate<T>(T model, string streamId, TypeEventConverter converter, StreamPosition? position = null, CancellationToken token = default)
        where T : IEventHandler
    {
        var pos = position ?? StreamPosition.Start;
        var items = Client.ReadStreamAsync(Direction.Forwards, streamId, pos, resolveLinkTos: true, cancellationToken: token);

        var vAware = model as IVersionAware;

        if (await items.ReadState == ReadState.StreamNotFound) return;

        await foreach (var i in items)
        {
            if (!converter(i.Event.EventType, out var t))
                continue;
            var (evt, metadata) = ReadEventData(i.Event, i.Link, t);
            await model.Handle(metadata, evt);
            vAware?.Increase();
        }
    }

    public async Task<IEventRecord?> FindEventInStream(string streamId, Guid id,
        TypeEventConverter eventMapping, Direction scanDirection = Direction.Backwards, CancellationToken token = default)
    {
        return await FindEventInStream<object>(streamId, id, eventMapping, scanDirection, token);
    }

    public async Task<IEventRecord<TEvent>?> FindEventInStream<TEvent>(string streamId, Guid id,
        TypeEventConverter? eventMapping = null, Direction scanDirection = Direction.Backwards, CancellationToken token = default)
    {
        var items = Client.ReadStreamAsync(Direction.Forwards, streamId, StreamPosition.Start, cancellationToken:token);

        bool TryMapEventByName(string x, out Type tt)
        {
            var name = Conventions.GetEventNameConvention(null, typeof(TEvent));
            if (x == name)
            {
                tt = typeof(TEvent);
                return true;
            }

            tt = null;
            return false;
        }

        eventMapping ??= TryMapEventByName;
        await foreach (var i in items)
        {
            if (i.Event.EventId.ToGuid() != id) continue;
            if (eventMapping(i.Event.EventType, out var t))
                throw new ArgumentException($"We don't know how to deserialize this event: {i.Event.EventType}.");

            var (evt, metadata) = ReadEventData(i.Event,i.Link, t);
            return new EventRecord<TEvent> { Event = (TEvent)evt, Metadata = metadata };
        }

        return null;
    }

    public ISubscriptionSet SubscribeSet()
    {
        return new SubscriptionSet(this);
    }

    public IAsyncEnumerable<object> Read<TOwner>(object id, StreamPosition? start = null, Direction? direction = null,
        long maxCount = long.MaxValue, CancellationToken token = default) where TOwner : ITypeRegister
    {
        start ??= StreamPosition.Start;

        var streamId = Conventions.GetStreamIdConvention(typeof(TOwner), id);
        var registry = _typeHandlerRegisters.GetEventNameConverterFor<TOwner>();
        return Read(streamId, registry, start, direction, maxCount, token);
    }

    public IAsyncEnumerable<object> Read<TOwner>(StreamPosition? start = null, Direction? direction = null,
        long maxCount = long.MaxValue, CancellationToken token = default) where TOwner : ITypeRegister
    {
        var streamId = Conventions.ProjectionCategoryStreamConvention(typeof(TOwner));
        var evNameConv = _typeHandlerRegisters.GetEventNameConverterFor<TOwner>();
        return Read(streamId, evNameConv, start, direction, maxCount, token);
    }

    public async IAsyncEnumerable<(object, Metadata)> ReadFull(string streamId, TypeEventConverter converter,
        StreamPosition? start = null, Direction? direction = null, long maxCount = long.MaxValue, [EnumeratorCancellation] CancellationToken token = default)
    {
        var d = direction ?? Direction.Forwards;
        var p = start ?? StreamPosition.Start;

        var items = Client.ReadStreamAsync(d, streamId, p, resolveLinkTos: true, maxCount: maxCount, cancellationToken:token);
        if (await items.ReadState == ReadState.StreamNotFound) yield break;

        var events = items.Select(x => new
                { ResolvedEvent = x, EventType = converter(x.Event.EventType, out var t) ? t : null })
            .Where(x => x.EventType != null)
            .Select(ev => ReadEventData(ev.ResolvedEvent.Event, ev.ResolvedEvent.Link, ev.EventType));
        await foreach (var i in events)
            yield return i;
    }
    public async IAsyncEnumerable<(T, Metadata)> ReadEventsOfType<T>(string? streamId = null, StreamPosition? start = null, Direction? direction = null,
        long maxCount = 9223372036854775807, CancellationToken token = default)
    {
        string eventName = this.Conventions.GetEventNameConvention(null, typeof(T));

        bool converter(string en, out Type t)
        {
            if (en == eventName)
            {
                t = typeof(T);
                return true;
            }

            t = null;
            return false;
        }

        streamId ??= $"$et-{eventName}";

        var d = direction ?? Direction.Forwards;
        var p = start ?? StreamPosition.Start;

        var items = Client.ReadStreamAsync(d, streamId, p, resolveLinkTos: true, maxCount: maxCount, cancellationToken: token);
        if (await items.ReadState == ReadState.StreamNotFound) yield break;

        var events = items.Select(x => new
                { ResolvedEvent = x, EventType = converter(x.Event.EventType, out var t) ? t : null })
            .Where(x => x.EventType != null)
            .Select(ev => ReadEventData(ev.ResolvedEvent.Event, ev.ResolvedEvent.Link, ev.EventType));
        await foreach (var i in events)
            yield return ((T)i.Item1, i.Item2);
    }
    public async IAsyncEnumerable<object> Read(string streamId, TypeEventConverter converter,
        StreamPosition? start = null, Direction? direction = null, long maxCount = long.MaxValue,[EnumeratorCancellation] CancellationToken token = default)
    {
        var d = direction ?? Direction.Forwards;
        var p = start ?? StreamPosition.Start;

        var items = Client.ReadStreamAsync(d, streamId, p, resolveLinkTos: true, maxCount: maxCount, cancellationToken: token);
        if (await items.ReadState == ReadState.StreamNotFound) yield break;

        var events = items.Select(x => new
                { ResolvedEvent = x, EventType = converter(x.Event.EventType, out var t) ? t : null })
            .Where(x => x.EventType != null)
            .Select(ev => Serializer(ev.EventType).Deserialize(ev.ResolvedEvent.Event.Data.Span, ev.EventType!));
        await foreach (var i in events)
            yield return i;
    }

    public async Task<TOwner> Get<TOwner>(object id, CancellationToken token = default)
        where TOwner : IAggregate<TOwner>, ITypeRegister, IId
    {
        var sp = StreamPosition.Start;
        var aggregate = TOwner.Empty(id);
        if (GetPolicy<TOwner>() != null && aggregate is IStatefull i)
        {
            var snapshot = await GetSnapshot(id, i.SnapshotType, token);
            if (snapshot != null)
            {
                i.Initialize(snapshot.Value, new StateInfo(snapshot.Version, snapshot.Created));
                sp = StreamPosition.FromInt64(snapshot.Version + 1);
            }
        }

        await aggregate.Rehydrate(Read<TOwner>(id, sp, token: token));
        return aggregate;
    }

    

    public async Task<IWriteResult> AppendEvents(string streamId, StreamRevision rev, IEnumerable<object> events,
        object? metadata = null, CancellationToken token = default)
    {
        var evData = MakeEvents(events, metadata);

        return await Client.AppendToStreamAsync(streamId, rev, evData, cancellationToken: token);
    }

    public async Task<IWriteResult> AppendEvents(string streamId, StreamState state, IEnumerable<object> events,
        object? metadata = null, CancellationToken token = default)
    {
        var evData = MakeEvents(events, metadata);

        var r = await Client.AppendToStreamAsync(streamId, state, evData, cancellationToken: token);
        return r;
    }

    public Task<IWriteResult> AppendState<T>(T state, CancellationToken token = default) => 
        AppendState(state, IdDuckTyping.Instance.GetId(state), _versionTyping.GetVersion(state), token);

    
    public async Task<IWriteResult> AppendState(object state, object id, long? version, CancellationToken token = default) 
    {
        var m = Conventions.GetMetadata(null, state, null);
        var stateType = state.GetType();
        var streamId = Conventions.GetStreamIdStateConvention(stateType, id);
        var evId = Conventions.GetEventIdStateConvention(state, id, version);
        var evData = MakeEvent(evId, Conventions.SnapshotEventNameConvention(stateType), state, m);
        var ret = (version == null || version < 0) ? 
            await Client.AppendToStreamAsync(streamId, version == -1 ? StreamState.NoStream : StreamState.Any, [evData], cancellationToken: token) : 
            await Client.AppendToStreamAsync(streamId, StreamRevision.FromInt64(version.Value), [evData], cancellationToken: token);
        _versionTyping.SetVersion(state, (version??-1) + 1);
        return ret;
    }
    public async Task<IWriteResult> AppendSnapshot(object snapshot, object id, long version, StreamState? state = null, CancellationToken token = default)
    {
        var m = Conventions.GetMetadata(null, snapshot, new { SnapshotVersion = version });
        var stateType = snapshot.GetType();
        var streamId = Conventions.GetStreamIdSnapshotConvention(stateType, id);
        var evId = Conventions.GetEventIdConvention(null, snapshot);
        var evData = MakeEvent(evId, Conventions.SnapshotEventNameConvention(stateType), snapshot, m);

        return await Client.AppendToStreamAsync(streamId, state ?? StreamState.Any, [evData], cancellationToken:token);
        
    }

    /// <summary>
    /// Appends metadata to a stream derived from the specified event type and identifier.
    /// </summary>
    /// <typeparam name="TEvent">The type of the event associated with the stream.</typeparam>
    /// <param name="id">The identifier of the event, used to derive the stream name.</param>
    /// <param name="state">The optional state of the stream (e.g., existing or new).</param>
    /// <param name="maxAge">The optional maximum age for events in the stream.</param>
    /// <param name="truncateBefore">The optional position before which events should be truncated.</param>
    /// <param name="cacheControl">The optional cache control duration for the stream.</param>
    /// <param name="acl">The optional access control list for the stream.</param>
    /// <param name="maxCount">The optional maximum number of events allowed in the stream.</param>
    /// <returns>A task that represents the asynchronous operation, containing the result of the write operation.</returns>
    /// <remarks>
    /// The stream name is derived using the <see cref="IReadOnlyConventions.StreamNameFromEventConvention"/> convention.
    /// </remarks>
    public async Task<IWriteResult> AppendStreamMetadataFromEvent<TEvent>(
        object id,
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null)
    {
        var streamId = Conventions.StreamNameFromEventConvention(typeof(TEvent), id);
        // Create StreamMetadata with the provided arguments
        return await AppendStreamMetadata(streamId, state, maxAge, truncateBefore, cacheControl, acl, maxCount);
    }
    /// <summary>
    /// Appends metadata to a stream based on the specified handler type.
    /// </summary>
    /// <typeparam name="THandler">
    /// The type of the handler that determines the stream for which metadata will be appended.
    /// </typeparam>
    /// <param name="state">
    /// The <see cref="StreamState"/> indicating the expected state of the stream. 
    /// If <c>null</c>, the operation will not check the stream's state.
    /// </param>
    /// <param name="maxAge">
    /// The maximum age of events in the stream. Events older than this value will be removed.
    /// </param>
    /// <param name="truncateBefore">
    /// The <see cref="StreamPosition"/> before which events will be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The duration for which the stream metadata can be cached.
    /// </param>
    /// <param name="acl">
    /// The access control list (<see cref="StreamAcl"/>) specifying permissions for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The maximum number of events allowed in the stream. Events exceeding this count will be removed.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains an <see cref="IWriteResult"/> 
    /// indicating the outcome of the operation.
    /// </returns>
    public async Task<IWriteResult> AppendStreamMetadataFromHandler<THandler>(
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null)
    {
        var streamId = Conventions.OutputStreamModelConvention(typeof(THandler));
        // Create StreamMetadata with the provided arguments
        return await AppendStreamMetadata(streamId, state, maxAge, truncateBefore, cacheControl, acl, maxCount);
    }
    /// <summary>
    /// Appends metadata to a stream associated with a specified aggregate type and identifier.
    /// </summary>
    /// <typeparam name="TAggregate">
    /// The type of the aggregate associated with the stream.
    /// </typeparam>
    /// <param name="id">
    /// The identifier of the aggregate.
    /// </param>
    /// <param name="state">
    /// The optional state of the stream, such as <see cref="StreamState"/>.
    /// </param>
    /// <param name="maxAge">
    /// The optional maximum age for events in the stream.
    /// </param>
    /// <param name="truncateBefore">
    /// The optional position before which events in the stream should be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The optional cache control duration for the stream.
    /// </param>
    /// <param name="acl">
    /// The optional access control list (ACL) for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The optional maximum number of events allowed in the stream.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains an <see cref="IWriteResult"/> 
    /// indicating the outcome of the operation.
    /// </returns>
    /// <remarks>
    /// This method uses the conventions defined in <see cref="IReadOnlyConventions"/> to determine the stream ID 
    /// based on the aggregate type and identifier.
    /// </remarks>
    public async Task<IWriteResult> AppendStreamMetadataFromAggregate<TAggregate>(
        object id,
        StreamState? state = null,
        TimeSpan? maxAge = null,
        StreamPosition? truncateBefore = null,
        TimeSpan? cacheControl = null,
        StreamAcl? acl = null,
        int? maxCount = null)
    {
        var streamId = Conventions.GetStreamIdConvention(typeof(TAggregate), id);
        // Create StreamMetadata with the provided arguments
        return await AppendStreamMetadata(streamId, state, maxAge, truncateBefore, cacheControl, acl, maxCount);
    }
    /// <summary>
    /// Appends metadata to a specified stream in the EventStore.
    /// </summary>
    /// <param name="streamId">The identifier of the stream to which metadata will be appended.</param>
    /// <param name="state">
    /// The expected state of the stream. If <c>null</c>, defaults to <see cref="StreamState.Any"/>.
    /// </param>
    /// <param name="maxAge">
    /// The maximum age of events in the stream. Events older than this value will be removed.
    /// </param>
    /// <param name="truncateBefore">
    /// The position in the stream before which events will be truncated.
    /// </param>
    /// <param name="cacheControl">
    /// The duration for which the stream metadata can be cached.
    /// </param>
    /// <param name="acl">
    /// The access control list (ACL) defining permissions for the stream.
    /// </param>
    /// <param name="maxCount">
    /// The maximum number of events allowed in the stream. Events exceeding this count will be removed.
    /// </param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains the write result of the operation.
    /// </returns>
    public async Task<IWriteResult> AppendStreamMetadata(string streamId, StreamState? state, TimeSpan? maxAge, StreamPosition? truncateBefore,
        TimeSpan? cacheControl, StreamAcl? acl, int? maxCount)
    {
        var metadata = new StreamMetadata(
            maxAge: maxAge,
            truncateBefore: truncateBefore,
            cacheControl: cacheControl,
            acl: acl,
            maxCount: maxCount
        );
        // Set the stream metadata
        return await Client.SetStreamMetadataAsync(streamId, state ?? StreamState.Any, metadata);
    }
    /// <summary>
    /// Appends an event to a stream in the Event Store.
    /// </summary>
    /// <param name="evt">The event to append. Cannot be <c>null</c>.</param>
    /// <param name="id">The optional identifier for the stream. If not provided, conventions will be used to determine the stream name.</param>
    /// <param name="metadata">Optional metadata associated with the event.</param>
    /// <param name="state">
    /// The expected state of the stream. Defaults to <see cref="StreamState.Any"/> if not specified.
    /// </param>
    /// <param name="evtName">
    /// The name of the event. If not provided, conventions will be used to determine the event name.
    /// </param>
    /// <param name="token">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>
    /// A task that represents the asynchronous operation. The task result contains an <see cref="IWriteResult"/> 
    /// indicating the result of the append operation.
    /// </returns>
    /// <exception cref="ArgumentException">Thrown when <paramref name="evt"/> is <c>null</c>.</exception>
    public async Task<IWriteResult> AppendEvent(object evt, object? id=null, object? metadata = null, StreamState? state=null, string? evtName=null, CancellationToken token = default)
    {
        if (evt == null) throw new ArgumentException("evt cannot be null.");
        

        evtName ??= Conventions.GetEventNameConvention(null, evt.GetType());
        var m = Conventions.GetMetadata(null, evt, metadata);
        var st = state ?? StreamState.Any;
        var streamId = Conventions.StreamNameFromEventConvention(evt.GetType(), id);
        var evId = Conventions.GetEventIdConvention(null, evt);
        var evData = MakeEvent(evId, evtName, evt, m);

        var r = await Client.AppendToStreamAsync(streamId, st, [evData], cancellationToken:token);
        return r;
    }
    public async Task<IWriteResult> AppendEventToStream(string streamId, object evt, StreamState? state = null, string? evtName = null,
        object? metadata = null, CancellationToken token = default)
    {
        if (string.IsNullOrEmpty(streamId)) throw new ArgumentException("steamId cannot be null or empty.");
        if (evt == null) throw new ArgumentException("Event cannot be null");

        StreamState st = state ?? StreamState.Any;
        var eventName = evtName ?? Conventions.GetEventNameConvention(null, evt.GetType());
        var m = Conventions.GetMetadata(null, evt, metadata);
        var evId = Conventions.GetEventIdConvention(null, evt);
        var evData = MakeEvent(evId, eventName, evt, m);

        var r = await Client.AppendToStreamAsync(streamId, st, [evData], cancellationToken: token);
        return r;
    }

    
    
    public async Task<IWriteResult> SaveChanges<T>(T aggregate, object? metadata = null, CancellationToken token = default)
        where T : IAggregate<T>, IId
    {
        if (aggregate == null) throw new ArgumentNullException("aggregate cannot be null.");

        var streamId = Conventions.GetStreamIdConvention(typeof(T), aggregate.Id);
        var evData = MakeEvents(aggregate.PendingEvents, metadata, aggregate);
        var r = await Client.AppendToStreamAsync(streamId, StreamRevision.FromInt64(aggregate.Version), evData, cancellationToken: token);
        aggregate.AckCommitted();

        var policy = GetPolicy<T>();
        if (policy != null && aggregate is IStatefull i && policy.ShouldMakeSnapshot(aggregate, i.InitializedWith))
            await AppendSnapshot(i.State, aggregate.Id, aggregate.Version, StreamState.Any, token);

        return r;
    }


    public async Task<IWriteResult> SaveNew<T>(T aggregate, object? metadata = null, CancellationToken token = default)
        where T : IAggregate<T>, IId
    {
        if (aggregate == null) throw new ArgumentNullException("aggregate cannot be null.");

        var streamId = Conventions.GetStreamIdConvention(typeof(T), aggregate.Id);
        var evData = MakeEvents(aggregate.PendingEvents, metadata, aggregate);
        var r = await Client.AppendToStreamAsync(streamId, StreamState.NoStream, evData, cancellationToken: token);
        aggregate.AckCommitted();

        var policy = GetPolicy<T>();
        if (policy != null && aggregate is IStatefull i && policy.ShouldMakeSnapshot(aggregate, i.InitializedWith))
            await AppendSnapshot(i.State, aggregate.Id, aggregate.Version, StreamState.NoStream, token);

        return r;
    }
    

    public async Task<SubscriptionRunnerState<T>?> GetState<T>(object id, string? streamId = null, CancellationToken token = default) where T:class
    {
        var streamType = typeof(T);
        streamId ??= Conventions.GetStreamIdStateConvention(streamType, id);
        var c = new SingleTypeConverter(streamType);
        var e = await ReadFull(streamId, c.Convert, StreamPosition.End, Direction.Backwards, 1, token).ToArrayAsync();
        if (!e.Any()) return null;
        
        //TODO: DuckTyping
        var (evt, m) = e[0];
        _versionTyping.SetVersion(evt, m.SourceStreamPosition);
        IdDuckTyping.Instance.SetId(evt, id);
        return new SubscriptionRunnerState<T>((T)evt, m);
    }

   

    public async Task<Snapshot?> GetSnapshot(object id, Type snapshotType, CancellationToken token = default)
    {
        if (snapshotType == null) throw new ArgumentNullException("snapshotType cannot be null.");

        var streamId = Conventions.GetStreamIdSnapshotConvention(snapshotType, id);
        var c = new SingleTypeConverter(snapshotType);
        var e = await ReadFull(streamId, c.Convert, StreamPosition.End, Direction.Backwards, 1, token).ToArrayAsync();
        if (!e.Any()) return null;

        var (evt, m) = e[0];
        var s = (Snapshot)Activator.CreateInstance(typeof(Snapshot<>).MakeGenericType(snapshotType));
        s.Created = m.Created().Value;
        s.Value = evt;
        s.Version = m.SnapshotVersion() ?? 0;
        return s;
    }

    public async Task<Snapshot<T>?> GetSnapshot<T>(Guid id, CancellationToken token = default)
    {
        var s = await GetSnapshot(id, typeof(T), token);
        return (Snapshot<T>)s;
    }

    /// <summary>
    ///     Appends a link to the stream based on metadata loaded from somewhere else.
    /// </summary>
    /// <param name="streamId">Full name of the stream.</param>
    /// <param name="metadata">Event's metadata that link will point to.</param>
    /// <param name="state">StreamState, default is Any</param>
    /// <param name="token"></param>
    /// <returns></returns>
    public async Task<IWriteResult> AppendLink(string streamId, Metadata metadata, StreamState? state = null, CancellationToken token = default)
    {
        if (string.IsNullOrEmpty(streamId)) throw new ArgumentException("steamId cannot be null or empty.");

        var data = Encoding.UTF8.GetBytes($"{metadata.SourceStreamPosition}@{metadata.SourceStreamId}");
        const string eventType = "$>";

        return await Client.AppendToStreamAsync(streamId, state ?? StreamState.Any,
            new[] { new EventData(Uuid.NewUuid(), eventType, data) }, cancellationToken: token);
    }
    /// <summary>
    /// Appends the link.
    /// </summary>
    /// <param name="streamId">The stream identifier.</param>
    /// <param name="streamPosition">Stream position in original stream</param>
    /// <param name="streamSourceId">The stream source identifier.</param>
    /// <param name="state">Optional expected stream state.</param>
    /// <returns></returns>
    public async Task<IWriteResult> AppendLink(string streamId, ulong streamPosition, string streamSourceId,
            StreamState? state = null, CancellationToken token = default)
    {
        if (string.IsNullOrEmpty(streamId)) throw new ArgumentException("steamId cannot be null or empty.");
        if (string.IsNullOrEmpty(streamSourceId)) throw new ArgumentException("StreamSourceId is required.");

        var data = Encoding.UTF8.GetBytes($"{streamPosition}@{streamSourceId}");
        const string eventType = "$>";

        return await Client.AppendToStreamAsync(streamId, state ?? StreamState.Any,
            new[] { new EventData(Uuid.NewUuid(), eventType, data) }, cancellationToken:token);
    }


    private ISnapshotPolicy? GetPolicy<TOwner>()
    {
        return _policies.GetOrAdd(typeof(TOwner), x => Conventions.SnapshotPolicyFactoryConvention(x));
    }

    public T GetExtension<T>() where T : new()
    {
        return (T)_extension.GetOrAdd(typeof(T), x => new T());
    }

    private IObjectSerializer Serializer(Type t)
    {
        return _serializers.GetOrAdd(t, SerializerFactory);
    }

    /// <summary>
    ///     Creates instance of IPlumber.
    /// </summary>
    /// <param name="settings">Connection settings to EventStore</param>
    /// <param name="configure">Additional configuration</param>
    /// <returns></returns>
    public static IPlumber Create(EventStoreClientSettings? settings = null, Action<IPlumberConfig>? configure = null)
    {
        settings ??=
            EventStoreClientSettings.Create("esdb://admin:changeit@localhost:2113?tls=false&tlsVerifyCert=false");
        var cfg = new PlumberConfig();
        configure?.Invoke(cfg);

        return new Plumber(settings, cfg);
    }

    /// <summary>
    ///     This method is called only from subscriptions.
    /// </summary>
    /// <param name="er"></param>
    /// <param name="eLink"></param>
    /// <param name="t"></param>
    /// <returns></returns>
    internal (object, Metadata) ReadEventData(EventRecord er, EventRecord? eLink, Type t)
    {
        var streamIdSuffix = er.EventStreamId.Substring(er.EventStreamId.IndexOf('-') + 1);
        if (!Guid.TryParse(streamIdSuffix, out var aggregateId)) 
            aggregateId = streamIdSuffix.ToGuid();

        var s = Serializer(t);
        var ev = s.Deserialize(er.Data.Span, t)!;
        var m = s.ParseMetadata(er.Metadata.Span);

        long? linkStreamPosition = eLink?.EventNumber.ToInt64();
        long sourceStreamPosition = er.EventNumber.ToInt64();
        
        var metadata = new Metadata(aggregateId, er.EventId.ToGuid(), sourceStreamPosition, linkStreamPosition, er.EventStreamId, m);
        return (ev, metadata);
    }

    private IEnumerable<EventData> MakeEvents(IEnumerable<object> events, object? metadata, IAggregate? agg = null)
    {
        var evData = events.Select(x =>
        {
            var m = Conventions.GetMetadata(agg, x, metadata);
            var evName = Conventions.GetEventNameConvention(agg?.GetType(), x.GetType());
            var evId = Conventions.GetEventIdConvention(agg, x);
            return MakeEvent(evId, evName, x, m);
        });
        return evData;
    }

    private EventData MakeEvent(Uuid evId, string evName, object data, object m)
    {
        var s = Serializer(data.GetType());
        return new EventData(evId, evName, s.Serialize(data), s.Serialize(m), s.ContentType);
    }
}


// --- File: MicroPlumberd\PlumberConfig.cs ---


using System.Collections.Concurrent;
using System.Reflection;

using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd;

class PlumberConfig : IPlumberConfig
{
    internal readonly ConcurrentDictionary<Type, object> Extension = new();
    public T GetExtension<T>() where T : new() => (T)Extension.GetOrAdd(typeof(T), x => new T());

    private IServiceProvider _serviceProvider = new ActivatorServiceProvider();
    private static readonly JsonObjectSerializer serializer = new JsonObjectSerializer();
    private Func<Type,IObjectSerializer> _serializerFactory = x => serializer;
    private Func<Exception, string, CancellationToken, Task<ErrorHandleDecision>> _errorHandlePolicy = OnError;

    public Func<Type,IObjectSerializer> SerializerFactory
    {
        get => _serializerFactory;
        set
        {
            if(value == null!) throw new ArgumentNullException("ObjectSerializer cannot be null.");
            _serializerFactory = value;
        }
    }

    public Conventions Conventions { get; } = new Conventions();
    IConventions IPlumberConfig.Conventions => this.Conventions;

    public PlumberConfig()
    {
        Conventions.SnapshotPolicyFactoryConvention = OnSnapshotPolicy;
    }

    private ISnapshotPolicy? OnSnapshotPolicy(Type ownerType)
    {
        var t = ownerType.GetCustomAttribute<AggregateAttribute>()?.SnaphotPolicy;
        if (t != null)
        {
            if (t.IsGenericTypeDefinition) t = t.MakeGenericType(ownerType);
            return (ISnapshotPolicy)ServiceProvider.GetRequiredService(t);
        }
        return null;
    }

    public IServiceProvider ServiceProvider
    {
        get => _serviceProvider;
        set
        {
            if (value == null!) throw new ArgumentNullException("ServiceProvider cannot be null.");
            _serviceProvider = value;
        }
    }

    internal Func<Exception, string, CancellationToken, Task<ErrorHandleDecision>> ErrorHandlePolicy
    {
        get => _errorHandlePolicy;
    }

    public event Action<IPlumber>? Created;
    public void SetErrorHandlePolicy(Func<Exception, string, CancellationToken, Task<ErrorHandleDecision>> value)
    {
        if (value == null!) throw new ArgumentNullException();
        _errorHandlePolicy = value;
    }

    public event Action<IServiceCollection>? Configured;

    private static async Task<ErrorHandleDecision> OnError(Exception ex, string stream, CancellationToken token)
    {
        await Task.Delay(30000, token);
        return ErrorHandleDecision.Retry;
    }
    
    internal void OnConfigured(IServiceCollection collection)
    {
        Configured?.Invoke(collection);
    }
    internal void OnCreated(Plumber plumber)
    {
        Created?.Invoke(plumber);
    }

    
}


// --- File: MicroPlumberd\ProjectionRegister.cs ---


using EventStore.Client;
using Grpc.Core;

namespace MicroPlumberd;

public interface IProjectionRegister
{
    Task<ProjectionDetails?> Get(string name);
}

static class Executor
{
    public static async Task<TResult> Retry<TException, TResult>(Func<Task<TResult>> action, int count = 3, int delay=100) where TException:Exception
    {
        TException last = null!;
        for(int i = 0; i < count; i++)
        try
        {
            return await action();
        }
        catch (TException e)
        {
            last = e;
            await Task.Delay(delay);
        }

        throw last!;
    }
}
class ProjectionRegister : IProjectionRegister
{
    private readonly AsyncLazy<Dictionary<string, ProjectionDetails>> _lazyLoader;
    private readonly EventStoreProjectionManagementClient _client;

    public ProjectionRegister(EventStoreProjectionManagementClient client)
    {
        _client = client;
        _lazyLoader = new AsyncLazy<Dictionary<string, ProjectionDetails>>(async () =>
        {
            return await Executor.Retry<RpcException,Dictionary<string, ProjectionDetails>>(async () =>
                await _client.ListContinuousAsync().ToDictionaryAsync(x => x.Name).AsTask(), delay:500);
        });
    }


    public async Task<ProjectionDetails?> Get(string name)
    {
        return (await _lazyLoader.Value).TryGetValue(name, out var v) ? v : null;
    }
}


// --- File: MicroPlumberd\StreamPosition.cs ---


using EventStore.Client;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

namespace MicroPlumberd;

/// <summary>
/// Represents a position in a specific event stream
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<StreamVersion>))]
public readonly record struct StreamVersion : IParsable<StreamVersion>, IComparable<StreamVersion>
{
    public string StreamName { get; }
    public long Version { get; }

    public StreamVersion(string streamName, long version)
    {
        if (string.IsNullOrWhiteSpace(streamName))
            throw new ArgumentException("Stream name cannot be empty", nameof(streamName));

        if (version < -1)
            throw new ArgumentException("Version cannot be less than -1", nameof(version));

        StreamName = streamName;
        Version = version;
    }

    public StreamVersion With(Metadata metadata)
    {
        
        return new StreamVersion(
            StreamName,
            metadata.SourceStreamPosition);
    }

    public override string ToString() => $"{StreamName}:{Version}";

    public static StreamVersion Parse(string s, IFormatProvider? provider = null)
    {
        if (string.IsNullOrWhiteSpace(s))
            throw new ArgumentException("Input string cannot be empty", nameof(s));

        var parts = s.Split(':');
        if (parts.Length != 2)
            throw new FormatException("Stream position must be in format 'streamName:version'");

        if (!long.TryParse(parts[1], out var version))
            throw new FormatException("Version must be a valid long integer");

        return new StreamVersion(parts[0], version);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out StreamVersion result)
    {
        result = default;

        if (string.IsNullOrWhiteSpace(s))
            return false;

        var parts = s.Split(':');
        if (parts.Length != 2)
            return false;

        if (!long.TryParse(parts[1], out var version))
            return false;

        result = new StreamVersion(parts[0], version);
        return true;
    }

    public int CompareTo(StreamVersion other)
    {
        var streamNameComparison = string.Compare(StreamName, other.StreamName, StringComparison.Ordinal);
        if (streamNameComparison != 0)
            return streamNameComparison;

        return Version.CompareTo(other.Version);
    }
}
/// <summary>
/// Represents a composite version of multiple event streams
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<CompositeStreamVersion>))]
public readonly record struct CompositeStreamVersion : IParsable<CompositeStreamVersion>, IEquatable<CompositeStreamVersion>
{
    public ImmutableSortedDictionary<string, long> Positions { get; private init; }
    
    public CompositeStreamVersion(IEnumerable<StreamVersion> positions)
    {
        Positions = positions?.ToImmutableSortedDictionary(x=>x.StreamName, x=>x.Version) ?? ImmutableSortedDictionary<string,long>.Empty;
    }

    public bool Equals(CompositeStreamVersion? other)
    {
        if (other == null) return false;
        return Positions.SequenceEqual(other.Value.Positions);
    }

    /// <summary>
    /// Creates an empty composite version
    /// </summary>
    public static CompositeStreamVersion Empty => new(ImmutableSortedSet<StreamVersion>.Empty);

    /// <summary>
    /// Gets the version for a specific stream
    /// </summary>
    public long GetVersionFor(string streamName) => Positions[streamName];

    /// <summary>
    /// Creates a new composite version with the specified stream position updated
    /// </summary>
    public CompositeStreamVersion WithPosition(StreamVersion position)
    {
        if (Positions.ContainsKey(position.StreamName))
        {
            var updatedPositions = Positions.SetItem(position.StreamName, position.Version);
            return new CompositeStreamVersion() { Positions = updatedPositions };
        }
        else
            return new CompositeStreamVersion() { Positions = Positions.Add(position.StreamName, position.Version) };

    }

    public override string ToString() => Positions.IsEmpty ? string.Empty : string.Join('.', this.Positions.Select(x=> new StreamVersion(x.Key, x.Value)));

    public static CompositeStreamVersion Parse(string s, IFormatProvider? provider = null)
    {
        if (string.IsNullOrWhiteSpace(s))
            return Empty;

        var parts = s.Split('.');
        var positions = new List<StreamVersion>();

        foreach (var part in parts)
        {
            if (string.IsNullOrWhiteSpace(part))
                continue;

            positions.Add(StreamVersion.Parse(part, provider));
        }

        return new CompositeStreamVersion(positions);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out CompositeStreamVersion result)
    {
        result = Empty;

        if (string.IsNullOrWhiteSpace(s))
            return true; // Empty string is a valid empty composite version

        var parts = s.Split('.');
        var positions = new List<StreamVersion>();

        foreach (var part in parts)
        {
            if (string.IsNullOrWhiteSpace(part))
                continue;

            if (!StreamVersion.TryParse(part, provider, out var position))
                return false;

            positions.Add(position);
        }

        result = new CompositeStreamVersion(positions);
        return true;
    }
}
/// <summary>
/// Extension methods for working with CompositeStreamVersion
/// </summary>
public static class CompositeStreamVersionExtensions
{
    /// <summary>
    /// Updates a composite version with the metadata from an event
    /// </summary>
    /// <typeparam name="TEvent">The type of event</typeparam>
    /// <param name="CompositeStreamVersion">The current composite version</param>
    /// <param name="metadata">The metadata from the event</param>
    /// <param name="plumber">The plumber instance to access conventions</param>
    /// <returns>An updated composite version</returns>
    public static CompositeStreamVersion With<TEvent>(
        this CompositeStreamVersion CompositeStreamVersion,
        Metadata metadata,
        IPlumber plumber)
    {
        
        if (plumber == null)
            throw new ArgumentNullException(nameof(plumber));

        // Get stream name from metadata or determine from event type if not present
        string streamName = plumber.Config.Conventions.GetEventNameConvention(null, typeof(TEvent));

        // Create stream position with the stream name and version from metadata
        var position = new StreamVersion(streamName, metadata.SourceStreamPosition);

        // Update the composite version with the new position
        return CompositeStreamVersion.WithPosition(position);
    }

    
}


// --- File: MicroPlumberd\SubscriptionRunner.cs ---


using EventStore.Client;
using Microsoft.Extensions.DependencyInjection;
using System.Threading;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd;


record SubscriptionRunnerState : IDisposable
{
    private IDisposable? _subscription;

    public SubscriptionRunnerState(FromStream initialPosition, EventStoreClient client, string streamName, UserCredentials? userCredentials, CancellationToken cancellationToken)
    {
        _initialPosition = initialPosition;
        _client = client;
        this.StreamName = streamName;
        this.UserCredentials = userCredentials;
        this.CancellationToken = cancellationToken;
        Position = initialPosition;
    }

    public EventStoreClient.StreamSubscriptionResult Subscribe()
    {
        var result = _client.SubscribeToStream(StreamName, Position, true, UserCredentials, CancellationToken);
        _subscription = result;
        return result;
    }
    public FromStream Position { get; set; }
    public IEventHandler Handler { get; set; }
    private readonly FromStream _initialPosition;
    private readonly EventStoreClient _client;
    public string StreamName { get; init; }
    public UserCredentials? UserCredentials { get; init; }
    public CancellationToken CancellationToken { get; init; }

    public void Dispose()
    {
        _subscription?.Dispose();
    }

   
};
class SubscriptionSeeker(Plumber plumber, string streamName, FromRelativeStreamPosition start,
    UserCredentials? userCredentials = null, CancellationToken cancellationToken = default) : ISubscriptionRunner
{
    private SubscriptionRunner? _runner;

    
    private async Task<SubscriptionRunnerState> Subscribe()
    {
        StreamPosition sp = StreamPosition.Start;
        FromStream subscriptionStart = FromStream.Start;

        if (start.StartPosition == FromStream.End)
        {
            sp = StreamPosition.End;
            subscriptionStart = FromStream.End;
        }
        else if (start.StartPosition != FromStream.Start)
            sp = start.StartPosition.ToUInt64();

        var records = plumber.Client.ReadStreamAsync(start.Direction, streamName, sp, 1, 
            cancellationToken:cancellationToken);
        StreamPosition dstPosition;
        if (await records.ReadState == ReadState.StreamNotFound)
            return new (subscriptionStart,plumber.Client,streamName, userCredentials,  cancellationToken);

        var record = await records.FirstAsync();
        if (start.Direction == Direction.Forwards)
        {
            dstPosition = record.Event.EventNumber + start.Count;
            subscriptionStart = FromStream.After(dstPosition);
        }
        else
        {
            ulong en = record.OriginalEventNumber.ToUInt64();
            if (en >= start.Count)
            {
                dstPosition = record.Event.EventNumber - start.Count;
                subscriptionStart = FromStream.After(dstPosition);
            }
            else subscriptionStart = FromStream.Start;
        }

        return new(subscriptionStart, plumber.Client, streamName, userCredentials, cancellationToken);
    }
    public async Task<T> WithHandler<T>(T model)
        where T : IEventHandler, ITypeRegister
    {
        return await WithHandler<T>(model, plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());
    }

    public async Task<T> WithHandler<T>(T model, TypeEventConverter func)
        where T : IEventHandler
    {
        return (T)await WithHandler((IEventHandler)model, func);
    }
    public async Task<IEventHandler> WithHandler(IEventHandler model, TypeEventConverter func)
    {
        _runner = new SubscriptionRunner(plumber, await Subscribe());
        await _runner.WithHandler(model, func);
        
        return model;
    }

    public async Task<IEventHandler> WithHandler<T>(TypeEventConverter func) where T : IEventHandler
    {
        var handler = plumber.ServiceProvider.GetService<IEventHandler<T>>() ?? (IEventHandler)plumber.ServiceProvider.GetRequiredService<T>();
        return (IEventHandler)await WithHandler(handler, func);
    }
    public async Task<IEventHandler> WithHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithHandler<T>(ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithHandler<T>(T model, ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model, register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>(T model) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model, new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());

    public async ValueTask DisposeAsync() => await _runner.DisposeAsync();
}
class SubscriptionRunner(Plumber plumber, SubscriptionRunnerState subscription) : ISubscriptionRunner
{
    public async Task<T> WithHandler<T>(T model)
        where T : IEventHandler, ITypeRegister
    {
        return await WithHandler<T>(model, plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());
    }

    public async Task<T> WithHandler<T>(T model, TypeEventConverter func)
        where T : IEventHandler
    {
        return (T)await WithHandler((IEventHandler)model, func);
    }
    
    public async Task<IEventHandler> WithHandler(IEventHandler model, TypeEventConverter func)
    {
        subscription.Handler = model;
        await Task.Factory.StartNew(async (_) =>
        {
            var l = plumber.Config.ServiceProvider.GetService<ILogger<SubscriptionRunner>>();
            while (!subscription.CancellationToken.IsCancellationRequested)
            {
                try
                {
                    await using var sub = subscription.Subscribe();
                    await foreach (var m in sub.Messages)
                    {
                        switch (m)
                        {
                            case StreamMessage.Event(var e):
                                await OnEvent(func, e, model);
                                subscription.Position = FromStream.After(e.OriginalEventNumber);
                                break;
                            case StreamMessage.CaughtUp:
                                if (model is ICaughtUpHandler cuh) await cuh.CaughtUp();
                                break;
                            default: break;

                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    l?.LogDebug($"Subscription '{subscription.StreamName}' was canceled.");
                    return;
                }
                catch (ObjectDisposedException)
                {
                    l?.LogDebug($"Subscription '{subscription.StreamName}' was canceled.");
                    return;
                }
                catch (Exception ex)
                {
                    l?.LogWarning($"Subscription '{subscription.StreamName}' was dropped. Will retry in 5sec.");
                    await Task.Delay(5000, subscription.CancellationToken);
                }
            }
        }, subscription, TaskCreationOptions.LongRunning);
        return model;
    }

    private async Task OnEvent(TypeEventConverter func, ResolvedEvent e, IEventHandler model)
    {
        while(!subscription.CancellationToken.IsCancellationRequested)
        try
        {
            if (!func(e.Event.EventType, out var t)) return;

            var (ev, metadata) = plumber.ReadEventData(e.Event, e.Link,t);
            using var scope = new InvocationScope();
            plumber.Conventions.BuildInvocationContext(scope.Context, metadata);
            await model.Handle(metadata, ev);
            return;
        }
        catch (Exception ex)
        {
            var l = plumber.Config.ServiceProvider.GetService<ILogger<SubscriptionRunner>>();
            
            l?.LogError(ex, $"Subscription '{subscription.StreamName}' encountered unhandled exception. Most likely because of Given/Handle methods throwing exceptions. Retry in 30sec.");
            var decision = await
                plumber.Config.HandleError(ex, subscription.StreamName, subscription.CancellationToken);
            switch (decision)
            {
                case ErrorHandleDecision.Retry:
                    continue;
                case ErrorHandleDecision.Cancel:
                    throw new OperationCanceledException("Operation canceled by user.");
                case ErrorHandleDecision.Ignore:
                    return;
            }

            
        }
    }

    public async Task<IEventHandler> WithHandler<T>(TypeEventConverter func) where T : IEventHandler
    {
        var handler = plumber.ServiceProvider.GetService<IEventHandler<T>>() ?? (IEventHandler)plumber.ServiceProvider.GetRequiredService<T>();
        return (IEventHandler)await WithHandler(handler, func);
    }
    public async Task<IEventHandler> WithHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>());

    public async ValueTask DisposeAsync() => subscription.Dispose();

    public async Task<IEventHandler> WithHandler<T>(ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithHandler<T>(T model, ITypeHandlerRegisters register) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model, register.GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>() where T : IEventHandler, ITypeRegister => await WithHandler<T>(new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());
    public async Task<IEventHandler> WithSnapshotHandler<T>(T model) where T : IEventHandler, ITypeRegister => await WithHandler<T>(model, new TypeHandlerRegisters((ownerType, eventType) => plumber.Conventions.SnapshotEventNameConvention(eventType)).GetEventNameConverterFor<T>());

}




// --- File: MicroPlumberd\SubscriptionSet.cs ---


using EventStore.Client;

namespace MicroPlumberd;

class SubscriptionSet(Plumber plumber) : ISubscriptionSet
{
    private readonly Plumber plumber = plumber;
    private readonly Dictionary<string, Type> _register = new();
    private readonly Dictionary<string, List<IEventHandler>> _dispatcher = new();
    
    public ISubscriptionSet With<TModel>(TModel model)
        where TModel : IEventHandler, ITypeRegister
    {
        foreach(var i in plumber.TypeHandlerRegisters.GetEventNameMappingsFor<TModel>())
        {
            _register.TryAdd(i.Key, i.Value);
            if (!_dispatcher.TryGetValue(i.Key, out var disp)) 
                _dispatcher.Add(i.Key, disp=new List<IEventHandler>());
            if(!disp.Contains(model))
                disp.Add(model);
        }
        return this;
    }
    public async Task SubscribePersistentlyAsync(string outputStream, string? groupName = null)
    {
        groupName ??= outputStream;
        await plumber.ProjectionManagementClient.TryCreateJoinProjection(outputStream, _register.Keys);
        var subscription = plumber.PersistentSubscriptionClient.SubscribeToStream(outputStream, groupName);
        var state = Tuple.Create(this, subscription);

        await Task.Factory.StartNew(static async (x) =>
        {
            var (builder, sub) = (Tuple<SubscriptionSet, EventStorePersistentSubscriptionsClient.PersistentSubscriptionResult>)x!;
            var plumber = builder.plumber;
            await foreach (var e in sub)
            {
                var er = e.Event;
                if (!builder._dispatcher.TryGetValue(er.EventType, out var models)) continue;
                var t = builder._register[er.EventType];

                var (ev, metadata) = plumber.ReadEventData(er,e.Link, t);
               

                foreach (var i in models)
                    await i.Handle(metadata, ev);
                await sub.Ack(e.Event.EventId);
            }
        }, state, TaskCreationOptions.LongRunning);
    }

   

    public async Task SubscribeAsync(string name, FromStream start)
    {
        await plumber.ProjectionManagementClient.TryCreateJoinProjection(name, _register.Keys);
        
        EventStoreClient.StreamSubscriptionResult subscription = plumber.Client.SubscribeToStream(name, start, true);
        var state = Tuple.Create(this, subscription);
        
        await Task.Factory.StartNew(static async (x) =>
        {
            var (builder, sub) = (Tuple<SubscriptionSet, EventStoreClient.StreamSubscriptionResult>)x!;
            var plumber = builder.plumber;
            await foreach (var e in sub)
            {
                var er = e.Event;
                if (!builder._dispatcher.TryGetValue(er.EventType, out var models)) continue;
                var t = builder._register[er.EventType];

                var (ev, metadata) = plumber.ReadEventData(er,e.Link, t);
                foreach (var i in models) 
                    await i.Handle(metadata, ev);
            }
        }, state, TaskCreationOptions.LongRunning);
    }
}


// --- File: MicroPlumberd\TypeHandlerRegister.cs ---


using System.Collections.Concurrent;
using System.Collections.Frozen;

namespace MicroPlumberd;

sealed class TypeHandlerRegisters(EventNameConvention conventions) : ITypeHandlerRegisters
{
    private readonly ConcurrentDictionary<Type, FrozenDictionary<string, Type>> _index = new();

    public IEnumerable<Type> HandlerTypes => _index.Keys;
    public TypeEventConverter GetEventNameConverterFor<T>() where T:ITypeRegister => Get<T>().TryGetValue!;

    private FrozenDictionary<string, Type> Get<T>() where T:ITypeRegister
    {
        var ownerType = typeof(T);
        return _index.GetOrAdd(ownerType, x => T.Types.ToFrozenDictionary(x => conventions(ownerType, x)));
    }
    
    public IEnumerable<KeyValuePair<string, Type>> GetEventNameMappingsFor<T>() where T : ITypeRegister
    {
        return Get<T>();
    }

    public IEnumerable<string> GetEventNamesFor<T>() where T : ITypeRegister => Get<T>().Keys;
}


// --- File: MicroPlumberd.CommandBus.Abstractions\CommandFaultException.cs ---


namespace MicroPlumberd;

public class FaultException<TData> : FaultException
{
    public FaultException(string? message, TData data, int code) : base(message)
    {
        Data = data;
        Code = code;
    }

    public TData Data { get; init; }

    public override object GetFaultData() => (object)this.Data;

    public FaultException(TData data) => this.Data = data;
}
public class FaultException : Exception
{
    public int Code { get; init; }
    public FaultException()
    {
    }

    public static FaultException Create(string message, object data, int code)
    {
        return (FaultException)Activator.CreateInstance(typeof(FaultException<>).MakeGenericType(data.GetType()), message, data, code)!;
    }
    public FaultException(string? message) : base(message)
    {
    }
    public FaultException(string? message, int code) : base(message)
    {
        Code = code;
    }

    public virtual object GetFaultData() => null;
}


// --- File: MicroPlumberd.CommandBus.Abstractions\ICommandBus.cs ---


namespace MicroPlumberd;

/// <summary>
/// Represents a command bus for sending commands.
/// </summary>
public interface ICommandBus : IAsyncDisposable, IDisposable
{
    /// <summary>
    /// Sends a command synchronously to the specified recipient - command handler. It waits for the response.
    /// </summary>
    /// <param name="recipientId">The ID of the recipient.</param>
    /// <param name="command">The command to send.</param>
    /// <param name="token"></param>
    /// <returns>A task representing the asynchronous operation.</returns>
    Task SendAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = false, CancellationToken token = default);

    /// <summary>
    /// Queues a command async to be processed by the specified recipient - command handler, in another session. Timeout id be default disabled. the default is fire and forget.
    /// </summary>
    /// <param name="recipientId">The ID of the recipient to process the command.</param>
    /// <param name="command">The command to be queued for processing.</param>
    /// <param name="token">A <see cref="CancellationToken"/> to observe while waiting for the task to complete.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    /// <remarks>
    /// This method queues the command for later processing, ensuring it is sent to the appropriate recipient.
    /// </remarks>
    Task QueueAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = true,  CancellationToken token = default);
}


// --- File: MicroPlumberd.CommandBus.Abstractions\Internals.cs ---


using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("MicroPlumberd.Services")]


// --- File: MicroPlumberd.DirectConnect\CommandEnvelope.cs ---


using ProtoBuf;
using System.Net;

namespace MicroPlumberd.DirectConnect;

[ProtoContract]
public record CommandEnvelope<TCommand>
{
    private Guid? _id = null;

    public Guid CommandId
    {
        get
        {
            if (Command is IId i) return i.Uuid;
            return _id ??= Guid.NewGuid();
        }
    }

    [ProtoMember(1)]
    public string StreamId { get; init; }

    [ProtoMember(2)]
    public required TCommand Command { get; init; }

    [ProtoMember(3)]
    public Guid? CorrelationId { get; init; }
}
public static class FaultEnvelope
{
    public static object Create(object faultData, string message)
    {
        return Activator.CreateInstance(typeof(FaultEnvelope<>).MakeGenericType(faultData.GetType()), faultData,
            message)!;
    }
}

public interface IFaultEnvelope
{
    object Data { get; }
    string Error { get;}
    HttpStatusCode Code { get;  }
}

[ProtoContract]
public record FaultEnvelope<TData> : IFaultEnvelope
{
    public FaultEnvelope(TData data, string error)
    {
        Data = data;
        Error = error;
    }

    public FaultEnvelope()
    {
        
    }
    object IFaultEnvelope.Data => this.Data;

    [ProtoMember(1)]
    public required TData Data { get; init; }
    
    [ProtoMember(2)]
    public required string Error { get; init; }

    [ProtoMember(3)]
    public HttpStatusCode Code { get; init; }
}


// --- File: MicroPlumberd.DirectConnect\CommandHandlerCore.cs ---


using System.Net;
using EventStore.Client;
using MicroPlumberd.Services;
using Microsoft.Extensions.DependencyInjection;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.DirectConnect;

internal class CommandHandlerCore<TCommand>(IServiceProvider serviceProvider) : IRequestHandler<CommandEnvelope<TCommand>, object>
{
    public async Task<object> Handle(CommandEnvelope<TCommand> request)
    {
        await using var sp = serviceProvider.CreateAsyncScope();

        var ch = sp.ServiceProvider.GetRequiredService<ICommandHandler<TCommand>>();
        try
        {
            return await ch.Execute(request.StreamId, request.Command) ?? HandlerOperationStatus.Ok();
        }
        catch (FaultException ex)
        {
            var faultData = ex.GetFaultData();
            return FaultEnvelope.Create(faultData, ex.Message);
        }
        catch (Exception ex)
        {
            return new HandlerOperationStatus()
            {
                Code = HttpStatusCode.InternalServerError,
                Error = ex.Message
            };
        }
    }
}


// --- File: MicroPlumberd.DirectConnect\CommandHandlerCorrelationDecorator.cs ---


using System.Diagnostics;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.DirectConnect;

internal class CommandHandlerCorrelationDecorator<TCommand>(IRequestHandler<CommandEnvelope<TCommand>, object> next) 
    : IRequestHandler<CommandEnvelope<TCommand>, object>
    
{
    public async Task<object> Handle(CommandEnvelope<TCommand> request)
    {
        InvocationContext.Current.SetCorrelation(request.CorrelationId ?? request.CommandId);
        InvocationContext.Current.SetCausation(request.CommandId);
        //Debug.WriteLine($"===> Setting scope of causation id to: {request.CommandId}");
        return await next.Handle(request);
    }
}


// --- File: MicroPlumberd.DirectConnect\ContainerExtensions.cs ---


using System.Reflection;
using MicroPlumberd.Services;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.DirectConnect;

public static class ContainerExtensions
{

    public static IServiceCollection AddCommandInvoker<TCommand>(this IServiceCollection services) 
    {
        return services.AddCommandInvoker(typeof(TCommand));
    }
    
    public static IServiceCollection AddCommandInvokers(this IServiceCollection services, params Type[] commandTypes)
    {
        return services.AddCommandInvokers(commandTypes.AsEnumerable());
    }
    public static IServiceCollection AddCommandInvokers(this IServiceCollection services, IEnumerable<Type> commandTypes)
    {
        foreach (var c in commandTypes) services.AddCommandInvoker(c);
        return services;
    }
    public static IServiceCollection AddCommandInvoker(this IServiceCollection services, Type commandType) 
    {
        services.AddClientInvoker(typeof(CommandEnvelope<>).MakeGenericType(commandType), typeof(object));
        var returnTypes = commandType.GetCustomAttributes<ReturnsAttribute>().Select(x => x.ReturnType);
        var faultTypes = commandType.GetCustomAttributes<ThrowsFaultExceptionAttribute>()
            .Select(x => typeof(FaultEnvelope<>).MakeGenericType(x.ThrownType));
        services.AddMessages(returnTypes.Union(faultTypes).Union(Enumerable.Repeat(typeof(HandlerOperationStatus),1)));
        return services;
    }

    public static IServiceCollection AddCommandHandler<TCommandHandler>(this IServiceCollection services) where TCommandHandler:IServiceTypeRegister
    {
        foreach (var cmdType in TCommandHandler.CommandTypes)
        {
            services.AddRequestResponse(typeof(CommandEnvelope<>).MakeGenericType(cmdType), typeof(object));
            var cmdEvnType = typeof(CommandEnvelope<>).MakeGenericType(cmdType);

            var serviceType = typeof(IRequestHandler<,>).MakeGenericType(cmdEvnType, typeof(object));
            services.AddSingleton(serviceType, typeof(CommandHandlerCore<>).MakeGenericType(cmdType));
            services.Decorate(serviceType, typeof(CommandHandlerCorrelationDecorator<>).MakeGenericType(cmdType));
        }
            
        if (!services.TryGetSingleton<TypeRegister>(out var service))
            throw new InvalidOperationException();
        

        service!.Index(TCommandHandler.ReturnTypes)
            .Index(TCommandHandler.FaultTypes);

        TCommandHandler.RegisterHandlers(services);

        return services;
    }
}


// --- File: MicroPlumberd.DirectConnect\HandlerOperationStatus.cs ---


using System.Net;
using ProtoBuf;

namespace MicroPlumberd.DirectConnect;

[ProtoContract]
public class HandlerOperationStatus
{
    [ProtoMember(1)]
    public HttpStatusCode Code { get; init; }

    [ProtoMember(2)]
    public string Error { get; init; }

    public static HandlerOperationStatus Ok() => new HandlerOperationStatus() { Code = HttpStatusCode.OK };
    
}


// --- File: MicroPlumberd.DirectConnect\ICommand.cs ---


using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.DirectConnect;

[AttributeUsage(AttributeTargets.Class)]
public class ReturnsAttribute<TResult>() : ReturnsAttribute(typeof(TResult)) { }


// --- File: MicroPlumberd.DirectConnect\RequestInvokerExtensions.cs ---


using ModelingEvolution.DirectConnect;
using System.Collections.Concurrent;
using MicroPlumberd.DirectConnect;

namespace MicroPlumberd
{
    public static class RequestInvokerExtensions
    {
        interface IInvoke<TResponse> { Task<TResponse> Execute(IRequestInvoker invoker, string id, object cmd); }
        private sealed class Invoker<TRequest, TResponse> : IInvoke<TResponse>  where TResponse : class
        {
            public Task<TResponse> Execute(IRequestInvoker invoker, string id, object cmd) => RequestInvokerExtensions.OnExecute<TRequest, TResponse>(invoker, id, (TRequest)cmd);
        }
        private static async Task<TResponse> OnExecute<TRequest, TResponse>(IRequestInvoker invoker, string id, TRequest cmd)
            where TResponse : class
        {
            var result = await invoker.Invoke<CommandEnvelope<TRequest>, object>(new CommandEnvelope<TRequest>() { StreamId = id, Command = cmd });
            if(result is not IFaultEnvelope)
                return (TResponse)result;
            var fault = (IFaultEnvelope)result;
            if (fault.Data != null)
                throw FaultException.Create(fault.Error, fault.Data, (int)fault.Code);
            throw new FaultException(fault.Error, (int)fault.Code);
        }
        private static readonly ConcurrentDictionary<Type, object> _invokers = new();
        /// <summary>
        /// Executes a command and gets a response of type TResponse.
        /// </summary>
        /// <typeparam name="TResponse">The type of the response.</typeparam>
        /// <param name="ri">The IRequestInvoker instance on which this method is invoked.</param>
        /// <param name="id">The unique identifier for the command.</param>
        /// <param name="c">The command object.</param>
        /// <returns>A Task that represents the asynchronous operation. The task result contains the response of type TResponse.</returns>
        public static Task<TResponse> Execute<TResponse>(this IRequestInvoker ri, string id, object c)
        {
            var commandType = c.GetType();
            var invoker = (IInvoke<TResponse>)_invokers.GetOrAdd(commandType, x =>
            {
                var t = typeof(Invoker<,>).MakeGenericType(commandType, typeof(TResponse));
                return Activator.CreateInstance(t)!;
            });
            return invoker.Execute(ri, id, c);
        }
        /// <summary>
        /// Executes a command and gets a response of type TResponse.
        /// </summary>
        /// <typeparam name="TResponse">The type of the response.</typeparam>
        /// <param name="ri">The IRequestInvoker instance on which this method is invoked.</param>
        /// <param name="id">The identifier.</param>
        /// <param name="c">The command object.</param>
        /// <returns></returns>
        public static Task<TResponse> Execute<TResponse>(this IRequestInvoker ri, object id, object c)
        {
            return Execute<TResponse>(ri, id?.ToString(), c);
        }
        /// <summary>
        /// Executes a command and gets a response of type HandlerOperationStatus.
        /// </summary>
        /// <param name="ri">The IRequestInvoker instance on which this method is invoked.</param>
        /// <param name="id">The unique identifier for the command.</param>
        /// <param name="c">The command object.</param>
        /// <returns>A Task that represents the asynchronous operation. The task result contains the response of type HandlerOperationStatus.</returns>

        public static Task Execute(this IRequestInvoker ri, string id, object c)
        {
            var commandType = c.GetType();
            var invoker = (IInvoke<HandlerOperationStatus>)_invokers.GetOrAdd(commandType, x =>
            {
                var t = typeof(Invoker<,>).MakeGenericType(commandType, typeof(HandlerOperationStatus));
                return Activator.CreateInstance(t)!;
            });
            return invoker.Execute(ri, id, c);
        }
        /// <summary>
        /// Executes a command and gets a response of type HandlerOperationStatus.
        /// </summary>
        /// <param name="ri">The IRequestInvoker instance on which this method is invoked.</param>
        /// <param name="id">The unique identifier for the command.</param>
        /// <param name="c">The command object.</param>
        /// <returns>A Task that represents the asynchronous operation. The task result contains the response of type HandlerOperationStatus.</returns>

        public static Task Execute(this IRequestInvoker ri, object id, object c) => Execute(ri, id.ToString(), c);
    }
}



// --- File: MicroPlumberd.DirectConnect\ReturnsAttribute.cs ---


namespace MicroPlumberd.DirectConnect;

public abstract class ReturnsAttribute(Type returnType) : Attribute
{
    public Type ReturnType { get; init; } = returnType;
}


// --- File: MicroPlumberd.Encryption\CertManager.cs ---


using System.Collections.Concurrent;
using System.ComponentModel;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;

namespace MicroPlumberd.Encryption;

[OutputStream("PublicCertificate")]
class PublicCertificate
{
    public byte[] Data { get; set; }
}

public class CertificateNotFoundException : Exception
{
    public string Recipient { get; init; }
}

class CertManagerInitializer(ICertManager cm, IPlumber plumber) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await cm.Init();
        await plumber.Subscribe("$et-PublicCertificateSnapShotted", FromRelativeStreamPosition.Start)
            .WithSnapshotHandler<PubCertEventHandler>();
    }
}

class CertManager(IPlumber plumber, IConfiguration configuration) : ICertManager
{
    private ConcurrentDictionary<string, X509Certificate2> _private = new();
    private ConcurrentDictionary<string, X509Certificate2> _public = new();
    public X509Certificate2 Get(string recipient)
    {
        return _public.GetOrAdd(recipient, r =>
        {
            var certDir = configuration.GetValue<string>("CertsPath") ?? "./certs";
            
            if (!Directory.Exists(certDir))
                Directory.CreateDirectory(certDir);
            var file = Path.Combine(certDir, $"{r}.cer");
            if (File.Exists(file))
                return new X509Certificate2(file);
            file = Path.Combine(certDir, $"{r}.pfx");
            if (File.Exists(file))
                return new X509Certificate2(file);
            throw new CertificateNotFoundException() { Recipient = recipient};
        });
    }

    public async Task Init()
    {
        var r = Environment.MachineName;
        var certDir = configuration.GetValue<string>("CertsPath") ?? "./certs";
        var file = Path.Combine(certDir, r + ".pfx");
        if (!Directory.Exists(certDir))
            Directory.CreateDirectory(certDir);
        if (File.Exists(file))
        {
            var result = await plumber.GetState<PublicCertificate>(r);
            if (result == null)
            {
                // stores are not in sync.
                var cert = new X509Certificate2(file);
                byte[] pubCer = cert.Export(X509ContentType.Cert);
                PublicCertificate pc = new PublicCertificate() { Data = pubCer };
                await plumber.AppendState(pc, r);
            }
        }
        else
        {
            var cert = GenerateCertificate(r);
            byte[] certData = cert.Export(X509ContentType.Pfx, "");
            byte[] pubCer = cert.Export(X509ContentType.Cert);
            await File.WriteAllBytesAsync(file, certData);
            PublicCertificate pc = new PublicCertificate() { Data = pubCer };
            await plumber.AppendState(pc, r);
        }

    }
    public X509Certificate2 GetPrivate(string recipient)
    {
        return _private.GetOrAdd(recipient, r =>
        {
            var certDir = configuration.GetValue<string>("CertsPath") ?? "./certs";
            var file = Path.Combine(certDir, r + ".pfx");
            if (!Directory.Exists(certDir))
                Directory.CreateDirectory(certDir);
            if (File.Exists(file))
                return new X509Certificate2(file, "");
            else
            {
                var cert = GenerateCertificate(r);
                byte[] certData = cert.Export(X509ContentType.Pfx, "");
                byte[] pubCer = cert.Export(X509ContentType.Cert);
                File.WriteAllBytes(file, certData);
                PublicCertificate pc = new PublicCertificate() { Data = pubCer };
                Task.Run(() => plumber.AppendState(pc, recipient));
                
                return cert;
            }
        });
    }
    static X509Certificate2 GenerateCertificate(string subjectName)
    {
        using var rsa = RSA.Create(2048);

        var req = new CertificateRequest($"CN={subjectName}", rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        var start = DateTimeOffset.UtcNow;
        var end = start.AddYears(20);
        var cert = req.CreateSelfSigned(start, end);

        return new X509Certificate2(cert.Export(X509ContentType.Pfx, ""), "", X509KeyStorageFlags.Exportable);
    }

}


// --- File: MicroPlumberd.Encryption\ContainerExtensions.cs ---


using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;

namespace MicroPlumberd.Encryption;

public static class ContainerExtensions
{
    public static IServiceCollection AddEncryption(this IServiceCollection services)
    {
        services.AddHostedService<CertManagerInitializer>();
        services.TryAddSingleton<IEncryptor, Encryptor>();
        services.TryAddSingleton<ICertManager, CertManager>();
        services.AddSingleton<PubCertEventHandler>();
        return services;
    }
    public static IPlumberConfig EnableEncryption(this IPlumberConfig services)
    {
        services.Created += (p) =>
        {
            if(!JsonObjectSerializer.Options.Converters.OfType<SecretConverterJsonConverterFactory>().Any())
                JsonObjectSerializer.Options.Converters.Add(new SecretConverterJsonConverterFactory(services.ServiceProvider));
        };
        return services;
    }
}


// --- File: MicroPlumberd.Encryption\Encryptor.cs ---


using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

namespace MicroPlumberd.Encryption;

class Encryptor(IPlumber plumber, ICertManager certManager) : IEncryptor
{
    private readonly ConcurrentDictionary<Type, IObjectSerializer> _serializers = new();
    private IObjectSerializer Serializer<T>() => _serializers.GetOrAdd(typeof(T), x => plumber.Config.SerializerFactory(x));
    public T Decrypt<T>( byte[] data, string recipient)
    {
        var certificate = certManager.GetPrivate(recipient);
        using var rsa = certificate.GetRSAPrivateKey();
        var decryptedData = rsa.Decrypt(data, RSAEncryptionPadding.OaepSHA256);
            
        return (T)Serializer<T>().Deserialize(decryptedData, typeof(T))!;
    }
    public byte[] Encrypt<T>(T data,  string recipient)
    {
        var dataToEncrypt = Serializer<T>().Serialize(data);
        var certificate = certManager.Get(recipient);
        using var rsa = certificate.GetRSAPublicKey();
        var encryptedData = rsa.Encrypt(dataToEncrypt, RSAEncryptionPadding.OaepSHA256);
        return encryptedData;
    }
}


// --- File: MicroPlumberd.Encryption\ICertManager.cs ---


using System.Security.Cryptography.X509Certificates;

namespace MicroPlumberd.Encryption;

public interface ICertManager
{
    X509Certificate2 GetPrivate(string recipient);
    X509Certificate2 Get(string recipient);
    Task Init();
}


// --- File: MicroPlumberd.Encryption\IEncryptor.cs ---


namespace MicroPlumberd.Encryption;

public interface IEncryptor
{
    byte[] Encrypt<T>(T data,  string recipient);
    T Decrypt<T>(byte[] data, string recipient);
}


// --- File: MicroPlumberd.Encryption\PubCertCacheModel.cs ---


using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Encryption;


class PubCertEventHandler(IConfiguration configuration, ILogger<PubCertEventHandler> log) : IEventHandler, ITypeRegister
{
    Task IEventHandler.Handle(Metadata m, object ev) => Given(m, ev);
    public async Task Given(Metadata m, object ev)
    {
        switch (ev)
        {
            case PublicCertificate e: await Given(m, e); break;
            default:
                throw new ArgumentException("Unknown event type", ev.GetType().Name);
        }
    }
    static IEnumerable<Type> ITypeRegister.Types => [typeof(PublicCertificate)];

    public async Task Given(Metadata m, PublicCertificate cert)
    {
        var certDir = configuration.GetValue<string>("CertsPath") ?? "./certs";
        var recipient = m.SourceStreamId.Substring(m.SourceStreamId.IndexOf('-')+1);
        var file = Path.Combine(certDir, $"{recipient}.cer");
        if (!Directory.Exists(certDir))
            Directory.CreateDirectory(certDir);
        try
        {
            if(!File.Exists(file))
                log.LogInformation("Persisting new public certificate: " + recipient);
            await File.WriteAllBytesAsync(file, cert.Data);
        }
        catch (Exception ex)
        {
            log.LogWarning(ex,"Could not save public certificate.");
        }
    }
}


// --- File: MicroPlumberd.Encryption\SecretConverterJsonConverterFactory.cs ---


using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.Extensions.DependencyInjection;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace MicroPlumberd.Encryption
{
    class SecretConverterJsonConverterFactory(IServiceProvider serviceProvider) : JsonConverterFactory
    {
        public override bool CanConvert(Type typeToConvert)
        {
            return typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(SecretObject<>);
        }

        public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)
        {
            var t = typeToConvert.GetGenericArguments()[0];
            var type = typeof(SecretObjectJsonConverter<>).MakeGenericType(t);
            return (JsonConverter)Activator.CreateInstance(type, serviceProvider.GetRequiredService<IEncryptor>())!;
        }
    }
}



// --- File: MicroPlumberd.Encryption\SecretObject.cs ---


namespace MicroPlumberd.Encryption;

public record SecretObject<T>
{
    private T? _value;
    private bool _decrypted;
    private readonly IEncryptor? _encryptor;
        
    private readonly byte[]? _data;
    private readonly string _recipient;
    
    internal byte[] Data => _data;
    internal string Recipient => _recipient;
    public static implicit operator SecretObject<T>(T obj) => new SecretObject<T>(obj);
    public static implicit operator T(SecretObject<T> obj) => obj.Value;
    private SecretObject(T value, string? recipient = null)
    {
        _value = value;
        _recipient = recipient ?? Environment.MachineName;
        _encryptor = null;
        _decrypted = true;
        //_salt = RandomNumberGenerator.GetBytes(16);
    }

    public T? Value
    {
        get
        {
            if (_decrypted) return _value;
            if (_encryptor == null)
                throw new InvalidOperationException("Missing encryptor");
            _value = _encryptor.Decrypt<T>(_data,_recipient);
            _decrypted = true;
            return _value;
        }
    }

    private SecretObject( byte[] enc, string recipient, IEncryptor encryptor)
    {
          
        _data = enc;
        _recipient = recipient;
        _encryptor = encryptor;
    }

    internal static SecretObject<T> Load(byte[] enc, string recipient, IEncryptor encryptor)
    {
        return new SecretObject<T>( enc, recipient, encryptor);
    }
    public static SecretObject<T> Create(T value, string recipient)
    {
        return new SecretObject<T>(value, recipient);
    }
        

        
}


// --- File: MicroPlumberd.Encryption\SecretObjectData.cs ---


using System.Runtime.Serialization;

namespace MicroPlumberd.Encryption;

[DataContract]
internal record SecretObjectData
{
    public SecretObjectData(string Recipient, byte[] Data)
    {
        this.Recipient = Recipient;
        //this.Salt = Salt;
        this.Data = Data;
    }
    [DataMember(Order = 1)]
    public string Recipient { get; set; }
    //[DataMember(Order = 2)]
    //public byte[] Salt { get; set; }
    [DataMember(Order = 3)]
    public byte[] Data { get; set; }

}


// --- File: MicroPlumberd.Encryption\SecretObjectJsonConverter.cs ---


using System.Text.Json;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Encryption;

public class SecretObjectJsonConverter<T>(IEncryptor encryptor) : JsonConverter<SecretObject<T>>
{
    public override SecretObject<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var dto = JsonSerializer.Deserialize<SecretObjectData>(ref reader, options);
        return SecretObject<T>.Load(dto.Data, dto.Recipient, encryptor);
    }

    public override void Write(Utf8JsonWriter writer, SecretObject<T> value, JsonSerializerOptions options)
    {
        byte[] data = encryptor.Encrypt(value.Value, value.Recipient);
        SecretObjectData dto = new SecretObjectData(value.Recipient,  data);
        JsonSerializer.Serialize(writer, dto, options);
    }
}


// --- File: MicroPlumberd.Examples.Cinema\Components\Layout\MainLayout.razor ---


@inherits LayoutComponentBase
<MudThemeProvider IsDarkMode="true"/>
<MudDialogProvider/>
<MudSnackbarProvider/>

<MudLayout>
    <MudAppBar>
        <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start" OnClick="@((e) => DrawerToggle())" />
        My Application
    </MudAppBar>
    <MudDrawer @bind-Open="@_drawerOpen">
        <NavMenu/>
    </MudDrawer>
    <MudMainContent>
        @Body
    </MudMainContent>
</MudLayout>
@code {
    bool _drawerOpen = true;

    void DrawerToggle()
    {
        _drawerOpen = !_drawerOpen;
    }
}


// --- File: MicroPlumberd.Examples.Cinema\Components\Layout\NavMenu.razor ---


<MudNavMenu>
    <MudNavLink Href="/" Match="NavLinkMatch.All">Dashboard</MudNavLink>
    <MudNavLink Href="/scheduler" Match="NavLinkMatch.Prefix">Scheduler</MudNavLink>
    
</MudNavMenu>


// --- File: MicroPlumberd.Examples.Cinema\Components\Pages\Error.razor ---


@page "/Error"
@using System.Diagnostics

<PageTitle>Error</PageTitle>

<h1 class="text-danger">Error.</h1>
<h2 class="text-danger">An error occurred while processing your request.</h2>

@if (ShowRequestId)
{
    <p>
        <strong>Request ID:</strong> <code>@RequestId</code>
    </p>
}

<h3>Development Mode</h3>
<p>
    Swapping to <strong>Development</strong> environment will display more detailed information about the error that occurred.
</p>
<p>
    <strong>The Development environment shouldn't be enabled for deployed applications.</strong>
    It can result in displaying sensitive information from exceptions to end users.
    For local debugging, enable the <strong>Development</strong> environment by setting the <strong>ASPNETCORE_ENVIRONMENT</strong> environment variable to <strong>Development</strong>
    and restarting the app.
</p>

@code{
    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    private string? RequestId { get; set; }
    private bool ShowRequestId => !string.IsNullOrEmpty(RequestId);

    protected override void OnInitialized() =>
        RequestId = Activity.Current?.Id ?? HttpContext?.TraceIdentifier;
}



// --- File: MicroPlumberd.Examples.Cinema\Components\_Imports.razor ---


@using System.Net.Http
@using System.Net.Http.Json
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web
@using static Microsoft.AspNetCore.Components.Web.RenderMode
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using Microsoft.JSInterop
@using MicroPlumberd.Examples.Cinema
@using MicroPlumberd.Examples.Cinema.Components
@using MudBlazor



// --- File: MicroPlumberd.Examples.Cinema\Components\App.razor ---


<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="_content/MudBlazor/MudBlazor.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="MicroPlumberd.Examples.Cinema.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet @rendermode="InteractiveServer" />
</head>

<body>
    <Routes @rendermode="InteractiveServer" />
    <script src="_framework/blazor.web.js"></script>
    <script src="_content/MudBlazor/MudBlazor.min.js"></script>
</body>

</html>



// --- File: MicroPlumberd.Examples.Cinema\Components\Routes.razor ---


<Router AppAssembly="typeof(Program).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="routeData" DefaultLayout="typeof(Layout.MainLayout)" />
        <FocusOnNavigate RouteData="routeData" Selector="h1" />
    </Found>
</Router>



// --- File: MicroPlumberd.Examples.Cinema\Purchase\RepertuarModel.cs ---


namespace MicroPlumberd.Examples.Cinema.Purchase
{
    
}



// --- File: MicroPlumberd.Examples.Cinema\Purchase\RepertuarPage.razor ---


@page "/"

<h3>RepertuarPage</h3>

@code {

}



// --- File: MicroPlumberd.Examples.Cinema\Purchase\ReservationPage.razor ---


@page "/reservation"

<PageTitle>Home</PageTitle>

<h1>Hello, world!</h1>

Welcome to your new app.



// --- File: MicroPlumberd.Examples.Cinema\Scheduler\AddScreeningDialog.razor ---


@using MicroPlumberd.Examples.Cinema.Utils
@inject ICommandBus _bus
@using MudBlazor
<MudDialog>
    <DialogContent>

        <MudForm>
            @* <MudTextField Label="Movie" @bind-Value="_cmd.Movie" Converter="OptionConverters.String"/> *@
        </MudForm>

    </DialogContent>
    <DialogActions>
        <MudButton Color="Color.Primary" OnClick="Close">Ok</MudButton>
    </DialogActions>
</MudDialog>

@code
{
    private CreateScreening _cmd = new CreateScreening();

    public async Task Close()
    {
        _cmd = new CreateScreening();
        _cmd.Date = DateOnly.FromDateTime(DateTime.Now);
        _cmd.Movie = "Foo";
        _cmd.Time = TimeOnly.FromDateTime(DateTime.Now);
        _cmd.SeatConfiguration = new SeatRoomConfiguration() { RowCount = 10, SeatCount = 10 };
        await _bus.SendAsync(Guid.NewGuid(), _cmd);
    }
}



// --- File: MicroPlumberd.Examples.Cinema\Scheduler\ScheduleCommandHandler.cs ---


using System.ComponentModel.DataAnnotations;
using System.Drawing;
using System.Reflection;
using System.Text.Json.Serialization;
using MicroPlumberd.Services;

namespace MicroPlumberd.Examples.Cinema.Scheduler
{
    [CommandHandler]
    public partial class ScheduleCommandHandler(IPlumber plumber) 
    {
        [ThrowsFaultException<ScreeningTimeCannotBeInPast>]
        public async Task Handle(Guid id, PatchScreening cmd)
        {
            if (cmd.Date.IsDefined && cmd.Time.IsDefined)
                if (cmd.Date.Value.ToDateTime(cmd.Time.Value) < DateTime.Now)
                    throw new FaultException<ScreeningTimeCannotBeInPast>(new ScreeningTimeCannotBeInPast());


            ScreeningStateDefined state = await plumber.GetState<ScreeningStateDefined>(id) ?? throw new Exception();
            
            if (cmd.SeatConfiguration.IsDefined)
            {
                SeatRoomConfiguration conf = cmd.SeatConfiguration;
                state.SeatsInRows = new Space[conf.RowCount, conf.SeatCount];
                foreach (var i in conf.EmptySpaces)
                    state.SeatsInRows[i.Row, i.Seat] = Space.Open;
            }

            if (cmd.Movie.IsDefined)
                state.Movie = cmd.Movie;

            if (cmd.Room.IsDefined)
                state.Room = cmd.Room;

            if (cmd.Time.IsDefined)
                state.When = state.When.Date.Add(cmd.Time.Value.ToTimeSpan());

            if (cmd.Date.IsDefined)
                state.When = cmd.Date.Value.ToDateTime(TimeOnly.MinValue).Add(state.When.TimeOfDay);

            await plumber.AppendState(state);
        }

        public async Task Handle(Guid id, CreateScreening cmd)
        {
            var state = Map(cmd);
            
            await plumber.AppendState(state, id);
        }
        private static ScreeningStateDefined Map(CreateScreening createScreening)
        {
            var seatConfiguration = createScreening.SeatConfiguration;
            var seatsInRows = new Space[seatConfiguration.RowCount, seatConfiguration.SeatCount];
            // Mark empty spaces
            foreach (var emptySpace in seatConfiguration.EmptySpaces)
            {
                seatsInRows[emptySpace.Row, emptySpace.Seat] = Space.Empty;
            }
            return new ScreeningStateDefined
            {
                SeatsInRows = seatsInRows,
                Movie = createScreening.Movie,
                Room = createScreening.Room,
                When = new DateTime(createScreening.Date.Year, createScreening.Date.Month, createScreening.Date.Day, createScreening.Time.Hour, createScreening.Time.Minute, createScreening.Time.Second),
                Version = 1, 
                Id = Guid.NewGuid() 
            };
        }
    }

    
    public class ScreeningTimeCannotBeInPast
    {

    }

    public readonly record struct SeatLocation(ushort Row, ushort Seat);
    
   

    public record PatchScreening
    {
        public Option<SeatRoomConfiguration> SeatConfiguration { get; set; }
        public Option<string> Movie { get; set; }
        public Option<string> Room { get; set; }
        public Option<TimeOnly> Time { get; set; }
        public Option<DateOnly> Date { get; set; }
    }
    public record SeatRoomConfiguration
    {
        public int SeatCount { get; init; } = 0;
        public int RowCount { get; init; } = 0;
        public SeatLocation[] EmptySpaces { get; init; } = Array.Empty<SeatLocation>();
    }
    public record CreateScreening
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public SeatRoomConfiguration SeatConfiguration { get; set; }
        public string Movie { get; set; }
        public string Room { get; set; }
        public TimeOnly Time { get; set; }
        public DateOnly Date { get; set; }

    }

    public enum Space
    {
        Open,Used,Empty
    }
    [OutputStream("Screening")]
    public record ScreeningStateDefined 
    {
        [JsonConverter(typeof(SpaceArrayJsonConverter))]
        public Space[,] SeatsInRows { get; set; }
        public string Movie { get; set; }
        public string Room { get; set; }
        
        public DateTime When { get; set; }
        public long Version { get; set; }
        public Guid Id { get; set; }
    }
}



// --- File: MicroPlumberd.Examples.Cinema\Scheduler\SchedulePage.razor ---


@page "/scheduler"
@using MudBlazor
@inject IDialogService DialogService

<PageTitle>Scheduler</PageTitle>


<MudButton OnClick="OpenDialog" Variant="Variant.Filled" Color="Color.Primary">
    Add screening
</MudButton>

@code {
    private void OpenDialog()
    {
        DialogService.Show<AddScreeningDialog>("Add Screening");
    }
}



// --- File: MicroPlumberd.Examples.Cinema\Scheduler\SpaceArrayJsonConverter.cs ---


using System.Text.Json;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Examples.Cinema.Scheduler;

public class SpaceArrayJsonConverter : JsonConverter<Space[,]>
{
    public override Space[,] Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.String)
        {
            throw new JsonException("Expected string");
        }
        string data = reader.GetString();
        string[] rows = data.Split('\n');
        int rowCount = rows.Length;
        int columnCount = rows[0].Length;
        var result = new Space[rowCount, columnCount];
        for (int i = 0; i < rowCount; i++)
        {
            for (int j = 0; j < columnCount; j++)
            {
                switch (rows[i][j])
                {
                    case 'x':
                        result[i, j] = Space.Used;
                        break;
                    case 'o':
                        result[i, j] = Space.Open;
                        break;
                    case '-':
                        result[i, j] = Space.Empty;
                        break;
                    default:
                        throw new JsonException("Unexpected character in input");
                }
            }
        }
        return result;
    }
    public override void Write(Utf8JsonWriter writer, Space[,] value, JsonSerializerOptions options)
    {
        int rowCount = value.GetLength(0);
        int columnCount = value.GetLength(1);
        var result = new char[rowCount * (columnCount + 1) - 1];
        int index = 0;
        for (int i = 0; i < rowCount; i++)
        {
            for (int j = 0; j < columnCount; j++)
            {
                switch (value[i, j])
                {
                    case Space.Used:
                        result[index++] = 'x';
                        break;
                    case Space.Open:
                        result[index++] = 'o';
                        break;
                    case Space.Empty:
                        result[index++] = '-';
                        break;
                    default:
                        throw new InvalidOperationException("Unexpected Space value");
                }
            }
            if (i < rowCount - 1)
            {
                result[index++] = '\n';
            }
        }
        writer.WriteStringValue(new string(result));
    }
}


// --- File: MicroPlumberd.Examples.Cinema\Utils\Converters.cs ---


using MudBlazor;

namespace MicroPlumberd.Examples.Cinema.Utils
{
    public class OptionConverters
    {
        public static MudBlazor.Converter<Option<string>, string> String =
            new MudBlazor.Converter<Option<string>, string>() { GetFunc = x => x, SetFunc = x => x.Value };
    }
}



// --- File: MicroPlumberd.Examples.Cinema\Program.cs ---


using MicroPlumberd.Examples.Cinema.Components;
using MicroPlumberd.Examples.Cinema.Scheduler;
using MicroPlumberd.Services;
using MudBlazor.Services;

namespace MicroPlumberd.Examples.Cinema
{
    public class Program
    {
        public static void Main(string[] args)
        {
            
            var builder = WebApplication.CreateBuilder(args);

            // Add services to the container.
            builder.Services.AddRazorComponents()
                .AddInteractiveServerComponents();
            builder.Services.AddPlumberd();
            builder.Services.AddCommandHandler<ScheduleCommandHandler>();
            builder.Services.AddMudServices();

            var app = builder.Build();

            // Configure the HTTP request pipeline.
            if (!app.Environment.IsDevelopment())
            {
                app.UseExceptionHandler("/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }

            app.UseHttpsRedirection();

            app.UseStaticFiles();
            app.UseAntiforgery();

            app.MapRazorComponents<App>()
                .AddInteractiveServerRenderMode();

            app.Run();
        }
    }
}



// --- File: MicroPlumberd.ProcessManager.Abstractions\CommandEnqueued.cs ---


// ReSharper disable once CheckNamespace
namespace MicroPlumberd;

/// <summary>
/// Factory class for <see cref="CommandEnqueued{TCommand}"/> events.
/// </summary>
public static class CommandEnqueued
{
    /// <summary>
    /// Creates the specified event.
    /// </summary>
    /// <param name="recipient">The recipient.</param>
    /// <param name="command">The command.</param>
    /// <returns></returns>
    public static ICommandEnqueued Create(Guid recipient, object command)
    {
        var type = typeof(CommandEnqueued<>).MakeGenericType(command.GetType());
        //TODO: Slow, should cache ctor.
        var cmd = (ICommandEnqueued)Activator.CreateInstance(type, recipient, command);

        return cmd;
    }
}
/// <summary>
/// Immutable class used in ProcessManagers in Given methods the rebuild the state based on send commands.
/// </summary>
/// <typeparam name="TCommand">The type of the command.</typeparam>
public sealed class CommandEnqueued<TCommand> : ICommandEnqueued
{
    /// <summary>
    /// Initializes a new instance of the <see cref="CommandEnqueued{TCommand}"/> class.
    /// </summary>
    /// <param name="recipientId">The recipient identifier.</param>
    /// <param name="command">The command.</param>
    public CommandEnqueued(Guid recipientId, TCommand command)
    {
        RecipientId = recipientId;
        Command = command;
    }
    /// <summary>
    /// Initializes a new instance of the <see cref="CommandEnqueued{TCommand}"/> class.
    /// </summary>
    public CommandEnqueued() { }
    object ICommandEnqueued.Command => Command;

    /// <summary>
    /// Gets the command.
    /// </summary>
    /// <value>
    /// The command.
    /// </value>
    public TCommand Command { get; init; }

    /// <summary>
    /// Gets the recipient identifier.
    /// </summary>
    /// <value>
    /// The recipient identifier.
    /// </value>
    public Guid RecipientId { get; init; }
}


// --- File: MicroPlumberd.ProcessManager.Abstractions\CommandInvocationFailed.cs ---


namespace MicroPlumberd;

public record CommandInvocationFailed
{
    public Guid RecipientId { get; init; }
    public ICommandRequest Command { get; init; }
    public string Message { get; init; }
}


// --- File: MicroPlumberd.ProcessManager.Abstractions\CommandRequest.cs ---


namespace MicroPlumberd;

public static class CommandRequest
{
    public static ICommandRequest Create(Guid recipientId, object command)
    {
        var t = typeof(CommandRequest<>).MakeGenericType(command.GetType());
        return (ICommandRequest)Activator.CreateInstance(t, recipientId, command);
    }
    public static ICommandRequest<TCommand> Create<TCommand>(Guid recipientId, TCommand command)
    {
        return new CommandRequest<TCommand>(recipientId, command);
    }
}
public record CommandRequest<TCommand> : ICommandRequest<TCommand>
{
    internal CommandRequest(Guid recipientId, TCommand command)
    {
        this.RecipientId = recipientId;
        this.Command = command;
    }

    public CommandRequest() { }
    public TCommand Command { get; init; }
    public Guid RecipientId { get; init; }
    object ICommandRequest.Command => Command;
}



// --- File: MicroPlumberd.ProcessManager.Abstractions\ExecutionContext.cs ---


namespace MicroPlumberd;

public record ExecutionContext(Metadata Metadata, object Event, Guid Id, ICommandRequest? Command, Exception Exception);


// --- File: MicroPlumberd.ProcessManager.Abstractions\ICommandEnqueued.cs ---


namespace MicroPlumberd;

public interface ICommandEnqueued
{
    object Command { get; }
    Guid RecipientId { get; }
}


// --- File: MicroPlumberd.ProcessManager.Abstractions\ICommandRequest.cs ---


// ReSharper disable once CheckNamespace
namespace MicroPlumberd;

public interface IProcessAction
{

}

public record StateChangeAction<TOwner>(Guid Id, long Version, params object[] Events) : IStateChangeAction
{
    public Type Owner => typeof(TOwner);
}
public interface IStateChangeAction : IProcessAction
{
    Guid Id { get;  }
    long Version { get; }
    object[] Events { get; }
    Type Owner { get; }
}
public interface ICommandRequest : IProcessAction
{
    Guid RecipientId { get; }
    object Command { get; }
}
public interface ICommandRequest<out TCommand> : ICommandRequest
{
    new TCommand Command { get; }
}


// --- File: MicroPlumberd.ProcessManager.Abstractions\IProcessManager.cs ---


using System.Security.Cryptography;
using System;

// ReSharper disable once CheckNamespace
namespace MicroPlumberd
{
    public interface IProcessManager : IEventHandler, IVersioned, IId
    {
        static abstract Type StartEvent { get; }
        static abstract IEnumerable<Type> CommandTypes { get; }
        Task<ICommandRequest?> HandleError(ExecutionContext executionContext);
        Task<ICommandRequest?> When(Metadata m, object evt);
        Task<ICommandRequest> StartWhen(Metadata m, object evt);
    }


    public abstract class ProcessManagerBase<TId> : IVersionAware, IIdAware, IId<TId> where TId : IParsable<TId>
    {
        private TId _id;
        public TId Id => _id;
        object IIdAware.Id { set => _id = (TId)value;
            get => _id;
        }
        public long Version { get; set; } = -1;
        

        public virtual async Task<ICommandRequest?> HandleError(ExecutionContext executionContext) => null;
    }


}



// --- File: MicroPlumberd.ProcessManager.Abstractions\ProcessManagerAttribute.cs ---


// ReSharper disable once CheckNamespace
namespace MicroPlumberd;

[AttributeUsage(AttributeTargets.Class)]
public class ProcessManagerAttribute : Attribute { }


// --- File: MicroPlumberd.Protobuf\ExpandoObjectConverter.cs ---


using System.Collections;
using System.Dynamic;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Protobuf;

class ExpandoObjectConverter : JsonConverter<ExpandoObject>
{
    public override ExpandoObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return ReadValue(ref reader, options);
    }
    
    private ExpandoObject ReadValue(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
        {
            throw new JsonException();
        }
    
        var expando = new ExpandoObject();
        IDictionary<string, object> dictionary = expando!;
    
        while (reader.Read())
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.EndObject:
                    return expando;
                case JsonTokenType.PropertyName:
                    var propertyName = reader.GetString();
                    reader.Read();
                    dictionary[propertyName!] = ReadObject(ref reader, options)!;
                    break;
                default:
                    throw new JsonException();
            }
        }
    
        throw new JsonException("Expected EndObject token not found.");
    }
    
    private object? ReadObject(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        switch (reader.TokenType)
        {
            case JsonTokenType.StartObject:
                return ReadValue(ref reader, options);
            case JsonTokenType.StartArray:
                return ReadArray(ref reader, options);
            case JsonTokenType.String:
                return reader.GetString();
            case JsonTokenType.Number:
                if (reader.TryGetInt32(out int intValue))
                {
                    return intValue;
                }
                else if (reader.TryGetDouble(out double doubleValue))
                {
                    return doubleValue;
                }
                break; // Could also handle other numeric types
            case JsonTokenType.True:
            case JsonTokenType.False:
                return reader.GetBoolean();
            case JsonTokenType.Null:
                return null;
            default:
                throw new JsonException($"Unexpected token: {reader.TokenType}");
        }
    
        return null;
    }
    
    private object ReadArray(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        var list = new List<object>();
    
        while (reader.Read())
        {
            if (reader.TokenType == JsonTokenType.EndArray)
            {
                return list;
            }
    
            list.Add(ReadObject(ref reader, options)!);
        }
    
        throw new JsonException("Expected EndArray token not found.");
    }
    
    public override void Write(Utf8JsonWriter writer, ExpandoObject value, JsonSerializerOptions options)
    {
        writer.WriteStartObject(); // Start writing the object
    
        foreach (var kvp in value)
        {
            writer.WritePropertyName(kvp.Key);
            WriteValue(writer, kvp.Value!, options);
        }
    
        writer.WriteEndObject(); // End writing the object
    }
    
    private void WriteValue(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
    {
        switch (value)
        {
            case null:
                writer.WriteNullValue();
                break;
            case ExpandoObject expando:
                Write(writer, expando, options); // Recursive call for nested objects
                break;
            case IList list:
                WriteArray(writer, list, options);
                break;
            case string str:
                writer.WriteStringValue(str);
                break;
            case bool boolVal:
                writer.WriteBooleanValue(boolVal);
                break;
            case int intVal:
                writer.WriteNumberValue(intVal);
                break;
            case long longVal:
                writer.WriteNumberValue(longVal);
                break;
            case float floatVal:
                writer.WriteNumberValue(floatVal);
                break;
            case double doubleVal:
                writer.WriteNumberValue(doubleVal);
                break;
            case DateTime dateTime:
                writer.WriteStringValue(dateTime);
                break;
            // Add other types as necessary
            default:
                JsonSerializer.Serialize(writer, value, value.GetType(), options);
                break;
        }
    }
    
    private void WriteArray(Utf8JsonWriter writer, IList list, JsonSerializerOptions options)
    {
        writer.WriteStartArray();
    
        foreach (var item in list)
        {
            WriteValue(writer, item, options);
        }
    
        writer.WriteEndArray();
    }
}


// --- File: MicroPlumberd.Protobuf\ProtoBuffObjectSerialization.cs ---


using System.Buffers;
using System.Collections.Concurrent;
using System.Dynamic;
using System.Text.Json;
using MicroPlumberd.Services;
using ProtoBuf;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;

namespace MicroPlumberd.Protobuf
{
    public class ProtoBuffObjectSerialization : IObjectSerializer
    {

        interface ISerializer
        {
            byte[] Serialize(object? t);
        }

        class Json : ISerializer
        {
            public byte[] Serialize(object? t)
            {
                return JsonSerializer.SerializeToUtf8Bytes(t, ProtoBuffObjectSerialization.Options);
            }
        }
        class ProtoSerializer<T> : ISerializer
        {
            public byte[] Serialize(object? t)
            {
                using var s = new MemoryStream();
                Serializer.Serialize(s, (T)t);
                return s.ToArray();
            }
        }
        private static readonly ConcurrentDictionary<Type, ISerializer> _serializes =
            new ConcurrentDictionary<Type, ISerializer>();
        public static JsonSerializerOptions Options = new() { Converters = { new ExpandoObjectConverter() } };
        private static JsonElement Empty = JsonSerializer.Deserialize<JsonElement>("{}");

        static ProtoBuffObjectSerialization()
        {
            //var model = RuntimeTypeModel.Default;
            //var type = model.Add(typeof(CommandExecuted), applyDefaultBehaviour: false);
            //model.Add
            //type.AddField(1, "CommandId");
            //type.AddField(2, "Duration");

            //var type2 = model.Add(typeof(CommandFailed), applyDefaultBehaviour: false);
            //type2.AddField(1, "CommandId");
            //type2.AddField(2, "Duration");
        }
        public object? Deserialize(ReadOnlySpan<byte> span, Type t)
        {
            return Serializer.NonGeneric.Deserialize(t, span);
        }

        public JsonElement ParseMetadata(ReadOnlySpan<byte> span)
        {
            if (span.Length == 0) return Empty;
            return JsonSerializer.Deserialize<JsonElement>(span, Options);
        }

        public byte[] Serialize(object? t)
        {
            
            return _serializes.GetOrAdd(t.GetType(),
                x =>
                {
                    if (x == typeof(ExpandoObject)) return new Json();
                    return (ISerializer)Activator.CreateInstance(typeof(ProtoSerializer<>).MakeGenericType(x));
                }).Serialize(t);
        }

        public string ContentType => "application/octet-stream";
    }
}



// --- File: MicroPlumberd.Service.Identity\Aggregates\AccessFailedCountChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record AccessFailedCountChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public int AccessFailedCount { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\AuthenticatorKeyChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record AuthenticatorKeyChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string AuthenticatorKey { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\AuthorizationUserAggregate.cs ---


using System.Collections.Immutable;
using System.Security.Claims;

namespace MicroPlumberd.Service.Identity.Aggregates;

[Aggregate]
public partial class AuthorizationUserAggregate : AggregateBase<UserIdentifier, AuthorizationUserAggregate.AuthorizationUserState>
{
    public AuthorizationUserAggregate(UserIdentifier id) : base(id) { }

    public record AuthorizationUserState
    {
        public UserIdentifier Id { get; init; }
        public ImmutableList<RoleIdentifier> Roles { get; init; } = ImmutableList<RoleIdentifier>.Empty;
        public ImmutableList<ClaimRecord> Claims { get; init; } = ImmutableList<ClaimRecord>.Empty;
        
        public bool IsDeleted { get; init; }
    }

    public record ClaimRecord
    {
        public ClaimType Type { get; init; }
        public ClaimValue Value { get; init; }
    }

    // Event application methods
    private static AuthorizationUserState Given(AuthorizationUserState state, AuthorizationUserCreated ev)
    {
        return new AuthorizationUserState
        {
            Id = ev.UserId,
            IsDeleted = false
        };
    }

    private static AuthorizationUserState Given(AuthorizationUserState state, RoleAdded ev)
    {
        if (state.Roles.Contains(ev.RoleId))
            return state;

        return state with
        {
            Roles = state.Roles.Add(ev.RoleId),
        };
    }

    private static AuthorizationUserState Given(AuthorizationUserState state, RoleRemoved ev)
    {
        return state with
        {
            Roles = state.Roles.Remove(ev.RoleId),
        };
    }

    private static AuthorizationUserState Given(AuthorizationUserState state, ClaimAdded ev)
    {
        var claimRecord = new ClaimRecord
        {
            Type = ev.ClaimType,
            Value = ev.ClaimValue
        };

        // Check if the claim already exists with this type and value
        bool claimExists = state.Claims.Any(c =>
            c.Type.Value == ev.ClaimType.Value &&
            c.Value.Value == ev.ClaimValue.Value);

        if (claimExists)
            return state;

        return state with
        {
            Claims = state.Claims.Add(claimRecord),
        };
    }

    private static AuthorizationUserState Given(AuthorizationUserState state, ClaimRemoved ev)
    {
        // Find all claims with matching type and value
        var claimsToRemove = state.Claims
            .Where(c =>
                c.Type.Value == ev.ClaimType.Value &&
                c.Value.Value == ev.ClaimValue.Value)
            .ToList();

        if (!claimsToRemove.Any())
            return state;

        var newClaims = state.Claims;
        foreach (var claim in claimsToRemove)
        {
            newClaims = newClaims.Remove(claim);
        }

        return state with
        {
            Claims = newClaims,
        };
    }

    private static AuthorizationUserState Given(AuthorizationUserState state, ClaimsReplaced ev)
    {
        // Convert the list of claims to ClaimRecord objects
        var newClaims = ev.Claims.Select(c => new ClaimRecord
        {
            Type = new ClaimType(c.Type),
            Value = new ClaimValue(c.Value)
        }).ToImmutableList();

        return state with
        {
            Claims = newClaims,
        };
    }


    private static AuthorizationUserState Given(AuthorizationUserState state, AuthorizationUserDeleted ev)
    {
        return state with { IsDeleted = true };
    }

    // Command methods
    public static AuthorizationUserAggregate Create(UserIdentifier id)
    {
        var aggregate = Empty(id);

        aggregate.AppendPendingChange(new AuthorizationUserCreated
        {
            Id = Guid.NewGuid(),
            UserId = id,
        });

        return aggregate;
    }

    public void AddRole(RoleIdentifier roleId)
    {
        EnsureNotDeleted();

        if (State.Roles.Contains(roleId))
            return; // Role already added

        AppendPendingChange(new RoleAdded
        {
            Id = Guid.NewGuid(),
            RoleId = roleId,
            
        });
    }

    public void RemoveRole(RoleIdentifier roleId)
    {
        EnsureNotDeleted();
        
        if (!State.Roles.Contains(roleId))
            return; // Role not present

        AppendPendingChange(new RoleRemoved
        {
            Id = Guid.NewGuid(),
            RoleId = roleId,
            
        });
    }

    public void AddClaim(ClaimType claimType, ClaimValue claimValue)
    {
        EnsureNotDeleted();
        
        // Check if claim already exists
        bool claimExists = State.Claims.Any(c =>
            c.Type.Value == claimType.Value &&
            c.Value.Value == claimValue.Value);

        if (claimExists)
            return; // Claim already added

        AppendPendingChange(new ClaimAdded
        {
            Id = Guid.NewGuid(),
            ClaimType = claimType,
            ClaimValue = claimValue,
            
        });
    }

    public void RemoveClaim(ClaimType claimType, ClaimValue claimValue)
    {
        EnsureNotDeleted();
        

        // Check if any claim matches
        bool claimExists = State.Claims.Any(c =>
            c.Type.Value == claimType.Value &&
            c.Value.Value == claimValue.Value);

        if (!claimExists)
            return; // No matching claim

        AppendPendingChange(new ClaimRemoved
        {
            Id = Guid.NewGuid(),
            ClaimType = claimType,
            ClaimValue = claimValue,
            
        });
    }

    public void ReplaceClaims(IEnumerable<Claim> claims)
    {
        EnsureNotDeleted();
        

        AppendPendingChange(new ClaimsReplaced
        {
            Id = Guid.NewGuid(),
            Claims = claims.ToList(),
            
        });
    }


    public void Delete()
    {
        if (State.IsDeleted)
            return;

        AppendPendingChange(new AuthorizationUserDeleted
        {
            Id = Guid.NewGuid()
        });
    }

    // Helper methods
    private void EnsureNotDeleted()
    {
        if (State.IsDeleted)
            throw new InvalidOperationException("Cannot modify authorization data of a deleted user");
    }

   
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\AuthorizationUserCreated.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using MicroPlumberd;


namespace MicroPlumberd.Service.Identity.Aggregates
{
    // Events
    [OutputStream("Authorization")]
    public record AuthorizationUserCreated
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public UserIdentifier UserId { get; init; }
    }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\AuthorizationUserDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record AuthorizationUserDeleted
{
    public Guid Id { get; init; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ClaimAdded.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record ClaimAdded
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public ClaimType ClaimType { get; init; }
    public ClaimValue ClaimValue { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ClaimRemoved.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record ClaimRemoved
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public ClaimType ClaimType { get; init; }
    public ClaimValue ClaimValue { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ClaimsReplaced.cs ---


using System.Security.Claims;

namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record ClaimsReplaced
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public List<Claim> Claims { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ConcurrencyException.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public class ConcurrencyException : Exception
{
    public ConcurrencyException(string message) : base(message)
    {
    }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\EmailChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record EmailChanged
{
    public Guid Id { get; init; }
    public string Email { get; init; }
    public string NormalizedEmail { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\EmailConfirmed.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record EmailConfirmed
{
    public Guid Id { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ExternalLoginAdded.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("ExternalLogin")]
public record ExternalLoginAdded
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public ExternalLoginProvider Provider { get; init; }
    public ExternalLoginKey ProviderKey { get; init; }
    public string DisplayName { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ExternalLoginAggregate.cs ---


using System.Collections.Immutable;

namespace MicroPlumberd.Service.Identity.Aggregates;

[Aggregate]
public partial class ExternalLoginAggregate : AggregateBase<UserIdentifier, ExternalLoginAggregate.ExternalLoginState>
{
    public ExternalLoginAggregate(UserIdentifier id) : base(id) { }

    public record ExternalLoginState
    {
        public UserIdentifier Id { get; init; }
        public ImmutableList<ExternalLoginRecord> Logins { get; init; } = ImmutableList<ExternalLoginRecord>.Empty;
        
        public bool IsDeleted { get; init; }
    }

    public record ExternalLoginRecord
    {
        public ExternalLoginProvider Provider { get; init; }
        public ExternalLoginKey ProviderKey { get; init; }
        public string DisplayName { get; init; }
    }

    // Event application methods
    private static ExternalLoginState Given(ExternalLoginState state, ExternalLoginAggregateCreated ev)
    {
        return new ExternalLoginState
        {
            Id = ev.UserId,
            
            IsDeleted = false
        };
    }

    private static ExternalLoginState Given(ExternalLoginState state, ExternalLoginAdded ev)
    {
        var loginRecord = new ExternalLoginRecord
        {
            Provider = ev.Provider,
            ProviderKey = ev.ProviderKey,
            DisplayName = ev.DisplayName
        };

        // Check if login already exists
        bool loginExists = state.Logins.Any(l =>
            l.Provider.Name == ev.Provider.Name &&
            l.ProviderKey.Value == ev.ProviderKey.Value);

        if (loginExists)
            return state;

        return state with
        {
            Logins = state.Logins.Add(loginRecord),
            
        };
    }

    private static ExternalLoginState Given(ExternalLoginState state, ExternalLoginRemoved ev)
    {
        var loginToRemove = state.Logins.FirstOrDefault(l =>
            l.Provider.Name == ev.Provider.Name &&
            l.ProviderKey.Value == ev.ProviderKey.Value);

        if (loginToRemove == null)
            return state;

        return state with
        {
            Logins = state.Logins.Remove(loginToRemove),
            
        };
    }

    

    private static ExternalLoginState Given(ExternalLoginState state, ExternalLoginAggregateDeleted ev)
    {
        return state with { IsDeleted = true };
    }

    // Command methods
    public static ExternalLoginAggregate Create(UserIdentifier id)
    {
        var aggregate = Empty(id);

        aggregate.AppendPendingChange(new ExternalLoginAggregateCreated
        {
            Id = Guid.NewGuid(),
            UserId = id,
            
        });

        return aggregate;
    }

    public void AddLogin(
        ExternalLoginProvider provider,
        ExternalLoginKey providerKey,
        string displayName
        )
    {
        EnsureNotDeleted();
        

        // Validation
        if (string.IsNullOrEmpty(provider.Name))
            throw new ArgumentException("Provider name cannot be empty", nameof(provider));

        if (string.IsNullOrEmpty(providerKey.Value))
            throw new ArgumentException("Provider key cannot be empty", nameof(providerKey));

        // Check if login already exists
        bool loginExists = State.Logins.Any(l =>
            l.Provider.Name == provider.Name &&
            l.ProviderKey.Value == providerKey.Value);

        if (loginExists)
            return; // Login already added

        AppendPendingChange(new ExternalLoginAdded
        {
            Id = Guid.NewGuid(),
            Provider = provider,
            ProviderKey = providerKey,
            DisplayName = displayName ?? string.Empty,
            
        });
    }

    public void RemoveLogin(
        ExternalLoginProvider provider,
        ExternalLoginKey providerKey
        )
    {
        EnsureNotDeleted();
        

        // Check if login exists
        bool loginExists = State.Logins.Any(l =>
            l.Provider.Name == provider.Name &&
            l.ProviderKey.Value == providerKey.Value);

        if (!loginExists)
            return; // Login doesn't exist

        AppendPendingChange(new ExternalLoginRemoved
        {
            Id = Guid.NewGuid(),
            Provider = provider,
            ProviderKey = providerKey,
            
        });
    }

   

    public void Delete()
    {
        if (State.IsDeleted)
            return;

        

        AppendPendingChange(new ExternalLoginAggregateDeleted
        {
            Id = Guid.NewGuid()
        });
    }

    // Helper methods
    private void EnsureNotDeleted()
    {
        if (State.IsDeleted)
            throw new InvalidOperationException("Cannot modify external logins of a deleted user");
    }

    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ExternalLoginAggregateCreated.cs ---


using System;
using System.Linq;
using System.Threading.Tasks;
using MicroPlumberd;


namespace MicroPlumberd.Service.Identity.Aggregates
{
    // Events
    [OutputStream("ExternalLogin")]
    public record ExternalLoginAggregateCreated
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public UserIdentifier UserId { get; init; }
        
    }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ExternalLoginAggregateDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("ExternalLogin")]
public record ExternalLoginAggregateDeleted
{
    public Guid Id { get; init; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\ExternalLoginRemoved.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("ExternalLogin")]
public record ExternalLoginRemoved
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public ExternalLoginProvider Provider { get; init; }
    public ExternalLoginKey ProviderKey { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\IdentityUserAggregate.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[Aggregate]
public partial class IdentityUserAggregate : AggregateBase<UserIdentifier, IdentityUserAggregate.IdentityUserState>
{
    public IdentityUserAggregate(UserIdentifier id) : base(id) { }

    public record IdentityUserState
    {
        public UserIdentifier Id { get; init; }
        public string PasswordHash { get; init; }
        public string SecurityStamp { get; init; }
        public bool TwoFactorEnabled { get; init; }
        public string AuthenticatorKey { get; init; }
        public int AccessFailedCount { get; init; }
        public bool LockoutEnabled { get; init; }
        public DateTimeOffset? LockoutEnd { get; init; }
        
        public bool IsDeleted { get; init; }
    }

    // Event application methods
    private static IdentityUserState Given(IdentityUserState state, IdentityUserCreated ev)
    {
        return new IdentityUserState
        {
            Id = ev.UserId,
            PasswordHash = ev.PasswordHash,
            SecurityStamp = ev.SecurityStamp,
            TwoFactorEnabled = false,
            AuthenticatorKey = null,
            AccessFailedCount = 0,
            LockoutEnabled = ev.LockoutEnabled,
            LockoutEnd = null,
            
            IsDeleted = false
        };
    }

    private static IdentityUserState Given(IdentityUserState state, PasswordChanged ev)
    {
        return state with
        {
            PasswordHash = ev.PasswordHash,
            SecurityStamp = ev.SecurityStamp,
            
        };
    }

    private static IdentityUserState Given(IdentityUserState state, SecurityStampChanged ev)
    {
        return state with
        {
            SecurityStamp = ev.SecurityStamp,
            
        };
    }

    private static IdentityUserState Given(IdentityUserState state, TwoFactorChanged ev)
    {
        var newState = state with
        {
            TwoFactorEnabled = ev.TwoFactorEnabled,
            
        };

        // If disabling 2FA, clear the authenticator key
        if (!ev.TwoFactorEnabled)
        {
            newState = newState with { AuthenticatorKey = null };
        }

        return newState;
    }

    private static IdentityUserState Given(IdentityUserState state, AuthenticatorKeyChanged ev)
    {
        return state with
        {
            AuthenticatorKey = ev.AuthenticatorKey,
            
        };
    }

    private static IdentityUserState Given(IdentityUserState state, AccessFailedCountChanged ev)
    {
        return state with
        {
            AccessFailedCount = ev.AccessFailedCount,
            
        };
    }

    private static IdentityUserState Given(IdentityUserState state, LockoutEnabledChanged ev)
    {
        return state with
        {
            LockoutEnabled = ev.LockoutEnabled,
            
        };
    }

    private static IdentityUserState Given(IdentityUserState state, LockoutEndChanged ev)
    {
        return state with
        {
            LockoutEnd = ev.LockoutEnd,
            
        };
    }



    private static IdentityUserState Given(IdentityUserState state, IdentityUserDeleted ev)
    {
        return state with { IsDeleted = true };
    }

    // Command methods
    public static IdentityUserAggregate Create(UserIdentifier id, string passwordHash, bool lockoutEnabled)
    {
        var aggregate = Empty(id);

        // Generate a new security stamp
        var securityStamp = Guid.NewGuid().ToString();

        aggregate.AppendPendingChange(new IdentityUserCreated
        {
            Id = Guid.NewGuid(),
            UserId = id,
            PasswordHash = passwordHash,
            SecurityStamp = securityStamp,
            LockoutEnabled = lockoutEnabled,
            
        });

        return aggregate;
    }

    /// <summary>
    /// Updates the password hash if it has changed
    /// </summary>
    public void ChangePasswordHash(string passwordHash)
    {
        EnsureNotDeleted();

        // Only emit an event if the password hash has actually changed
        if (State.PasswordHash != passwordHash && !string.IsNullOrEmpty(passwordHash))
        {
            // Generate a new security stamp whenever the password changes
            var securityStamp = Guid.NewGuid().ToString();

            AppendPendingChange(new PasswordChanged
            {
                Id = Guid.NewGuid(),
                PasswordHash = passwordHash,
                SecurityStamp = securityStamp
            });
        }
    }

    public void ChangeSecurityStamp()
    {
        EnsureNotDeleted();
        

        AppendPendingChange(new SecurityStampChanged
        {
            Id = Guid.NewGuid(),
            SecurityStamp = Guid.NewGuid().ToString(),
            
        });
    }

    /// <summary>
    /// Updates the two-factor enabled setting if it has changed
    /// </summary>
    public void ChangeTwoFactorEnabled(bool enabled)
    {
        EnsureNotDeleted();

        // Only emit an event if the two-factor enabled setting has actually changed
        if (State.TwoFactorEnabled != enabled)
        {
            // If enabling 2FA, ensure we have an authenticator key
            if (enabled && string.IsNullOrEmpty(State.AuthenticatorKey))
            {
                throw new InvalidOperationException("Cannot enable two-factor authentication without an authenticator key");
            }

            AppendPendingChange(new TwoFactorChanged
            {
                Id = Guid.NewGuid(),
                TwoFactorEnabled = enabled
            });
        }
    }

    public void ChangeAuthenticatorKey(string authenticatorKey )
    {
        EnsureNotDeleted();
        

        if (string.IsNullOrEmpty(authenticatorKey))
        {
            throw new ArgumentException("Authenticator key cannot be empty", nameof(authenticatorKey));
        }

        AppendPendingChange(new AuthenticatorKeyChanged
        {
            Id = Guid.NewGuid(),
            AuthenticatorKey = authenticatorKey,
            
        });
    }

    public int IncrementAccessFailedCount()
    {
        EnsureNotDeleted();
        

        // If the user is locked out, don't increment the count
        if (IsLockedOut())
            return State.AccessFailedCount;

        var newCount = State.AccessFailedCount + 1;

        AppendPendingChange(new AccessFailedCountChanged
        {
            Id = Guid.NewGuid(),
            AccessFailedCount = newCount,
            
        });

        // If lockout is enabled and we've reached the threshold, lock the user out
        if (State.LockoutEnabled && newCount >= 5) // 5 is a common default
        {
            AppendPendingChange(new LockoutEndChanged
            {
                Id = Guid.NewGuid(),
                LockoutEnd = DateTimeOffset.UtcNow.AddMinutes(15), // 15 minutes is a common default
                
            });
        }

        return newCount;
    }

    public void ResetAccessFailedCount()
    {
        EnsureNotDeleted();
        

        if (State.AccessFailedCount > 0)
        {
            AppendPendingChange(new AccessFailedCountChanged
            {
                Id = Guid.NewGuid(),
                AccessFailedCount = 0,
                
            });
        }
    }

    /// <summary>
    /// Updates the lockout enabled setting if it has changed
    /// </summary>
    public void ChangeLockoutEnabled(bool enabled)
    {
        EnsureNotDeleted();

        // Only emit an event if the lockout enabled setting has actually changed
        if (State.LockoutEnabled != enabled)
        {
            AppendPendingChange(new LockoutEnabledChanged
            {
                Id = Guid.NewGuid(),
                LockoutEnabled = enabled
            });
        }
    }

    public void ChangeLockoutEnd(DateTimeOffset? lockoutEnd )
    {
        EnsureNotDeleted();


        // If setting a lockout end, ensure it's in the future
        if (State.LockoutEnd != lockoutEnd)
        {
            // If setting a lockout end, ensure it's in the future
            if (lockoutEnd.HasValue && lockoutEnd.Value <= DateTimeOffset.UtcNow)
            {
                throw new ArgumentException("Lockout end date must be in the future", nameof(lockoutEnd));
            }

            AppendPendingChange(new LockoutEndChanged
            {
                Id = Guid.NewGuid(),
                LockoutEnd = lockoutEnd
            });
        }
    }


    public void Delete()
    {
        if (State.IsDeleted)
            return;

        

        AppendPendingChange(new IdentityUserDeleted
        {
            Id = Guid.NewGuid()
        });
    }

    // Helper methods
    public bool IsLockedOut()
    {
        return State.LockoutEnabled &&
               State.LockoutEnd.HasValue &&
               State.LockoutEnd.Value > DateTimeOffset.UtcNow;
    }

    private void EnsureNotDeleted()
    {
        if (State.IsDeleted)
            throw new InvalidOperationException("Cannot modify a deleted user");
    }


}


// --- File: MicroPlumberd.Service.Identity\Aggregates\IdentityUserCreated.cs ---


using System;
using System.Threading.Tasks;
using MicroPlumberd;


namespace MicroPlumberd.Service.Identity.Aggregates
{
    [OutputStream("Identity")]
    public record IdentityUserCreated
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public UserIdentifier UserId { get; init; }
        public string PasswordHash { get; init; }
        public string SecurityStamp { get; init; }
        public bool LockoutEnabled { get; init; }
        
    }

    // Exception for concurrency conflicts
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\IdentityUserDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record IdentityUserDeleted
{
    public Guid Id { get; init; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\LockoutEnabledChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record LockoutEnabledChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public bool LockoutEnabled { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\LockoutEndChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record LockoutEndChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public DateTimeOffset? LockoutEnd { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\PasswordChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record PasswordChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string PasswordHash { get; init; }
    public string SecurityStamp { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\PhoneNumberChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record PhoneNumberChanged
{
    public Guid Id { get; init; }
    public string PhoneNumber { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\PhoneNumberConfirmed.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record PhoneNumberConfirmed
{
    public Guid Id { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleAdded.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record RoleAdded
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public RoleIdentifier RoleId { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleAggregate.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[Aggregate]
public partial class RoleAggregate : AggregateBase<RoleIdentifier, RoleAggregate.RoleState>
{
    public RoleAggregate(RoleIdentifier id) : base(id) { }

    public record RoleState
    {
        public RoleIdentifier Id { get; init; }
        public string Name { get; init; }
        public string NormalizedName { get; init; }
        
        public bool IsDeleted { get; init; }
    }

    // Event application methods
    private static RoleState Given(RoleState state, RoleCreated ev)
    {
        return new RoleState
        {
            Id = ev.RoleId,
            Name = ev.Name,
            NormalizedName = ev.NormalizedName,
            
            IsDeleted = false
        };
    }

    private static RoleState Given(RoleState state, RoleNameChanged ev)
    {
        return state with
        {
            Name = ev.Name,
            NormalizedName = ev.NormalizedName,
            
        };
    }

   

    private static RoleState Given(RoleState state, RoleDeleted ev)
    {
        return state with { IsDeleted = true };
    }

    // Command methods
    public static RoleAggregate Create(RoleIdentifier id, string name, string normalizedName)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Role name cannot be empty", nameof(name));

        if (string.IsNullOrWhiteSpace(normalizedName))
            throw new ArgumentException("Normalized role name cannot be empty", nameof(normalizedName));

        var aggregate = Empty(id);
        aggregate.AppendPendingChange(new RoleCreated
        {
            Id = Guid.NewGuid(),
            RoleId = id,
            Name = name,
            NormalizedName = normalizedName,
            
        });

        return aggregate;
    }

    public void ChangeName(string name, string normalizedName)
    {
        if (State.IsDeleted)
            throw new InvalidOperationException("Cannot modify a deleted role");

        // Only emit an event if the name has actually changed
        if (State.Name != name || State.NormalizedName != normalizedName)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Role name cannot be empty", nameof(name));

            if (string.IsNullOrWhiteSpace(normalizedName))
                throw new ArgumentException("Normalized role name cannot be empty", nameof(normalizedName));

            AppendPendingChange(new RoleNameChanged
            {
                Id = Guid.NewGuid(),
                Name = name,
                NormalizedName = normalizedName
            });
        }
    }



    public void Delete()
    {
        if (State.IsDeleted)
            return;

        
        AppendPendingChange(new RoleDeleted
        {
            Id = Guid.NewGuid()
        });
    }

}




// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleCreated.cs ---


using System;
using System.Threading.Tasks;
using MicroPlumberd;


namespace MicroPlumberd.Service.Identity.Aggregates
{
    // Events
    [OutputStream("Authorization")]
    public record RoleCreated
    {
        public Guid Id { get; init; }
        public RoleIdentifier RoleId { get; init; }
        public string Name { get; init; }
        public string NormalizedName { get; init; }
        
    }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record RoleDeleted
{
    public Guid Id { get; init; }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleNameChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record RoleNameChanged
{
    public Guid Id { get; init; }
    public string Name { get; init; }
    public string NormalizedName { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\RoleRemoved.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Authorization")]
public record RoleRemoved
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public RoleIdentifier RoleId { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\SecurityStampChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record SecurityStampChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string SecurityStamp { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TokenAggregate.cs ---


using Microsoft.AspNetCore.Identity;
using System.Collections.Immutable;

namespace MicroPlumberd.Service.Identity.Aggregates;

[Aggregate]
public partial class TokenAggregate : AggregateBase<UserIdentifier, TokenAggregate.TokenState>
{
    public TokenAggregate(UserIdentifier id) : base(id) { }

    public record TokenState
    {
        public UserIdentifier Id { get; init; }
        public ImmutableList<TokenRecord> Tokens { get; init; } = ImmutableList<TokenRecord>.Empty;
        
        public bool IsDeleted { get; init; }
    }

    public record TokenRecord
    {
        public TokenName Name { get; init; }
        public TokenValue Value { get; init; }
        public string LoginProvider { get; init; }
    }

    // Event application methods
    private static TokenState Given(TokenState state, TokenAggregateCreated ev)
    {
        
        return new TokenState
        {
            Id = ev.UserId,
            
            IsDeleted = false
        };
    }

    private static TokenState Given(TokenState state, TokenSet ev)
    {
        // Remove existing token with the same name and login provider
        var existingToken = state.Tokens.FirstOrDefault(t =>
            t.Name.Value == ev.Name.Value &&
            t.LoginProvider == ev.LoginProvider);

        var tokens = state.Tokens;

        if (existingToken != null)
        {
            tokens = tokens.Remove(existingToken);
        }

        // Add the new token
        var tokenRecord = new TokenRecord
        {
            Name = ev.Name,
            Value = ev.Value,
            LoginProvider = ev.LoginProvider
        };

        return state with
        {
            Tokens = tokens.Add(tokenRecord),
            
        };
    }

    private static TokenState Given(TokenState state, TokenRemoved ev)
    {
        // Find the token to remove
        var tokenToRemove = state.Tokens.FirstOrDefault(t =>
            t.Name.Value == ev.Name.Value &&
            t.LoginProvider == ev.LoginProvider);

        if (tokenToRemove == null)
            return state;

        return state with
        {
            Tokens = state.Tokens.Remove(tokenToRemove),
            
        };
    }



    private static TokenState Given(TokenState state, TokenAggregateDeleted ev)
    {
        return state with { IsDeleted = true };
    }

    // Command methods
    public static TokenAggregate Create(UserIdentifier id)
    {
        var aggregate = Empty(id);

        aggregate.AppendPendingChange(new TokenAggregateCreated
        {
            UserId = id,
            
        });

        return aggregate;
    }

    public void SetToken(
        TokenName name,
        TokenValue value,
        string loginProvider
        )
    {
        EnsureNotDeleted();
        

        // Validation
        if (string.IsNullOrEmpty(name.Value))
            throw new ArgumentException("Token name cannot be empty", nameof(name));

        if (string.IsNullOrEmpty(value.Value))
            throw new ArgumentException("Token value cannot be empty", nameof(value));

        AppendPendingChange(new TokenSet
        {
            Name = name,
            Value = value,
            LoginProvider = loginProvider ?? string.Empty,
            
        });
    }

    public void RemoveToken(
        TokenName name,
        string loginProvider
        )
    {
        EnsureNotDeleted();
        

        // Check if the token exists
        var tokenExists = State.Tokens.Any(t =>
            t.Name.Value == name.Value &&
            t.LoginProvider == (loginProvider ?? string.Empty));

        if (!tokenExists)
            return; // Token doesn't exist

        AppendPendingChange(new TokenRemoved
        {
            Name = name,
            LoginProvider = loginProvider ?? string.Empty,
            
        });
    }


    public void Delete()
    {
        if (State.IsDeleted)
            return;

        

        AppendPendingChange(new TokenAggregateDeleted());
    }

    // Helper methods
    private void EnsureNotDeleted()
    {
        if (State.IsDeleted)
            throw new InvalidOperationException("Cannot modify tokens of a deleted user");
    }

}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TokenAggregateCreated.cs ---


using System;
using System.Linq;
using System.Threading.Tasks;
using MicroPlumberd;


namespace MicroPlumberd.Service.Identity.Aggregates
{
    // Events with Id initialized directly in the record
    [OutputStream("Token")]
    public record TokenAggregateCreated
    {
        public Guid Id { get; init; } = Guid.NewGuid();
        public UserIdentifier UserId { get; init; }
        
    }
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TokenAggregateDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Token")]
public record TokenAggregateDeleted
{
    public Guid Id { get; init; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TokenRemoved.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Token")]
public record TokenRemoved
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public TokenName Name { get; init; }
    public string LoginProvider { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TokenSet.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Token")]
public record TokenSet
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public TokenName Name { get; init; }
    public TokenValue Value { get; init; }
    public string LoginProvider { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\TwoFactorChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

[OutputStream("Identity")]
public record TwoFactorChanged
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public bool TwoFactorEnabled { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\UserNameChanged.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record UserNameChanged
{
    public Guid Id { get; init; }
    public string UserName { get; init; }
    public string NormalizedUserName { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\UserProfileAggregate.cs ---


using System;
using System.Threading.Tasks;
using MicroPlumberd;

namespace MicroPlumberd.Service.Identity.Aggregates
{
    [Aggregate]
    public partial class UserProfileAggregate : AggregateBase<UserIdentifier, UserProfileAggregate.UserProfileState>
    {
        public UserProfileAggregate(UserIdentifier id) : base(id) { }

        public record UserProfileState
        {
            public UserIdentifier Id { get; init; }
            public string UserName { get; init; }
            public string NormalizedUserName { get; init; }
            public string Email { get; init; }
            public string NormalizedEmail { get; init; }
            public bool EmailConfirmed { get; init; }
            public string PhoneNumber { get; init; }
            public bool PhoneNumberConfirmed { get; init; }
            
            public bool IsDeleted { get; init; }
        }

        // Event application methods
        private static UserProfileState Given(UserProfileState state, UserProfileCreated ev)
        {
            return new UserProfileState
            {
                Id = ev.UserId,
                UserName = ev.UserName,
                NormalizedUserName = ev.NormalizedUserName,
                Email = ev.Email,
                NormalizedEmail = ev.NormalizedEmail,
                EmailConfirmed = false,
                PhoneNumber = ev.PhoneNumber,
                PhoneNumberConfirmed = false,
                
                IsDeleted = false
            };
        }

        private static UserProfileState Given(UserProfileState state, UserNameChanged ev)
        {
            return state with
            {
                UserName = ev.UserName,
                NormalizedUserName = ev.NormalizedUserName,
                
            };
        }

        private static UserProfileState Given(UserProfileState state, EmailChanged ev)
        {
            return state with
            {
                Email = ev.Email,
                NormalizedEmail = ev.NormalizedEmail,
                // Changing email resets confirmation
                EmailConfirmed = false,
                
            };
        }

        private static UserProfileState Given(UserProfileState state, EmailConfirmed ev)
        {
            return state with
            {
                EmailConfirmed = true,
                
            };
        }

        private static UserProfileState Given(UserProfileState state, PhoneNumberChanged ev)
        {
            return state with
            {
                PhoneNumber = ev.PhoneNumber,
                // Changing phone resets confirmation
                PhoneNumberConfirmed = false,
                
            };
        }

        private static UserProfileState Given(UserProfileState state, PhoneNumberConfirmed ev)
        {
            return state with
            {
                PhoneNumberConfirmed = true,
                
            };
        }



        private static UserProfileState Given(UserProfileState state, UserProfileDeleted ev)
        {
            return state with { IsDeleted = true };
        }

        // Command methods
        public static UserProfileAggregate Create(
            UserIdentifier id,
            string userName,
            string normalizedUserName,
            string email,
            string normalizedEmail,
            string phoneNumber)
        {
            var aggregate = Empty(id);

            // Validation
            if (string.IsNullOrWhiteSpace(userName))
                throw new ArgumentException("Username cannot be empty", nameof(userName));

            if (string.IsNullOrWhiteSpace(normalizedUserName))
                throw new ArgumentException("Normalized username cannot be empty", nameof(normalizedUserName));

            if (!string.IsNullOrEmpty(email) && string.IsNullOrEmpty(normalizedEmail))
                throw new ArgumentException("Normalized email must be provided if email is provided", nameof(normalizedEmail));

            // Email format validation could be added here

            aggregate.AppendPendingChange(new UserProfileCreated
            {
                Id = Guid.NewGuid(),
                UserId = id,
                UserName = userName,
                NormalizedUserName = normalizedUserName,
                Email = email,
                NormalizedEmail = normalizedEmail,
                PhoneNumber = phoneNumber,
                
            });

            return aggregate;
        }

        public void ChangeUserName(string userName, string normalizedUserName )
        {
            EnsureNotDeleted();


            // Validation
            if (State.UserName != userName || State.NormalizedUserName != normalizedUserName)
            {
                // Validation
                if (string.IsNullOrWhiteSpace(userName))
                    throw new ArgumentException("Username cannot be empty", nameof(userName));

                if (string.IsNullOrWhiteSpace(normalizedUserName))
                    throw new ArgumentException("Normalized username cannot be empty", nameof(normalizedUserName));

                AppendPendingChange(new UserNameChanged
                {
                    Id = Guid.NewGuid(),
                    UserName = userName,
                    NormalizedUserName = normalizedUserName
                });
            }
        }

        public void ChangeEmail(string email, string normalizedEmail )
        {
            EnsureNotDeleted();


            // Only emit an event if the email has actually changed
            if (State.Email != email || State.NormalizedEmail != normalizedEmail)
            {
                // Validation
                if (!string.IsNullOrEmpty(email) && string.IsNullOrEmpty(normalizedEmail))
                    throw new ArgumentException("Normalized email must be provided if email is provided", nameof(normalizedEmail));

                // Email format validation could be added here

                AppendPendingChange(new EmailChanged
                {
                    Id = Guid.NewGuid(),
                    Email = email,
                    NormalizedEmail = normalizedEmail
                });
                
            }
        }

        public void ConfirmEmail()
        {
            EnsureNotDeleted();


            // Only emit an event if the email is not already confirmed
            if (!State.EmailConfirmed)
            {
                // Validation
                if (string.IsNullOrEmpty(State.Email))
                    throw new InvalidOperationException("Cannot confirm email when no email is set");

                AppendPendingChange(new EmailConfirmed
                {
                    Id = Guid.NewGuid()
                });
            }
        }

        public void ChangePhoneNumber(string phoneNumber )
        {
            EnsureNotDeleted();


            // Only emit an event if the phone number has actually changed
            if (State.PhoneNumber != phoneNumber)
            {
                // Phone number format validation could be added here

                AppendPendingChange(new PhoneNumberChanged
                {
                    Id = Guid.NewGuid(),
                    PhoneNumber = phoneNumber
                });
            }
        }

        public void ConfirmPhoneNumber()
        {
            EnsureNotDeleted();


            // Only emit an event if the phone number is not already confirmed
            if (!State.PhoneNumberConfirmed)
            {
                // Validation
                if (string.IsNullOrEmpty(State.PhoneNumber))
                    throw new InvalidOperationException("Cannot confirm phone number when no phone number is set");

                AppendPendingChange(new PhoneNumberConfirmed
                {
                    Id = Guid.NewGuid()
                });
            }
        }


        public void Delete()
        {
            if (State.IsDeleted)
                return;

            

            AppendPendingChange(new UserProfileDeleted
            {
                Id = Guid.NewGuid()
            });
        }

        // Helper methods
        private void EnsureNotDeleted()
        {
            if (State.IsDeleted)
                throw new InvalidOperationException("Cannot modify a deleted user profile");
        }


    }


}


// --- File: MicroPlumberd.Service.Identity\Aggregates\UserProfileCreated.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record UserProfileCreated
{
    public Guid Id { get; init; }
    public UserIdentifier UserId { get; init; }
    public string UserName { get; init; }
    public string NormalizedUserName { get; init; }
    public string Email { get; init; }
    public string NormalizedEmail { get; init; }
    public string PhoneNumber { get; init; }
    
}


// --- File: MicroPlumberd.Service.Identity\Aggregates\UserProfileDeleted.cs ---


namespace MicroPlumberd.Service.Identity.Aggregates;

public record UserProfileDeleted
{
    public Guid Id { get; init; }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\AuthenticationModel.cs ---


using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;


namespace MicroPlumberd.Service.Identity.ReadModels
{
    [EventHandler]
    [OutputStream("AuthenticationModel_v1")]
    public partial class AuthenticationModel
    {
        private readonly ConcurrentDictionary<UserIdentifier, AuthenticationData> _authDataByUserId = new();

        public record AuthenticationData
        {
            public string PasswordHash { get; init; }
            public string SecurityStamp { get; init; }
            public bool TwoFactorEnabled { get; init; }
            public string AuthenticatorKey { get; init; }
            public int AccessFailedCount { get; init; }
            public bool LockoutEnabled { get; init; }
            public DateTimeOffset? LockoutEnd { get; init; }
        }

        private async Task Given(Metadata m, IdentityUserCreated ev)
        {
            _authDataByUserId[ev.UserId] = new AuthenticationData
            {
                PasswordHash = ev.PasswordHash,
                SecurityStamp = ev.SecurityStamp,
                TwoFactorEnabled = false,
                AuthenticatorKey = null,
                AccessFailedCount = 0,
                LockoutEnabled = ev.LockoutEnabled,
                LockoutEnd = null
            };

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PasswordChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    PasswordHash = ev.PasswordHash,
                    SecurityStamp = ev.SecurityStamp
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, SecurityStampChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    SecurityStamp = ev.SecurityStamp
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, TwoFactorChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                var newData = data with
                {
                    TwoFactorEnabled = ev.TwoFactorEnabled
                };

                // If disabling 2FA, clear the authenticator key
                if (!ev.TwoFactorEnabled)
                {
                    newData = newData with { AuthenticatorKey = null };
                }

                _authDataByUserId[userId] = newData;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, AuthenticatorKeyChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    AuthenticatorKey = ev.AuthenticatorKey
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, AccessFailedCountChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    AccessFailedCount = ev.AccessFailedCount
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, LockoutEnabledChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    LockoutEnabled = ev.LockoutEnabled
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, LockoutEndChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var data))
            {
                _authDataByUserId[userId] = data with
                {
                    LockoutEnd = ev.LockoutEnd
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, IdentityUserDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);
            _authDataByUserId.TryRemove(userId, out _);

            await Task.CompletedTask;
        }

        // Query method
        public AuthenticationData GetAuthenticationData(UserIdentifier userId)
        {
            _authDataByUserId.TryGetValue(userId, out var data);
            return data;
        }
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\ExternalLoginModel.cs ---


using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;


namespace MicroPlumberd.Service.Identity.ReadModels
{
    [EventHandler]
    [OutputStream("ExternalLoginModel_v1")]
    public partial class ExternalLoginModel
    {
        private readonly ConcurrentDictionary<UserIdentifier, ImmutableList<ExternalLoginInfo>> _loginsByUserId = new();
        private readonly ConcurrentDictionary<string, UserIdentifier> _userIdsByLogin = new();

        public record ExternalLoginInfo
        {
            public string ProviderName { get; init; }
            public string ProviderKey { get; init; }
            public string DisplayName { get; init; }
        }

        private async Task Given(Metadata m, ExternalLoginAggregateCreated ev)
        {
            _loginsByUserId[ev.UserId] = ImmutableList<ExternalLoginInfo>.Empty;
            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ExternalLoginAdded ev)
        {
            var userId = new UserIdentifier(m.Id);

            // Add to user's logins
            if (_loginsByUserId.TryGetValue(userId, out var logins))
            {
                var loginInfo = new ExternalLoginInfo
                {
                    ProviderName = ev.Provider.Name,
                    ProviderKey = ev.ProviderKey.Value,
                    DisplayName = ev.DisplayName ?? string.Empty
                };

                _loginsByUserId[userId] = logins.Add(loginInfo);
            }

            // Add to login lookup
            var lookupKey = GetLookupKey(ev.Provider.Name, ev.ProviderKey.Value);
            _userIdsByLogin[lookupKey] = userId;

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ExternalLoginRemoved ev)
        {
            var userId = new UserIdentifier(m.Id);

            // Remove from user's logins
            if (_loginsByUserId.TryGetValue(userId, out var logins))
            {
                var loginToRemove = logins.FirstOrDefault(l =>
                    l.ProviderName == ev.Provider.Name &&
                    l.ProviderKey == ev.ProviderKey.Value);

                if (loginToRemove != null)
                {
                    _loginsByUserId[userId] = logins.Remove(loginToRemove);
                }
            }

            // Remove from login lookup
            var lookupKey = GetLookupKey(ev.Provider.Name, ev.ProviderKey.Value);
            _userIdsByLogin.TryRemove(lookupKey, out _);

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ExternalLoginAggregateDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_loginsByUserId.TryRemove(userId, out var logins))
            {
                // Remove all lookups for this user
                foreach (var login in logins)
                {
                    var lookupKey = GetLookupKey(login.ProviderName, login.ProviderKey);
                    _userIdsByLogin.TryRemove(lookupKey, out _);
                }
            }

            await Task.CompletedTask;
        }

        // Query methods
        public ImmutableList<ExternalLoginInfo> GetLoginsForUser(UserIdentifier userId)
        {
            if (_loginsByUserId.TryGetValue(userId, out var logins))
            {
                return logins;
            }

            return ImmutableList<ExternalLoginInfo>.Empty;
        }

        public UserIdentifier FindUserIdByLogin(string providerName, string providerKey)
        {
            var lookupKey = GetLookupKey(providerName, providerKey);

            _userIdsByLogin.TryGetValue(lookupKey, out var userId);
            return userId;
        }

        // Helper method for lookup key
        private string GetLookupKey(string providerName, string providerKey)
        {
            return $"{providerName}|{providerKey}";
        }
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\RoleByIdModel.cs ---


using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;

namespace MicroPlumberd.Service.Identity.ReadModels
{
    /// <summary>
    /// Consolidated read model for roles with direct references in lookups
    /// </summary>
    [EventHandler]
    [OutputStream("RolesModel_v1")]
    public partial class RolesModel
    {
        // Primary collection - clustered index
        private readonly ConcurrentDictionary<RoleIdentifier, Role> _rolesById = new();

        // Lookup dictionary - direct references to the same Role objects
        private readonly ConcurrentDictionary<string, Role> _rolesByNormalizedName = new();

        // Returns all roles (for IQueryable interface)
        public ImmutableList<Role> GetAllRoles() => _rolesById.Values.ToImmutableList();

        #region Event Handlers

        private async Task Given(Metadata m, RoleCreated ev)
        {
            // Create a new role object
            var role = new Role
            {
                Id = ev.RoleId.ToString(),
                Name = ev.Name,
                NormalizedName = ev.NormalizedName
            };

            // Add to primary collection
            if (_rolesById.TryAdd(ev.RoleId, role))
            {
                // Add to lookup - same reference
                if (!string.IsNullOrEmpty(ev.NormalizedName))
                {
                    _rolesByNormalizedName.TryAdd(ev.NormalizedName, role);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleNameChanged ev)
        {
            var roleId = new RoleIdentifier(m.Id);

            if (_rolesById.TryGetValue(roleId, out var role))
            {
                // Remove from old lookup
                if (!string.IsNullOrEmpty(role.NormalizedName))
                {
                    _rolesByNormalizedName.TryRemove(role.NormalizedName, out _);
                }

                // Update the role
                role.Name = ev.Name;
                role.NormalizedName = ev.NormalizedName;

                // Add to lookup with updated normalized name - same reference
                if (!string.IsNullOrEmpty(ev.NormalizedName))
                {
                    _rolesByNormalizedName.TryAdd(ev.NormalizedName, role);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleDeleted ev)
        {
            var roleId = new RoleIdentifier(m.Id);

            // Remove from primary collection
            if (_rolesById.TryRemove(roleId, out var role))
            {
                // Remove from lookup
                if (!string.IsNullOrEmpty(role.NormalizedName))
                {
                    _rolesByNormalizedName.TryRemove(role.NormalizedName, out _);
                }
            }

            await Task.CompletedTask;
        }

        #endregion

        #region Query Methods

        /// <summary>
        /// Gets a role by ID
        /// </summary>
        public Role GetById(RoleIdentifier id)
        {
            _rolesById.TryGetValue(id, out var role);
            return role;
        }

        /// <summary>
        /// Gets a role by normalized name
        /// </summary>
        public Role GetByNormalizedName(string normalizedName)
        {
            if (string.IsNullOrEmpty(normalizedName))
                return null;

            _rolesByNormalizedName.TryGetValue(normalizedName, out var role);
            return role;
        }

        /// <summary>
        /// Gets a role ID by normalized name
        /// </summary>
        public RoleIdentifier GetIdByNormalizedName(string normalizedName)
        {
            var role = GetByNormalizedName(normalizedName);
            return role != null ? GetRoleIdentifier(role.Id) : default;
        }

        #endregion

        #region Helper Methods

        private RoleIdentifier GetRoleIdentifier(string roleId)
        {
            return RoleIdentifier.Parse(roleId, null);
        }

        #endregion
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\TokenModel.cs ---


using System.Collections.Concurrent;
using System.Linq;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;


namespace MicroPlumberd.Service.Identity.ReadModels
{
    [EventHandler]
    [OutputStream("TokenModel_v1")]
    public partial class TokenModel
    {
        private readonly ConcurrentDictionary<UserIdentifier, ConcurrentDictionary<string, string>> _tokensByUserId = new();

        private async Task Given(Metadata m, TokenAggregateCreated ev)
        {
            _tokensByUserId[ev.UserId] = new ConcurrentDictionary<string, string>();
            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, TokenSet ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_tokensByUserId.TryGetValue(userId, out var userTokens))
            {
                var lookupKey = GetLookupKey(ev.Name.Value, ev.LoginProvider);
                userTokens[lookupKey] = ev.Value.Value;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, TokenRemoved ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_tokensByUserId.TryGetValue(userId, out var userTokens))
            {
                var lookupKey = GetLookupKey(ev.Name.Value, ev.LoginProvider);
                userTokens.TryRemove(lookupKey, out _);
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, TokenAggregateDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);
            _tokensByUserId.TryRemove(userId, out _);

            await Task.CompletedTask;
        }

        // Query methods
        public string GetToken(UserIdentifier userId, string name, string loginProvider)
        {
            if (_tokensByUserId.TryGetValue(userId, out var userTokens))
            {
                var lookupKey = GetLookupKey(name, loginProvider);
                userTokens.TryGetValue(lookupKey, out var token);
                return token;
            }

            return null;
        }

        // Helper method for lookup key
        private string GetLookupKey(string name, string loginProvider)
        {
            return $"{loginProvider ?? string.Empty}|{name}";
        }
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\UserAuthorizationModel.cs ---


using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Collections;
using MicroPlumberd.Service.Identity.Aggregates;

namespace MicroPlumberd.Service.Identity.ReadModels
{
    [EventHandler]
    [OutputStream("UserAuthorizationModel_v1")]
    public partial class UserAuthorizationModel
    {
        private readonly ConcurrentDictionary<UserIdentifier, UserAuthData> _authDataByUserId = new();
        private readonly ConcurrentDictionary<RoleIdentifier, RoleData> _roleData = new();
        private readonly RolesModel _rolesModel;

        public UserAuthorizationModel(RolesModel rolesModel)
        {
            _rolesModel = rolesModel ?? throw new ArgumentNullException(nameof(rolesModel));
        }

        public record RoleData
        {
            public RoleIdentifier Id { get; init; }
            public string Name { get; init; }
            public ConcurrentHashSet<UserIdentifier> Users { get; } = new();
        }

        public record UserAuthData
        {
            public UserIdentifier Id { get; init; }
            public ImmutableList<RoleData> Roles { get; init; } = ImmutableList<RoleData>.Empty;
            public ImmutableList<Claim> Claims { get; init; } = ImmutableList<Claim>.Empty;
        }

        #region Authorization User Events

        private async Task Given(Metadata m, AuthorizationUserCreated ev)
        {
            _authDataByUserId[ev.UserId] = new UserAuthData
            {
                Id = ev.UserId
            };

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleAdded ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                // Get or create role data
                var roleData = _roleData.GetOrAdd(ev.RoleId, id =>
                {
                    var role = _rolesModel.GetById(id);
                    return new RoleData
                    {
                        Id = id,
                        Name = role?.Name ?? string.Empty
                    };
                });

                // Only add if not already present
                bool roleExists = authData.Roles.Any(r => r.Id.Equals(ev.RoleId));

                if (!roleExists)
                {
                    // Update roles for user
                    _authDataByUserId[userId] = authData with
                    {
                        Roles = authData.Roles.Add(roleData)
                    };

                    // Add user to role's user collection
                    roleData.Users.Add(userId);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleRemoved ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                // Find the role
                var roleToRemove = authData.Roles.FirstOrDefault(r => r.Id.Equals(ev.RoleId));

                if (roleToRemove != null)
                {
                    // Update roles for user
                    _authDataByUserId[userId] = authData with
                    {
                        Roles = authData.Roles.Remove(roleToRemove)
                    };

                    // Remove user from role's user collection
                    if (_roleData.TryGetValue(ev.RoleId, out var roleData))
                    {
                        roleData.Users.TryRemove(userId);
                    }
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ClaimAdded ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                var newClaim = new Claim(ev.ClaimType.Value, ev.ClaimValue.Value);

                // Check if claim already exists
                bool claimExists = authData.Claims.Any(c =>
                    c.Type == ev.ClaimType.Value &&
                    c.Value == ev.ClaimValue.Value);

                if (!claimExists)
                {
                    _authDataByUserId[userId] = authData with
                    {
                        Claims = authData.Claims.Add(newClaim)
                    };
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ClaimRemoved ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                // Find claims to remove
                var claimsToRemove = authData.Claims
                    .Where(c =>
                        c.Type == ev.ClaimType.Value &&
                        c.Value == ev.ClaimValue.Value)
                    .ToList();

                if (claimsToRemove.Any())
                {
                    var newClaims = authData.Claims;
                    foreach (var claim in claimsToRemove)
                    {
                        newClaims = newClaims.Remove(claim);
                    }

                    _authDataByUserId[userId] = authData with
                    {
                        Claims = newClaims
                    };
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ClaimsReplaced ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                _authDataByUserId[userId] = authData with
                {
                    Claims = ev.Claims.ToImmutableList()
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, AuthorizationUserDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_authDataByUserId.TryRemove(userId, out var authData))
            {
                // Remove user from all roles
                foreach (var roleData in authData.Roles)
                {
                    roleData.Users.TryRemove(userId);
                }
            }

            await Task.CompletedTask;
        }

        #endregion

        #region Role Events

        private async Task Given(Metadata m, RoleCreated ev)
        {
            // Add or update role data
            _roleData.AddOrUpdate(
                ev.RoleId,
                new RoleData { Id = ev.RoleId, Name = ev.Name },
                (_, existing) => existing with { Name = ev.Name }
            );

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleNameChanged ev)
        {
            var roleId = new RoleIdentifier(m.Id);

            // Update role data
            if (_roleData.TryGetValue(roleId, out var roleData))
            {
                // Create new role data with updated name
                var updatedRoleData = new RoleData
                {
                    Id = roleId,
                    Name = ev.Name
                };

                // Copy users from old role data
                foreach (var userId in roleData.Users)
                {
                    updatedRoleData.Users.Add(userId);
                }

                // Replace role data
                _roleData[roleId] = updatedRoleData;

                // Update role name in all user auth data that contains this role
                foreach (var userId in roleData.Users)
                {
                    if (_authDataByUserId.TryGetValue(userId, out var userData))
                    {
                        // Find and replace the role
                        var roleIndex = userData.Roles.FindIndex(r => r.Id.Equals(roleId));
                        if (roleIndex >= 0)
                        {
                            var newRoles = userData.Roles.RemoveAt(roleIndex).Add(updatedRoleData);
                            _authDataByUserId[userId] = userData with { Roles = newRoles };
                        }
                    }
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, RoleDeleted ev)
        {
            var roleId = new RoleIdentifier(m.Id);

            // Remove role from all users
            if (_roleData.TryRemove(roleId, out var roleData))
            {
                foreach (var userId in roleData.Users)
                {
                    if (_authDataByUserId.TryGetValue(userId, out var userData))
                    {
                        // Find the role
                        var roleToRemove = userData.Roles.FirstOrDefault(r => r.Id.Equals(roleId));
                        if (roleToRemove != null)
                        {
                            // Update roles for user
                            _authDataByUserId[userId] = userData with
                            {
                                Roles = userData.Roles.Remove(roleToRemove)
                            };
                        }
                    }
                }
            }

            await Task.CompletedTask;
        }

        #endregion

        #region Query Methods
        /// <summary>
        /// Checks if a user is in a role by role name
        /// </summary>
        public bool IsInRole(UserIdentifier userId, string normalizedRoleName)
        {
            if (_authDataByUserId.TryGetValue(userId, out var authData))
            {
                return authData.Roles.Any(r =>
                    string.Equals(r.Name, normalizedRoleName, StringComparison.OrdinalIgnoreCase) ||
                    (r.Name != null && string.Equals(r.Name.ToUpperInvariant(), normalizedRoleName, StringComparison.Ordinal)));
            }

            return false;
        }

        /// <summary>
        /// Gets authorization data for a user
        /// </summary>
        public UserAuthData GetById(UserIdentifier id)
        {
            _authDataByUserId.TryGetValue(id, out var authData);
            return authData;
        }

        /// <summary>
        /// Gets all users in a role
        /// </summary>
        public ImmutableList<UserIdentifier> GetUsersInRole(RoleIdentifier roleId)
        {
            if (_roleData.TryGetValue(roleId, out var roleData))
            {
                return roleData.Users.ToImmutableList();
            }

            return ImmutableList<UserIdentifier>.Empty;
        }

        /// <summary>
        /// Gets all users with a specific role name
        /// </summary>
        public ImmutableList<UserIdentifier> GetUsersInRole(string normalizedRoleName)
        {
            var role = _rolesModel.GetByNormalizedName(normalizedRoleName);
            if (role != null)
            {
                var roleId = RoleIdentifier.Parse(role.Id, null);
                return GetUsersInRole(roleId);
            }

            return ImmutableList<UserIdentifier>.Empty;
        }

        /// <summary>
        /// Gets all claims for a user
        /// </summary>
        public ImmutableList<Claim> GetClaims(UserIdentifier id)
        {
            if (_authDataByUserId.TryGetValue(id, out var authData))
            {
                return authData.Claims;
            }

            return ImmutableList<Claim>.Empty;
        }

        /// <summary>
        /// Gets all role names for a user
        /// </summary>
        public ImmutableList<string> GetRoleNames(UserIdentifier id)
        {
            if (_authDataByUserId.TryGetValue(id, out var authData))
            {
                return authData.Roles.Select(r => r.Name).ToImmutableList();
            }

            return ImmutableList<string>.Empty;
        }

        /// <summary>
        /// Checks if a user is in a role
        /// </summary>
        public bool IsInRole(UserIdentifier id, RoleIdentifier roleId)
        {
            if (_authDataByUserId.TryGetValue(id, out var authData))
            {
                return authData.Roles.Any(r => r.Id.Equals(roleId));
            }

            return false;
        }

        #endregion
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\UserProfileModel.cs ---


using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;


namespace MicroPlumberd.Service.Identity.ReadModels
{
    [EventHandler]
    [OutputStream("UserProfileModel_v1")]
    public partial class UserProfileModel
    {
        private readonly ConcurrentDictionary<UserIdentifier, ProfileData> _profilesById = new();
        private readonly ConcurrentDictionary<string, UserIdentifier> _userIdsByNormalizedName = new();
        private readonly ConcurrentDictionary<string, UserIdentifier> _userIdsByNormalizedEmail = new();

        public record ProfileData
        {
            public UserIdentifier Id { get; init; }
            public string UserName { get; init; }
            public string NormalizedUserName { get; init; }
            public string Email { get; init; }
            public string NormalizedEmail { get; init; }
            public bool EmailConfirmed { get; init; }
            public string PhoneNumber { get; init; }
            public bool PhoneNumberConfirmed { get; init; }
            
        }

        private async Task Given(Metadata m, UserProfileCreated ev)
        {
            var profile = new ProfileData
            {
                Id = ev.UserId,
                UserName = ev.UserName,
                NormalizedUserName = ev.NormalizedUserName,
                Email = ev.Email,
                NormalizedEmail = ev.NormalizedEmail,
                EmailConfirmed = false,
                PhoneNumber = ev.PhoneNumber,
                PhoneNumberConfirmed = false,
                
            };

            _profilesById[ev.UserId] = profile;
            _userIdsByNormalizedName[ev.NormalizedUserName] = ev.UserId;

            if (!string.IsNullOrEmpty(ev.NormalizedEmail))
            {
                _userIdsByNormalizedEmail[ev.NormalizedEmail] = ev.UserId;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, UserNameChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryGetValue(userId, out var profile))
            {
                // Remove old normalized name mapping
                _userIdsByNormalizedName.TryRemove(profile.NormalizedUserName, out _);

                // Update profile
                var updatedProfile = profile with
                {
                    UserName = ev.UserName,
                    NormalizedUserName = ev.NormalizedUserName,
                    
                };

                _profilesById[userId] = updatedProfile;
                _userIdsByNormalizedName[ev.NormalizedUserName] = userId;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, EmailChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryGetValue(userId, out var profile))
            {
                // Remove old normalized email mapping
                if (!string.IsNullOrEmpty(profile.NormalizedEmail))
                {
                    _userIdsByNormalizedEmail.TryRemove(profile.NormalizedEmail, out _);
                }

                // Update profile
                var updatedProfile = profile with
                {
                    Email = ev.Email,
                    NormalizedEmail = ev.NormalizedEmail,
                    EmailConfirmed = false,
                    
                };

                _profilesById[userId] = updatedProfile;

                // Add new normalized email mapping
                if (!string.IsNullOrEmpty(ev.NormalizedEmail))
                {
                    _userIdsByNormalizedEmail[ev.NormalizedEmail] = userId;
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, EmailConfirmed ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryGetValue(userId, out var profile))
            {
                _profilesById[userId] = profile with
                {
                    EmailConfirmed = true,
                    
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PhoneNumberChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryGetValue(userId, out var profile))
            {
                _profilesById[userId] = profile with
                {
                    PhoneNumber = ev.PhoneNumber,
                    PhoneNumberConfirmed = false,
                    
                };
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PhoneNumberConfirmed ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryGetValue(userId, out var profile))
            {
                _profilesById[userId] = profile with
                {
                    PhoneNumberConfirmed = true,
                    
                };
            }

            await Task.CompletedTask;
        }


        private async Task Given(Metadata m, UserProfileDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_profilesById.TryRemove(userId, out var profile))
            {
                _userIdsByNormalizedName.TryRemove(profile.NormalizedUserName, out _);

                if (!string.IsNullOrEmpty(profile.NormalizedEmail))
                {
                    _userIdsByNormalizedEmail.TryRemove(profile.NormalizedEmail, out _);
                }
            }

            await Task.CompletedTask;
        }

        // Query methods
        public ProfileData GetById(UserIdentifier id)
        {
            _profilesById.TryGetValue(id, out var profile);
            return profile;
        }

        public UserIdentifier GetIdByNormalizedUserName(string normalizedUserName)
        {
            _userIdsByNormalizedName.TryGetValue(normalizedUserName, out var id);
            return id;
        }

        public UserIdentifier GetIdByNormalizedEmail(string normalizedEmail)
        {
            _userIdsByNormalizedEmail.TryGetValue(normalizedEmail, out var id);
            return id;
        }

        public ImmutableList<ProfileData> GetAllProfiles()
        {
            return _profilesById.Values.ToImmutableList();
        }
    }
}


// --- File: MicroPlumberd.Service.Identity\ReadModels\UsersModel.cs ---


using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Threading.Tasks;
using MicroPlumberd;
using MicroPlumberd.Service.Identity.Aggregates;

namespace MicroPlumberd.Service.Identity.ReadModels
{
    /// <summary>
    /// Consolidated read model for users with multiple lookup dictionaries
    /// </summary>
    [EventHandler]
    [OutputStream("UsersModel_v1")]
    public partial class UsersModel
    {
        // Primary collection - clustered index
        private readonly ConcurrentDictionary<UserIdentifier, User> _usersById = new();

        // Lookup dictionaries - direct references to the same User objects
        private readonly ConcurrentDictionary<string, User> _usersByNormalizedName = new();
        private readonly ConcurrentDictionary<string, User> _usersByNormalizedEmail = new();
        private readonly ConcurrentDictionary<string, User> _usersByExternalLogin = new();

        // Returns all users (for IQueryable interface)
        public ImmutableList<User> GetAllUsers() => _usersById.Values.ToImmutableList();

        #region Event Handlers

        private async Task Given(Metadata m, UserProfileCreated ev)
        {
            // Create a new user object
            var user = new User
            {
                Id = ev.UserId.ToString(),
                UserName = ev.UserName,
                NormalizedUserName = ev.NormalizedUserName,
                Email = ev.Email,
                NormalizedEmail = ev.NormalizedEmail,
                EmailConfirmed = false,
                PhoneNumber = ev.PhoneNumber,
                PhoneNumberConfirmed = false
            };

            // Add to primary collection
            if (_usersById.TryAdd(ev.UserId, user))
            {
                // Add to lookups - same reference
                if (!string.IsNullOrEmpty(ev.NormalizedUserName))
                {
                    _usersByNormalizedName.TryAdd(ev.NormalizedUserName, user);
                }

                if (!string.IsNullOrEmpty(ev.NormalizedEmail))
                {
                    _usersByNormalizedEmail.TryAdd(ev.NormalizedEmail, user);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, IdentityUserCreated ev)
        {
            if (_usersById.TryGetValue(ev.UserId, out var user))
            {
                user.PasswordHash = ev.PasswordHash;
                user.SecurityStamp = ev.SecurityStamp;
                user.LockoutEnabled = ev.LockoutEnabled;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, UserNameChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                // Remove from old lookup
                if (!string.IsNullOrEmpty(user.NormalizedUserName))
                {
                    _usersByNormalizedName.TryRemove(user.NormalizedUserName, out _);
                }

                // Update the user
                user.UserName = ev.UserName;
                user.NormalizedUserName = ev.NormalizedUserName;

                // Add to lookup with updated normalized name
                if (!string.IsNullOrEmpty(ev.NormalizedUserName))
                {
                    _usersByNormalizedName.TryAdd(ev.NormalizedUserName, user);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, EmailChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                // Remove from old lookup
                if (!string.IsNullOrEmpty(user.NormalizedEmail))
                {
                    _usersByNormalizedEmail.TryRemove(user.NormalizedEmail, out _);
                }

                // Update the user
                user.Email = ev.Email;
                user.NormalizedEmail = ev.NormalizedEmail;
                user.EmailConfirmed = false; // Reset confirmation on email change

                // Add to lookup with updated normalized email
                if (!string.IsNullOrEmpty(ev.NormalizedEmail))
                {
                    _usersByNormalizedEmail.TryAdd(ev.NormalizedEmail, user);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, EmailConfirmed ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.EmailConfirmed = true;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PhoneNumberChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.PhoneNumber = ev.PhoneNumber;
                user.PhoneNumberConfirmed = false; // Reset confirmation on phone change
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PhoneNumberConfirmed ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.PhoneNumberConfirmed = true;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, PasswordChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.PasswordHash = ev.PasswordHash;
                user.SecurityStamp = ev.SecurityStamp;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, SecurityStampChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.SecurityStamp = ev.SecurityStamp;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, TwoFactorChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.TwoFactorEnabled = ev.TwoFactorEnabled;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, LockoutEnabledChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.LockoutEnabled = ev.LockoutEnabled;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, LockoutEndChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.LockoutEnd = ev.LockoutEnd;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, AccessFailedCountChanged ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                user.AccessFailedCount = ev.AccessFailedCount;
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ExternalLoginAdded ev)
        {
            var userId = new UserIdentifier(m.Id);

            if (_usersById.TryGetValue(userId, out var user))
            {
                // Create a composite key for the external login
                string loginKey = GetExternalLoginKey(ev.Provider.Name, ev.ProviderKey.Value);

                // Add to lookup - same reference to the user
                _usersByExternalLogin.TryAdd(loginKey, user);
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, ExternalLoginRemoved ev)
        {
            // Create a composite key for the external login
            string loginKey = GetExternalLoginKey(ev.Provider.Name, ev.ProviderKey.Value);

            // Remove from lookup
            _usersByExternalLogin.TryRemove(loginKey, out _);

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, UserProfileDeleted ev)
        {
            var userId = new UserIdentifier(m.Id);

            // Remove from primary collection
            if (_usersById.TryRemove(userId, out var user))
            {
                // Remove from lookups
                if (!string.IsNullOrEmpty(user.NormalizedUserName))
                {
                    _usersByNormalizedName.TryRemove(user.NormalizedUserName, out _);
                }

                if (!string.IsNullOrEmpty(user.NormalizedEmail))
                {
                    _usersByNormalizedEmail.TryRemove(user.NormalizedEmail, out _);
                }

                // Remove all external login entries - need to scan
                foreach (var loginKey in _usersByExternalLogin.Where(kvp => ReferenceEquals(kvp.Value, user))
                    .Select(kvp => kvp.Key).ToList())
                {
                    _usersByExternalLogin.TryRemove(loginKey, out _);
                }
            }

            await Task.CompletedTask;
        }

        private async Task Given(Metadata m, IdentityUserDeleted ev)
        {
            // User is already handled in UserProfileDeleted
            await Task.CompletedTask;
        }

        #endregion

        #region Query Methods

        /// <summary>
        /// Gets a user by ID
        /// </summary>
        public User GetById(UserIdentifier id)
        {
            _usersById.TryGetValue(id, out var user);
            return user;
        }

        /// <summary>
        /// Gets a user by normalized username
        /// </summary>
        public User GetByNormalizedUserName(string normalizedUserName)
        {
            if (string.IsNullOrEmpty(normalizedUserName))
                return null;

            _usersByNormalizedName.TryGetValue(normalizedUserName, out var user);
            return user;
        }

        /// <summary>
        /// Gets a user by normalized email
        /// </summary>
        public User GetByNormalizedEmail(string normalizedEmail)
        {
            if (string.IsNullOrEmpty(normalizedEmail))
                return null;

            _usersByNormalizedEmail.TryGetValue(normalizedEmail, out var user);
            return user;
        }

        /// <summary>
        /// Gets a user by external login provider and key
        /// </summary>
        public User GetByExternalLogin(string loginProvider, string providerKey)
        {
            if (string.IsNullOrEmpty(loginProvider) || string.IsNullOrEmpty(providerKey))
                return null;

            string loginKey = GetExternalLoginKey(loginProvider, providerKey);

            _usersByExternalLogin.TryGetValue(loginKey, out var user);
            return user;
        }

        /// <summary>
        /// Gets a user ID by normalized username
        /// </summary>
        public UserIdentifier GetIdByNormalizedUserName(string normalizedUserName)
        {
            var user = GetByNormalizedUserName(normalizedUserName);
            return user != null ? GetUserIdentifier(user.Id) : default;
        }

        /// <summary>
        /// Gets a user ID by normalized email
        /// </summary>
        public UserIdentifier GetIdByNormalizedEmail(string normalizedEmail)
        {
            var user = GetByNormalizedEmail(normalizedEmail);
            return user != null ? GetUserIdentifier(user.Id) : default;
        }

        /// <summary>
        /// Gets a user ID by external login provider and key
        /// </summary>
        public UserIdentifier GetIdByExternalLogin(string loginProvider, string providerKey)
        {
            var user = GetByExternalLogin(loginProvider, providerKey);
            return user != null ? GetUserIdentifier(user.Id) : default;
        }

        #endregion

        #region Helper Methods

        private string GetExternalLoginKey(string providerName, string providerKey)
        {
            return $"{providerName}|{providerKey}";
        }

        private UserIdentifier GetUserIdentifier(string userId)
        {
            return UserIdentifier.Parse(userId, null);
        }

        #endregion
    }
}


// --- File: MicroPlumberd.Service.Identity\ClaimType.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Identity;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Represents a user in the identity system
/// </summary>
public class User : IdentityUser
{
    // Additional properties can be added here if needed
    // This class inherits all the standard properties from IdentityUser
}

/// <summary>
/// Represents a role in the identity system
/// </summary>
public class Role : IdentityRole
{
    // Additional properties can be added here if needed
    // This class inherits all the standard properties from IdentityRole
}
/// <summary>
/// Represents a claim type
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<ClaimType>))]
public readonly record struct ClaimType : IParsable<ClaimType>, IComparable<ClaimType>
{
    public string Value { get; }

    public ClaimType(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Claim type cannot be empty", nameof(value));

        Value = value.ToLowerInvariant();
    }

    public override string ToString() => Value;

    // Common claim types
    public static ClaimType Name => new("name");
    public static ClaimType Role => new("role");
    public static ClaimType Email => new("email");
    public static ClaimType Parse(string s, IFormatProvider? provider)
    {
        return new ClaimType(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out ClaimType result)
    {
        result = new ClaimType(s);
        return true;
    }

    public int CompareTo(ClaimType other)
    {
        return string.Compare(Value, other.Value, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\ClaimValue.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Represents a claim value
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<ClaimValue>))]
public readonly record struct ClaimValue : IParsable<ClaimValue>, IComparable<ClaimValue>
{
    public string Value { get; }

    public ClaimValue(string value)
    {
        if (value == null)
            throw new ArgumentNullException(nameof(value));

        Value = value.ToLowerInvariant();
    }

    public override string ToString() => Value;
    public static ClaimValue Parse(string s, IFormatProvider? provider)
    {
        return new ClaimValue(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out ClaimValue result)
    {
        result = new ClaimValue(s);
        return true;
    }

    public int CompareTo(ClaimValue other)
    {
        return string.Compare(Value, other.Value, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\ContainerExtensions.cs ---


using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MicroPlumberd.Service.Identity.ReadModels;
using MicroPlumberd.Services;
using Microsoft.AspNetCore.Identity;
using Microsoft.Extensions.DependencyInjection;
using static MicroPlumberd.Service.Identity.Aggregates.RoleAggregate;

namespace MicroPlumberd.Service.Identity
{
    public static class ContainerExtensions
    {
        public static IServiceCollection AddPlumberdIdentity(this IServiceCollection container)
        {
            container.AddSingleton<UsersModel>();
            container.AddSingleton<RolesModel>();
            
            container.AddSingleton<AuthenticationModel>();
            container.AddSingleton<UserProfileModel>();
            container.AddSingleton<UserAuthorizationModel>();
            container.AddSingleton<ExternalLoginModel>();
            container.AddSingleton<TokenModel>();
            

            // Register event handlers for read models
            container.AddEventHandler<UsersModel>();
            container.AddEventHandler<RolesModel>();
            container.AddEventHandler<AuthenticationModel>();
            container.AddEventHandler<UserProfileModel>();
            container.AddEventHandler<UserAuthorizationModel>();
            container.AddEventHandler<ExternalLoginModel>();
            container.AddEventHandler<TokenModel>();
            

            // Register stores
            return container;

        }
    }
}



// --- File: MicroPlumberd.Service.Identity\ExternalLoginKey.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Identifies a user within an external provider
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<ExternalLoginKey>))]
public readonly record struct ExternalLoginKey : IParsable<ExternalLoginKey>, IComparable<ExternalLoginKey>
{
    public string Value { get; }

    public ExternalLoginKey(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("External login key cannot be empty", nameof(value));

        Value = value.ToLowerInvariant();
    }

    public override string ToString() => Value;
    public static ExternalLoginKey Parse(string s, IFormatProvider? provider)
    {
        return new ExternalLoginKey(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out ExternalLoginKey result)
    {
        result = new ExternalLoginKey(s);
        return true;
    }

    public int CompareTo(ExternalLoginKey other)
    {
        return string.Compare(Value, other.Value, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\ExternalLoginProvider.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Identifies an external login provider
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<ExternalLoginProvider>))]
public readonly record struct ExternalLoginProvider : IParsable<ExternalLoginProvider>, IComparable<ExternalLoginProvider>
{
    public string Name { get; }

    public ExternalLoginProvider(string name)
    {
        if (string.IsNullOrWhiteSpace(name))
            throw new ArgumentException("Provider name cannot be empty", nameof(name));

        Name = name.ToLowerInvariant();
    }

        

    public override string ToString() => Name;

    // Common providers
    public static ExternalLoginProvider Google => new("Google");
    public static ExternalLoginProvider Microsoft => new("Microsoft");
    public static ExternalLoginProvider Facebook => new("Facebook");
    public static ExternalLoginProvider Twitter => new("Twitter");
    public static ExternalLoginProvider Parse(string s, IFormatProvider? provider)
    {
        return new ExternalLoginProvider(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out ExternalLoginProvider result)
    {
        result = new ExternalLoginProvider(s);
        return true;
    }

    public int CompareTo(ExternalLoginProvider other)
    {
        return string.Compare(Name, other.Name, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\RoleIdentifier.cs ---


using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Uniquely identifies a role
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<RoleIdentifier>))]
public readonly record struct RoleIdentifier : IParsable<RoleIdentifier> , IComparable<RoleIdentifier>
{
    public Guid Id { get; }

    public RoleIdentifier(Guid id)
    {
        if (id == Guid.Empty)
            throw new ArgumentException("Role identifier cannot be empty", nameof(id));

        Id = id;
    }

    public static RoleIdentifier New() => new(Guid.NewGuid());

    public static RoleIdentifier Parse(string value, IFormatProvider? provider = null) => new(Guid.Parse(value));

    public static bool TryParse(string value, IFormatProvider? provider, out RoleIdentifier result)
    {
        if (Guid.TryParse(value, out var id))
        {
            result = new RoleIdentifier(id);
            return true;
        }

        result = default;
        return false;
    }

    public override string ToString() => Id.ToString();

    public int CompareTo(RoleIdentifier other)
    {
        return Id.CompareTo(other.Id);
    }
}


// --- File: MicroPlumberd.Service.Identity\RoleStore.cs ---


using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;
using MicroPlumberd.Service.Identity.Aggregates;
using MicroPlumberd.Service.Identity.ReadModels;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Implementation of ASP.NET Core Identity store for roles using event sourcing with MicroPlumberd
/// </summary>
public class RoleStore :
    IRoleStore<Role>,
    IQueryableRoleStore<Role>
{
    private readonly IPlumber _plumber;
    private readonly RolesModel _rolesModel;

    public RoleStore(
        IPlumber plumber,
        RolesModel rolesModel)
    {
        _plumber = plumber ?? throw new ArgumentNullException(nameof(plumber));
        _rolesModel = rolesModel ?? throw new ArgumentNullException(nameof(rolesModel));
    }

    public IQueryable<Role> Roles => _rolesModel.GetAllRoles().AsQueryable();

    // Helper method to convert string ID to RoleIdentifier
    private RoleIdentifier GetRoleIdentifier(string roleId)
    {
        if (string.IsNullOrEmpty(roleId))
            throw new ArgumentException("Role ID cannot be null or empty", nameof(roleId));

        if (!RoleIdentifier.TryParse(roleId, null, out var roleIdentifier))
            throw new ArgumentException("Invalid role ID format", nameof(roleId));

        return roleIdentifier;
    }

    // Helper method to extract expected version from concurrency stamp
    private CompositeStreamVersion GetExpectedVersion(string concurrencyStamp)
    {
        if (string.IsNullOrEmpty(concurrencyStamp))
            return CompositeStreamVersion.Empty;

        if (!CompositeStreamVersion.TryParse(concurrencyStamp, null, out var version))
            return CompositeStreamVersion.Empty;

        return version;
    }

    public async Task<IdentityResult> CreateAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (role == null)
                throw new ArgumentNullException(nameof(role));

            // Check if a role with this normalized name already exists
            if (!string.IsNullOrEmpty(role.NormalizedName))
            {
                var existingRoleId = _rolesModel.GetIdByNormalizedName(role.NormalizedName);
                if (!existingRoleId.Equals(default(RoleIdentifier)))
                {
                    return IdentityResult.Failed(new IdentityError
                    {
                        Description = $"Role with name '{role.Name}' already exists"
                    });
                }
            }

            // If the role doesn't have an ID, generate one
            if (string.IsNullOrEmpty(role.Id))
            {
                role.Id = RoleIdentifier.New().ToString();
            }

            var roleId = GetRoleIdentifier(role.Id);
            var normalizedName = role.NormalizedName ?? role.Name?.ToUpperInvariant();

            var roleAggregate = RoleAggregate.Create(roleId, role.Name, normalizedName);
            await _plumber.SaveNew(roleAggregate);

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    public async Task<IdentityResult> DeleteAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (role == null)
                throw new ArgumentNullException(nameof(role));

            var roleId = GetRoleIdentifier(role.Id);
            var expectedVersion = GetExpectedVersion(role.ConcurrencyStamp);

            var roleAggregate = await _plumber.Get<RoleAggregate>(roleId);
            roleAggregate.Delete(); // Not using concurrency stamp
            await _plumber.SaveChanges(roleAggregate);

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    public async Task<Role> FindByIdAsync(string roleId, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var id = GetRoleIdentifier(roleId);
        return _rolesModel.GetById(id);
    }

    public async Task<Role> FindByNameAsync(string normalizedRoleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return _rolesModel.GetByNormalizedName(normalizedRoleName);
    }

    public Task<string> GetNormalizedRoleNameAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (role == null)
            throw new ArgumentNullException(nameof(role));

        return Task.FromResult(role.NormalizedName);
    }

    public Task<string> GetRoleIdAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (role == null)
            throw new ArgumentNullException(nameof(role));

        return Task.FromResult(role.Id);
    }

    public Task<string> GetRoleNameAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (role == null)
            throw new ArgumentNullException(nameof(role));

        return Task.FromResult(role.Name);
    }

    public Task SetNormalizedRoleNameAsync(Role role, string normalizedName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (role == null)
            throw new ArgumentNullException(nameof(role));

        role.NormalizedName = normalizedName;
        return Task.CompletedTask;
    }

    public Task SetRoleNameAsync(Role role, string roleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (role == null)
            throw new ArgumentNullException(nameof(role));

        role.Name = roleName;
        return Task.CompletedTask;
    }

    public async Task<IdentityResult> UpdateAsync(Role role, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (role == null)
                throw new ArgumentNullException(nameof(role));

            var roleId = GetRoleIdentifier(role.Id);

            // Check if another role with this normalized name already exists
            if (!string.IsNullOrEmpty(role.NormalizedName))
            {
                var existingRole = _rolesModel.GetByNormalizedName(role.NormalizedName);
                if (existingRole != null && existingRole.Id != role.Id)
                {
                    return IdentityResult.Failed(new IdentityError
                    {
                        Description = $"Role with name '{role.Name}' already exists"
                    });
                }
            }

            var roleAggregate = await _plumber.Get<RoleAggregate>(roleId);

            // Let the aggregate decide if a change is needed
            roleAggregate.ChangeName(role.Name, role.NormalizedName);

            // Only save if there are pending changes
            if (roleAggregate.HasPendingChanges)
            {
                await _plumber.SaveChanges(roleAggregate);
            }

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    public void Dispose()
    {
        // Nothing to dispose
    }
}


// --- File: MicroPlumberd.Service.Identity\TokenName.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Names a token
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<TokenName>))]
public readonly record struct TokenName : IParsable<TokenName>, IComparable<TokenName>
{
    public string Value { get; }

    public TokenName(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Token name cannot be empty", nameof(value));

        Value = value.ToLowerInvariant();
    }

    public override string ToString() => Value;

    // Common token names
    public static TokenName RefreshToken => new("RefreshToken");
    public static TokenName EmailConfirmation => new("EmailConfirmation");
    public static TokenName ResetPassword => new("ResetPassword");
    public static TokenName Parse(string s, IFormatProvider? provider)
    {
        return new TokenName(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out TokenName result)
    {
        result = new TokenName(s);
        return true;
    }

    public int CompareTo(TokenName other)
    {
        return string.Compare(Value, other.Value, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\TokenValue.cs ---


using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Holds a token's value
/// </summary>
[JsonConverter(typeof(JsonParsableConverter<TokenValue>))]
public readonly record struct TokenValue : IParsable<TokenValue>, IComparable<TokenValue>
{
    public string Value { get; }

    public TokenValue(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Token value cannot be empty", nameof(value));

        Value = value.ToLowerInvariant();
    }

    public override string ToString() => Value;
    public static TokenValue Parse(string s, IFormatProvider? provider)
    {
        return new(s);
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out TokenValue result)
    {
        result = new(s);
        return true;
    }

    public int CompareTo(TokenValue other)
    {
        return string.Compare(Value, other.Value, StringComparison.Ordinal);
    }
}


// --- File: MicroPlumberd.Service.Identity\UserIdentifier.cs ---


// ValueTypes.cs

using System.Text.Json.Serialization;

namespace MicroPlumberd.Service.Identity
{
    /// <summary>
    /// Uniquely identifies a user
    /// </summary>
    [JsonConverter(typeof(JsonParsableConverter<UserIdentifier>))]
    public readonly record struct UserIdentifier : IParsable<UserIdentifier>, IComparable<UserIdentifier>
    {
        public Guid Id { get; }

        public UserIdentifier(Guid id)
        {
            if (id == Guid.Empty)
                throw new ArgumentException("User identifier cannot be empty", nameof(id));

            Id = id;
        }

        public static UserIdentifier New() => new(Guid.NewGuid());

        public static UserIdentifier Parse(string value, IFormatProvider? provider = null) => new(Guid.Parse(value));

        public static bool TryParse(string? value, IFormatProvider? provider, out UserIdentifier result)
        {
            if (Guid.TryParse(value, out var id))
            {
                result = new UserIdentifier(id);
                return true;
            }

            result = default;
            return false;
        }

        public override string ToString() => Id.ToString();

        public int CompareTo(UserIdentifier other)
        {
            return Id.CompareTo(other.Id);
        }
    }
}


// --- File: MicroPlumberd.Service.Identity\UserService.cs ---


using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;
using MicroPlumberd.Service.Identity.Aggregates;
using MicroPlumberd.Service.Identity.ReadModels;

namespace MicroPlumberd.Service.Identity;

/// <summary>
/// Implementation of ASP.NET Core Identity stores for users using event sourcing with MicroPlumberd
/// </summary>
public class UserStore :
    IUserStore<User>,
    IUserEmailStore<User>,
    IUserPasswordStore<User>,
    IUserSecurityStampStore<User>,
    IUserLockoutStore<User>,
    IUserTwoFactorStore<User>,
    IUserPhoneNumberStore<User>,
    IUserLoginStore<User>,
    IUserClaimStore<User>,
    IUserRoleStore<User>,
    IUserAuthenticationTokenStore<User>,
    IUserAuthenticatorKeyStore<User>,
    IUserTwoFactorRecoveryCodeStore<User>,
    IQueryableUserStore<User>
{
    private readonly IPlumber _plumber;
    private readonly UsersModel _usersModel;
    private readonly RolesModel _rolesModel;
    private readonly AuthenticationModel _authenticationModel;
    private readonly UserAuthorizationModel _userAuthorizationModel;
    private readonly TokenModel _tokenModel;
    private readonly ExternalLoginModel _externalLoginModel;

    public UserStore(
        IPlumber plumber,
        UsersModel usersModel,
        RolesModel rolesModel,
        AuthenticationModel authenticationModel,
        UserAuthorizationModel userAuthorizationModel,
        TokenModel tokenModel, ExternalLoginModel externalLoginModel)
    {
        _plumber = plumber ?? throw new ArgumentNullException(nameof(plumber));
        _usersModel = usersModel ?? throw new ArgumentNullException(nameof(usersModel));
        _rolesModel = rolesModel ?? throw new ArgumentNullException(nameof(rolesModel));
        _authenticationModel = authenticationModel ?? throw new ArgumentNullException(nameof(authenticationModel));
        _userAuthorizationModel = userAuthorizationModel ?? throw new ArgumentNullException(nameof(userAuthorizationModel));
        _tokenModel = tokenModel ?? throw new ArgumentNullException(nameof(tokenModel));
        _externalLoginModel = externalLoginModel;
    }

    // Helper method to convert string ID to UserIdentifier
    private UserIdentifier GetUserIdentifier(string userId)
    {
        if (string.IsNullOrEmpty(userId))
            throw new ArgumentException("User ID cannot be null or empty", nameof(userId));

        if (!UserIdentifier.TryParse(userId, null, out var userIdentifier))
            throw new ArgumentException("Invalid user ID format", nameof(userId));

        return userIdentifier;
    }

    // Helper method to extract expected version from concurrency stamp
    private CompositeStreamVersion GetExpectedVersion(string concurrencyStamp)
    {
        if (string.IsNullOrEmpty(concurrencyStamp))
            return CompositeStreamVersion.Empty;

        if (!CompositeStreamVersion.TryParse(concurrencyStamp, null, out var version))
            return CompositeStreamVersion.Empty;

        return version;
    }

    #region IUserStore<User> Implementation

    public IQueryable<User> Users => _usersModel.GetAllUsers().AsQueryable();

    public async Task<IdentityResult> CreateAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            var userId = GetUserIdentifier(user.Id);

            // Create profile aggregate
            var userProfile = UserProfileAggregate.Create(
                userId,
                user.UserName,
                user.NormalizedUserName,
                user.Email,
                user.NormalizedEmail,
                user.PhoneNumber);

            await _plumber.SaveNew(userProfile);

            // Create identity aggregate
            var identityUser = IdentityUserAggregate.Create(
                userId,
                user.PasswordHash,
                user.LockoutEnabled);

            await _plumber.SaveNew(identityUser);

            // Create authorization aggregate
            var authorizationUser = AuthorizationUserAggregate.Create(userId);
            await _plumber.SaveNew(authorizationUser);

            // Create external login aggregate
            var externalLoginAggregate = ExternalLoginAggregate.Create(userId);
            await _plumber.SaveNew(externalLoginAggregate);

            // Create token aggregate
            var tokenAggregate = TokenAggregate.Create(userId);
            await _plumber.SaveNew(tokenAggregate);

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    public async Task<IdentityResult> DeleteAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            var userId = GetUserIdentifier(user.Id);
            var expectedVersion = GetExpectedVersion(user.ConcurrencyStamp);

            // Delete profile
            var userProfile = await _plumber.Get<UserProfileAggregate>(userId);
            userProfile.Delete(); // We're not using concurrency stamp anymore
            await _plumber.SaveChanges(userProfile);

            // Delete identity
            var identityUser = await _plumber.Get<IdentityUserAggregate>(userId);
            identityUser.Delete();
            await _plumber.SaveChanges(identityUser);

            // Delete authorization
            var authorizationUser = await _plumber.Get<AuthorizationUserAggregate>(userId);
            authorizationUser.Delete();
            await _plumber.SaveChanges(authorizationUser);

            // Delete external logins
            var externalLoginAggregate = await _plumber.Get<ExternalLoginAggregate>(userId);
            externalLoginAggregate.Delete();
            await _plumber.SaveChanges(externalLoginAggregate);

            // Delete tokens
            var tokenAggregate = await _plumber.Get<TokenAggregate>(userId);
            tokenAggregate.Delete();
            await _plumber.SaveChanges(tokenAggregate);

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    public async Task<User> FindByIdAsync(string userId, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var userIdentifier = GetUserIdentifier(userId);
        return _usersModel.GetById(userIdentifier);
    }

    public async Task<User> FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return _usersModel.GetByNormalizedUserName(normalizedUserName);
    }

    public Task<string> GetNormalizedUserNameAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.NormalizedUserName);
    }

    public Task<string> GetUserIdAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.Id);
    }

    public Task<string> GetUserNameAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.UserName);
    }

    public Task SetNormalizedUserNameAsync(User user, string normalizedName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.NormalizedUserName = normalizedName;
        return Task.CompletedTask;
    }

    public Task SetUserNameAsync(User user, string userName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.UserName = userName;
        return Task.CompletedTask;
    }

    public async Task<IdentityResult> UpdateAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        try
        {
            if (user == null)
                throw new ArgumentNullException(nameof(user));

            var userId = GetUserIdentifier(user.Id);
          

            // Update profile
            var userProfile = await _plumber.Get<UserProfileAggregate>(userId);

            // Let the aggregate decide if a change is needed
            userProfile.ChangeUserName(user.UserName, user.NormalizedUserName);
            userProfile.ChangeEmail(user.Email, user.NormalizedEmail);

           

            userProfile.ChangePhoneNumber(user.PhoneNumber);

           

            // Only save if there are pending changes
            if (userProfile.HasPendingChanges) await _plumber.SaveChanges(userProfile);

            // Change identity
            var identityUser = await _plumber.Get<IdentityUserAggregate>(userId);

            identityUser.ChangePasswordHash(user.PasswordHash);
            identityUser.ChangeTwoFactorEnabled(user.TwoFactorEnabled);
            identityUser.ChangeLockoutEnabled(user.LockoutEnabled);
            identityUser.ChangeLockoutEnd(user.LockoutEnd);

            // Only save if there are pending changes
            if (identityUser.HasPendingChanges) await _plumber.SaveChanges(identityUser);

            return IdentityResult.Success;
        }
        catch (Exception ex)
        {
            return IdentityResult.Failed(new IdentityError { Description = ex.Message });
        }
    }

    #endregion

    #region IUserEmailStore<User> Implementation

    public async Task<User> FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return _usersModel.GetByNormalizedEmail(normalizedEmail);
    }

    public Task<string> GetEmailAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.Email);
    }

    public Task<bool> GetEmailConfirmedAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.EmailConfirmed);
    }

    public Task<string> GetNormalizedEmailAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.NormalizedEmail);
    }

    public Task SetEmailAsync(User user, string email, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.Email = email;
        return Task.CompletedTask;
    }

    public Task SetEmailConfirmedAsync(User user, bool confirmed, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.EmailConfirmed = confirmed;
        return Task.CompletedTask;
    }

    public Task SetNormalizedEmailAsync(User user, string normalizedEmail, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.NormalizedEmail = normalizedEmail;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserPasswordStore<User> Implementation

    public Task<string> GetPasswordHashAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.PasswordHash);
    }

    public Task<bool> HasPasswordAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(!string.IsNullOrEmpty(user.PasswordHash));
    }

    public Task SetPasswordHashAsync(User user, string passwordHash, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.PasswordHash = passwordHash;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserSecurityStampStore<User> Implementation

    public Task<string> GetSecurityStampAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.SecurityStamp);
    }

    public Task SetSecurityStampAsync(User user, string stamp, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.SecurityStamp = stamp;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserLockoutStore<User> Implementation

    public Task<int> GetAccessFailedCountAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.AccessFailedCount);
    }

    public Task<bool> GetLockoutEnabledAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.LockoutEnabled);
    }

    public Task<DateTimeOffset?> GetLockoutEndDateAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.LockoutEnd);
    }

    public async Task<int> IncrementAccessFailedCountAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var identityUser = await _plumber.Get<IdentityUserAggregate>(userId);

        var ret = identityUser.IncrementAccessFailedCount();
        await _plumber.SaveChanges(identityUser);

        // Return the updated count from the aggregate
        return ret;
    }

    public async Task ResetAccessFailedCountAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var identityUser = await _plumber.Get<IdentityUserAggregate>(userId);

        identityUser.ResetAccessFailedCount();
        await _plumber.SaveChanges(identityUser);
    }

    public Task SetLockoutEnabledAsync(User user, bool enabled, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.LockoutEnabled = enabled;
        return Task.CompletedTask;
    }

    public Task SetLockoutEndDateAsync(User user, DateTimeOffset? lockoutEnd, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.LockoutEnd = lockoutEnd;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserTwoFactorStore<User> Implementation

    public Task<bool> GetTwoFactorEnabledAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.TwoFactorEnabled);
    }

    public Task SetTwoFactorEnabledAsync(User user, bool enabled, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.TwoFactorEnabled = enabled;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserPhoneNumberStore<User> Implementation

    public Task<string> GetPhoneNumberAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.PhoneNumber);
    }

    public Task<bool> GetPhoneNumberConfirmedAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        return Task.FromResult(user.PhoneNumberConfirmed);
    }

    public Task SetPhoneNumberAsync(User user, string phoneNumber, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.PhoneNumber = phoneNumber;
        return Task.CompletedTask;
    }

    public Task SetPhoneNumberConfirmedAsync(User user, bool confirmed, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        user.PhoneNumberConfirmed = confirmed;
        return Task.CompletedTask;
    }

    #endregion

    #region IUserLoginStore<User> Implementation

    public async Task AddLoginAsync(User user, UserLoginInfo login, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (login == null)
            throw new ArgumentNullException(nameof(login));

        var userId = GetUserIdentifier(user.Id);
        var externalLoginAggregate = await _plumber.Get<ExternalLoginAggregate>(userId);

        var provider = new ExternalLoginProvider(login.LoginProvider);
        var key = new ExternalLoginKey(login.ProviderKey);

        externalLoginAggregate.AddLogin(provider, key, login.ProviderDisplayName);
        await _plumber.SaveChanges(externalLoginAggregate);
    }

    public async Task<User> FindByLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        return _usersModel.GetByExternalLogin(loginProvider, providerKey);
    }

    public async Task<IList<UserLoginInfo>> GetLoginsAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var logins = _externalLoginModel.GetLoginsForUser(userId);

        return logins.Select(l => new UserLoginInfo(
            l.ProviderName,
            l.ProviderKey,
            l.DisplayName
        )).ToList();
    }

    public async Task RemoveLoginAsync(User user, string loginProvider, string providerKey, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var externalLoginAggregate = await _plumber.Get<ExternalLoginAggregate>(userId);

        var provider = new ExternalLoginProvider(loginProvider);
        var key = new ExternalLoginKey(providerKey);

        externalLoginAggregate.RemoveLogin(provider, key);
        await _plumber.SaveChanges(externalLoginAggregate);
    }

    #endregion

    #region IUserClaimStore<User> Implementation

    public async Task<IList<Claim>> GetClaimsAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        return _userAuthorizationModel.GetClaims(userId).ToList();
    }

    public async Task AddClaimsAsync(User user, IEnumerable<Claim> claims, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (claims == null)
            throw new ArgumentNullException(nameof(claims));

        var userId = GetUserIdentifier(user.Id);
        var authorizationAggregate = await _plumber.Get<AuthorizationUserAggregate>(userId);

        foreach (var claim in claims)
        {
            var claimType = new ClaimType(claim.Type);
            var claimValue = new ClaimValue(claim.Value);

            authorizationAggregate.AddClaim(claimType, claimValue);
        }

        await _plumber.SaveChanges(authorizationAggregate);
    }

    public async Task ReplaceClaimAsync(User user, Claim claim, Claim newClaim, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (claim == null)
            throw new ArgumentNullException(nameof(claim));
        if (newClaim == null)
            throw new ArgumentNullException(nameof(newClaim));

        var userId = GetUserIdentifier(user.Id);
        var authorizationAggregate = await _plumber.Get<AuthorizationUserAggregate>(userId);

        // Remove the old claim
        var oldClaimType = new ClaimType(claim.Type);
        var oldClaimValue = new ClaimValue(claim.Value);
        authorizationAggregate.RemoveClaim(oldClaimType, oldClaimValue);

        // Add the new claim
        var newClaimType = new ClaimType(newClaim.Type);
        var newClaimValue = new ClaimValue(newClaim.Value);
        authorizationAggregate.AddClaim(newClaimType, newClaimValue);

        await _plumber.SaveChanges(authorizationAggregate);
    }

    public async Task RemoveClaimsAsync(User user, IEnumerable<Claim> claims, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (claims == null)
            throw new ArgumentNullException(nameof(claims));

        var userId = GetUserIdentifier(user.Id);
        var authorizationAggregate = await _plumber.Get<AuthorizationUserAggregate>(userId);

        foreach (var claim in claims)
        {
            var claimType = new ClaimType(claim.Type);
            var claimValue = new ClaimValue(claim.Value);

            authorizationAggregate.RemoveClaim(claimType, claimValue);
        }

        await _plumber.SaveChanges(authorizationAggregate);
    }

    public async Task<IList<User>> GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (claim == null)
            throw new ArgumentNullException(nameof(claim));

        // This requires a query across all users with this claim
        // Since we don't have a direct index for this, we'll need to search through all users
        // This is potentially inefficient and might need optimization in a real system

        // For now, we'll just return an empty list as a placeholder
        // In a real implementation, you would need to create a specialized read model for this query
        return new List<User>();
    }

    #endregion

    #region IUserRoleStore<User> Implementation

    public async Task AddToRoleAsync(User user, string roleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrWhiteSpace(roleName))
            throw new ArgumentException("Role name cannot be empty", nameof(roleName));

        // Get the role ID from the normalized name
        string normalizedRoleName = roleName.ToUpperInvariant();
        var roleId = _rolesModel.GetIdByNormalizedName(normalizedRoleName);

        if (roleId.Equals(default(RoleIdentifier)))
            throw new InvalidOperationException($"Role '{roleName}' does not exist");

        var userId = GetUserIdentifier(user.Id);
        var authorizationAggregate = await _plumber.Get<AuthorizationUserAggregate>(userId);

        authorizationAggregate.AddRole(roleId);
        await _plumber.SaveChanges(authorizationAggregate);
    }

    public async Task RemoveFromRoleAsync(User user, string roleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrWhiteSpace(roleName))
            throw new ArgumentException("Role name cannot be empty", nameof(roleName));

        // Get the role ID from the normalized name
        string normalizedRoleName = roleName.ToUpperInvariant();
        var roleId = _rolesModel.GetIdByNormalizedName(normalizedRoleName);

        if (roleId.Equals(default(RoleIdentifier)))
            return; // Role doesn't exist, nothing to remove

        var userId = GetUserIdentifier(user.Id);
        var authorizationAggregate = await _plumber.Get<AuthorizationUserAggregate>(userId);

        authorizationAggregate.RemoveRole(roleId);
        await _plumber.SaveChanges(authorizationAggregate);
    }

    public async Task<IList<string>> GetRolesAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        return _userAuthorizationModel.GetRoleNames(userId);
        
    }

    public async Task<bool> IsInRoleAsync(User user, string roleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        var userId = GetUserIdentifier(user.Id);
        return _userAuthorizationModel.IsInRole(userId, roleName);
    }

    public async Task<IList<User>> GetUsersInRoleAsync(string roleName, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (string.IsNullOrWhiteSpace(roleName))
            throw new ArgumentException("Role name cannot be empty", nameof(roleName));

        // Get the role ID from the normalized name
        string normalizedRoleName = roleName.ToUpperInvariant();
        var roleId = _rolesModel.GetIdByNormalizedName(normalizedRoleName);

        if (roleId.Equals(default(RoleIdentifier)))
            return new List<User>(); // Role doesn't exist

        var userIds = _userAuthorizationModel.GetUsersInRole(roleId);

        // Convert user IDs to User objects
        var users = new List<User>();
        foreach (var userId in userIds)
        {
            var user = _usersModel.GetById(userId);
            if (user != null)
                users.Add(user);
        }

        return users;
    }

    #endregion

    #region IUserAuthenticationTokenStore<User> Implementation

    public async Task<string> GetTokenAsync(User user, string loginProvider, string name, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Token name cannot be empty", nameof(name));

        var userId = GetUserIdentifier(user.Id);
        return _tokenModel.GetToken(userId, name, loginProvider);
    }

    public async Task SetTokenAsync(User user, string loginProvider, string name, string value, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Token name cannot be empty", nameof(name));

        var userId = GetUserIdentifier(user.Id);
        var tokenAggregate = await _plumber.Get<TokenAggregate>(userId);

        var tokenName = new TokenName(name);
        var tokenValue = new TokenValue(value);

        tokenAggregate.SetToken(tokenName, tokenValue, loginProvider);
        await _plumber.SaveChanges(tokenAggregate);
    }

    public async Task RemoveTokenAsync(User user, string loginProvider, string name, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Token name cannot be empty", nameof(name));

        var userId = GetUserIdentifier(user.Id);
        var tokenAggregate = await _plumber.Get<TokenAggregate>(userId);

        var tokenName = new TokenName(name);

        tokenAggregate.RemoveToken(tokenName, loginProvider);
        await _plumber.SaveChanges(tokenAggregate);
    }

    #endregion

    #region IUserAuthenticatorKeyStore<User> Implementation

    public async Task<string> GetAuthenticatorKeyAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var authData = _authenticationModel.GetAuthenticationData(userId);

        return authData?.AuthenticatorKey;
    }

    public async Task SetAuthenticatorKeyAsync(User user, string key, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var identityUser = await _plumber.Get<IdentityUserAggregate>(userId);

        identityUser.ChangeAuthenticatorKey(key);
        await _plumber.SaveChanges(identityUser);
    }

    #endregion

    #region IUserTwoFactorRecoveryCodeStore<User> Implementation

    public async Task<int> CountCodesAsync(User user, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));

        var userId = GetUserIdentifier(user.Id);
        var codes = await GetRecoveryCodesAsync(userId);

        return codes.Count;
    }

    public async Task<bool> RedeemCodeAsync(User user, string code, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (string.IsNullOrEmpty(code))
            throw new ArgumentException("Recovery code cannot be empty", nameof(code));

        var userId = GetUserIdentifier(user.Id);
        var tokenAggregate = await _plumber.Get<TokenAggregate>(userId);

        var codes = await GetRecoveryCodesAsync(userId);
        var normalizedCode = code.Trim();

        if (!codes.Contains(normalizedCode))
            return false;

        // Remove the used code
        codes.Remove(normalizedCode);

        // Save the updated codes
        await SetRecoveryCodesAsync(tokenAggregate, codes);

        return true;
    }

    public async Task ReplaceCodesAsync(User user, IEnumerable<string> recoveryCodes, CancellationToken cancellationToken)
    {
        cancellationToken.ThrowIfCancellationRequested();

        if (user == null)
            throw new ArgumentNullException(nameof(user));
        if (recoveryCodes == null)
            throw new ArgumentNullException(nameof(recoveryCodes));

        var userId = GetUserIdentifier(user.Id);
        var tokenAggregate = await _plumber.Get<TokenAggregate>(userId);

        // Save the new codes
        await SetRecoveryCodesAsync(tokenAggregate, recoveryCodes.ToList());
    }

    // Helper methods for recovery codes
    private async Task<List<string>> GetRecoveryCodesAsync(UserIdentifier userId)
    {
        var tokenValue = _tokenModel.GetToken(userId, "RecoveryCodes", null);

        if (string.IsNullOrEmpty(tokenValue))
            return new List<string>();

        return tokenValue.Split(';', StringSplitOptions.RemoveEmptyEntries).ToList();
    }

    private async Task SetRecoveryCodesAsync(TokenAggregate tokenAggregate, List<string> codes)
    {
        var tokenValue = string.Join(";", codes);
        var tokenName = new TokenName("RecoveryCodes");

        tokenAggregate.SetToken(tokenName, new TokenValue(tokenValue), null);
        await _plumber.SaveChanges(tokenAggregate);
    }

    #endregion

    public void Dispose()
    {
        // Nothing to dispose
    }
}


// --- File: MicroPlumberd.Services\Validation\CommandHandlerAttributeValidator.cs ---


using System.ComponentModel.DataAnnotations;

namespace MicroPlumberd.Services;

public class CommandHandlerAttributeValidator<T>(ICommandHandler<T> nx, IServiceProvider sp) : ICommandHandler<T>
{
    public Task<object?> Execute(string id, T command)
    {
        var validationContext = new ValidationContext(command, sp, null);
        Validator.ValidateObject(command, validationContext);
        return nx.Execute(id, command);
    }

}

class CommandBusAttributeValidator(ICommandBus cb, IServiceProvider sp) : ICommandBus
{
    public async Task SendAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = false,  CancellationToken token = default)
    {
        var validationContext = new ValidationContext(command, sp, null);
        Validator.ValidateObject(command, validationContext, true);
        await cb.SendAsync(recipientId, command, timeout,fireAndForget, token);
    }

    public Task QueueAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = true, CancellationToken token = default)
    {
        var validationContext = new ValidationContext(command, sp, null);
        Validator.ValidateObject(command, validationContext, true);
        return cb.QueueAsync(recipientId, command, timeout, fireAndForget, token);
    }
    public void Dispose(){}
    public ValueTask DisposeAsync()
    {
        return ValueTask.CompletedTask;
    }
}


// --- File: MicroPlumberd.Services\Class1.cs ---


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Dynamic;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Xml.Linq;
using EventStore.Client;
using MicroPlumberd;
using MicroPlumberd.Services;
using MicroPlumberd.Utils;
using static CorrelationModel;

[assembly: InternalsVisibleTo("MicroPlumberd.Tests")]

public class CorrelationModelBuilder
{
    private readonly List<TypeEventConverter> _converters = new();
    private readonly IServicesConvention _conventions;
    private readonly IPlumber _plumber;
    private readonly Dictionary<string, Type> _register = new Dictionary<string, Type>();
    internal CorrelationModelBuilder(IPlumber plumber)
    {
        _plumber = plumber;
        _conventions = plumber.Config.Conventions.ServicesConventions();
        _converters.Add(_register.TryGetValue);
    }

    public CorrelationModelBuilder WithEventHandler<T>() where T:IEventHandler, ITypeRegister
    {
        var converter = _plumber.TypeHandlerRegisters.GetEventNameConverterFor<T>();
        _converters.Add(converter);
        return this;
    }

    public CorrelationModelBuilder WithEvent<T>()
    {
        var converter = _plumber.Config.Conventions.GetEventNameConvention(null, typeof(T));
        _register.Add(converter, typeof(T));
        return this;
    }
    public CorrelationModelBuilder WithCommandHandler<T>() where T : ICommandHandler, IServiceTypeRegister
    {
        foreach (var commandType in T.CommandTypes)
        {
            string cmdName = _plumber.Config.Conventions.GetEventNameConvention(null, commandType);
            _register.Add(cmdName, commandType);
            var cmdNameExecuted = _conventions.CommandNameConvention(commandType);
            //ThrowsFaultExceptionAttribute
            string executedCommand = $"{cmdNameExecuted}Executed";
            _register.Add(executedCommand, typeof(CommandExecuted));

            string executedFailed = $"{cmdNameExecuted}Failed";
            _register.Add(executedFailed, typeof(CommandFailed));

            foreach (var i in commandType.GetCustomAttributes<ThrowsFaultExceptionAttribute>())
            {
                string executedFailedWithPayload = $"{cmdNameExecuted}Failed<{i.ThrownType.Name}>";
                _register.Add(executedFailedWithPayload, typeof(CommandFailed<>).MakeGenericType(i.ThrownType));
            }
        }

        return this;
    }
    public async Task<CorrelationModel> Read(Guid correlationId)
    {
        
        var model = new CorrelationModel(_converters.ToArray(), correlationId);
        await this._plumber.Rehydrate(model, $"$bc-{correlationId}", model.TryConvert, StreamPosition.Start);
        return model;
    }
    public async Task<CorrelationModel> Subscribe(Guid correlationId)
    {
        var model = new CorrelationModel(_converters.ToArray(), correlationId);
        await this._plumber.Subscribe( $"$bc-{correlationId}",FromRelativeStreamPosition.Start)
            .WithHandler(model, model.TryConvert);
        return model;
    }
}

public static class CorrelationModelBuilderExtensions
{
    public static CorrelationModelBuilder CorrelationModel(this IPlumber plumber)
    {
        return new CorrelationModelBuilder(plumber);
    }
}
[DebuggerDisplay("{Event}")]
public class CorrelationModel : IEventHandler, IEnumerable<CorrelationNode>
{
    public class CorrelationNode : IEquatable<CorrelationNode>, INotifyCollectionChanged, IReadOnlyList<CorrelationNode>, INotifyPropertyChanged
    {
        public CorrelationNode? Parent
        {
            get => _parent;
            internal set
            {
                if (_parent == value) return;
                _parent = value;
                if (_parent == null) return;
                if (!_parent._children.Contains(this))
                    _parent.AddChild(this);
            }
        }

        public Guid Id { get; }
        private readonly ObservableCollection<CorrelationNode> _children = new();
        private CorrelationNode? _parent;
        private TimeSpan? _duration;
        private HttpStatusCode? _faultCode;
        private string _faultMessage;
        private bool? _isFaulted;
        private object? _fault;
        public object Event { get; }

        public TimeSpan? Duration
        {
            get => _duration;
            internal set
            {
                if (SetField(ref _duration, value))
                {
                    OnPropertyChanged(nameof(IsCompleted));
                }
            }
        }

        public object? Fault
        {
            get => _fault;
            internal set => SetField(ref _fault, value);
        }

        public HttpStatusCode? FaultCode
        {
            get => _faultCode;
            internal set => SetField(ref _faultCode, value);
        }

        public string FaultMessage
        {
            get => _faultMessage;
            internal set => SetField(ref _faultMessage, value);
        }

        public bool? IsFaulted
        {
            get => _isFaulted;
            internal set => SetField(ref _isFaulted, value);
        }

        public bool IsCompleted => Duration.HasValue;
        
        public T EventAs<T>() => (T)Event;
        
        public CorrelationNode(Metadata metadata, object @event)
        {
            Id = IdDuckTyping.Instance.TryGetGuidId(@event, out var g) ? g : throw new InvalidOperationException("Id is required!");
            Event = @event;
        }

        public CorrelationNode AddChild(CorrelationNode node)
        {
            _children.Add(node);
            return this;
        }
        public IEnumerator<CorrelationNode> GetEnumerator()
        {
            return _children.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IEnumerable)_children).GetEnumerator();
        }

        public bool Equals(CorrelationNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return Id.Equals(other.Id);
        }

        public override bool Equals(object? obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != GetType()) return false;
            return Equals((CorrelationNode)obj);
        }

        public override int GetHashCode()
        {
            return Id.GetHashCode();
        }

        public static bool operator ==(CorrelationNode? left, CorrelationNode? right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(CorrelationNode? left, CorrelationNode? right)
        {
            return !Equals(left, right);
        }

        public event NotifyCollectionChangedEventHandler? CollectionChanged
        {
            add => _children.CollectionChanged += value;
            remove => _children.CollectionChanged -= value;
        }

        public int Count => _children.Count;

        public CorrelationNode this[int index] => _children[index];
        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }

    private readonly List<CorrelationNode> _items = new();
    private CorrelationNode _root;
    private readonly ConcurrentDictionary<Guid, CorrelationNode> _nodes = new();
    private readonly TypeEventConverter[] _converters;
    private readonly Guid _correlationId;
    public Guid CorrelationId => _correlationId;
    internal CorrelationModel(TypeEventConverter[] converters, Guid correlationId)
    {
        _converters = converters;
        _correlationId = correlationId;
    }

    Task IEventHandler.Handle(Metadata m, object ev)
    {
        var causation = m.CausationId() ?? throw new InvalidOperationException("CausationId is required!");
        if (_nodes.TryGetValue(causation, out var src))
        {
            if (ev is CommandExecuted ce)
            {
                src.Duration = ce.Duration;
                src.IsFaulted = false;
            }
            else if (ev is ICommandFailed cf)
            {
                src.IsFaulted = true;
                src.FaultCode = cf.Code;
                src.FaultMessage = cf.Message;
            }
            else if (ev is ICommandFailedEx cfo)
            {
                src.IsFaulted = true;
                src.FaultCode = cfo.Code;
                src.FaultMessage = cfo.Message;
                src.Fault = cfo.Fault;
            }
            else
            {
                var node = new CorrelationNode(m, ev) { Parent = src! };
                _nodes.TryAdd(node.Id, node);
                _items.Add(node);
            }
        }
        else
        {
            if (_root != null) throw new InvalidOperationException("Root node is already set!");
            // this is root node.
            _root = new CorrelationNode(m, ev);
            _nodes.TryAdd(_root.Id, _root);
            _items.Add(_root);
       }
       return Task.CompletedTask;
    }


    public IEnumerator<CorrelationNode> GetEnumerator()
    {
        return _items.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return ((IEnumerable)_items).GetEnumerator();
    }
    public bool TryConvert(string type, out Type t)
    {
        foreach (var converter in _converters)
        {
            if (converter(type, out t))
            {
                return true;
            }
        }

        t = null;
        return false;
    }
}


// --- File: MicroPlumberd.Services\CommandBus.cs ---


using System.Runtime.CompilerServices;



using System.Collections.Concurrent;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using EventStore.Client;
using MicroPlumberd;
using MicroPlumberd.Collections;
using MicroPlumberd.Services;

using MicroPlumberd.Utils;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services;

internal class CommandBus : ICommandBus, IEventHandler
{
    private readonly IPlumber _plumber;
    private readonly ICommandBusPool _pool;
    private readonly ILogger<CommandBus> _log;
    private readonly string _streamIn;
    private readonly string _streamOut;
    private readonly ConcurrentDictionary<Guid, CommandExecutionResults> _handlers = new();
    private readonly ConcurrentDictionary<string, Type> _commandMapping = new();
    private readonly ConcurrentHashSet<Type> _supportedCommands = new();
    private AsyncLazy<bool> _initialized;
    private readonly object _sync = new object();
    private IAsyncDisposable? _subscription;
    public Guid SessionId { get; } = Guid.NewGuid();
    public CommandBus(IPlumber plumber, ICommandBusPool pool, ILogger<CommandBus> log)
    {
        _plumber = plumber;
        _pool = pool;
        _log = log;
        var servicesConventions = plumber.Config.Conventions.ServicesConventions();
        _streamIn = servicesConventions.SessionInStreamFromSessionIdConvention(SessionId);
        _streamOut = servicesConventions.SessionOutStreamFromSessionIdConvention(SessionId);
        _initialized = new AsyncLazy<bool>(OnInitialize);
    }

    private async Task<bool> OnInitialize()
    {
        await _plumber.Client.SetStreamMetadataAsync(_streamIn, StreamState.NoStream, new StreamMetadata(maxAge: TimeSpan.FromDays(30)));
        await _plumber.Client.SetStreamMetadataAsync(_streamOut, StreamState.NoStream, new StreamMetadata(maxAge: TimeSpan.FromDays(30)));
        _subscription = await _plumber.SubscribeEventHandler(TryMapEventResponse, null, this, _streamOut, FromStream.End, false);
        _log.LogDebug("Session {steamId} subscribed.", _streamOut);
       
        return true;
    }


    private bool TryMapEventResponse(string type, out Type t)
    {
        if (_commandMapping.TryGetValue(type, out t)) return true;

        string supportedMessages = string.Join("\r\n-> ", _commandMapping.Keys);
        string helpMsg;
        int index = type.IndexOf("Failed<");
        if (index != -1)
        {
            string arg = type.Substring(index + 7);
            helpMsg = $"\r\nHave you forgotten to decorate command with [ThrowsFaultException<{arg}] attribute??";
        }
        else
            helpMsg = string.Empty;
        _log.LogWarning("Received unrecognized message type: {type}; Supported message types:{supportedMessages}"+ helpMsg, type, supportedMessages);
        return false;

    }

    private readonly IdDuckTyping _idTyping = new();

    public async Task QueueAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = true, CancellationToken token = default)
    {
        using var scope = await _pool.RentScope(token);
        await scope.SendAsync(recipientId, command, timeout ?? TimeSpan.FromDays(7), fireAndForget, token);
    }
    public async Task SendAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = false, CancellationToken token = default)
    {
        var commandId = GetCommandId(command);
        var causationId = InvocationContext.Current.CausactionId() ?? commandId;
        var correlationId = InvocationContext.Current.CorrelationId() ?? commandId;
        var retById = IdDuckTyping.Instance.TryGetGuidId(command, out var id) ? id : correlationId;

        var metadata = new
        {
            CorrelationId =  (Guid)correlationId!, 
            CausationId = (Guid)causationId!,
            RecipientId = recipientId.ToString(),
            SessionId = SessionId,
        };

        var executionResults = new CommandExecutionResults();
        if (!_handlers.TryAdd(retById, executionResults))
            throw new InvalidOperationException("This command is being executed.");

        //Debug.WriteLine($"===> {SessionId} expects results from command id: {retById}, Context causation is: {InvocationContext.Current.CausactionId()}");
        
        CheckMapping(command);
        await _initialized.Value;

        await _plumber.AppendEvents(_streamIn, StreamState.Any, [command], metadata, token);

        if (fireAndForget)
            return;
        
        bool receivedReturn = await executionResults.IsReady.Task.WaitAsync(timeout ?? _plumber.Config.ServicesConfig().DefaultTimeout, token);
        if (!executionResults.IsSuccess)
        {
            if (!receivedReturn)
            {
                _handlers.TryRemove(metadata.CausationId, out var v);
                throw new TimeoutException("Command execution timeout.");
            }
            else if (executionResults.ErrorData != null)
                throw FaultException.Create(executionResults.ErrorMessage, executionResults.ErrorData, (int)executionResults.ErrorCode);
            throw new FaultException(executionResults.ErrorMessage);
        }
    }

    private Guid GetCommandId(object command)
    {
        Guid commandId = Guid.NewGuid();
        if (command is IId iid)
        {
            commandId = iid.Uuid;
        }
        else
        {
            var tmpId = _idTyping.GetId(command);
            if (tmpId is Guid g)
            {
                commandId = g;
            }
            else commandId = Guid.NewGuid();
        }

        return commandId;
    }

    private void CheckMapping(object command)
    {
        var cmdType = command.GetType();
        if (_supportedCommands.Contains(cmdType)) return;
        if (!_supportedCommands.Add(cmdType)) return;

        foreach (var (name, type) in _plumber.Config.Conventions.ServicesConventions().CommandMessageTypes(cmdType))
            _commandMapping.TryAdd(name, type);
    }


    async Task IEventHandler.Handle(Metadata m, object ev)
    {
        var causationId = ev is ICommandSource cs ? cs.CommandId : (m.CausationId() ?? Guid.Empty);
        if (_handlers.TryGetValue(causationId, out var results))
        {
            if (await results.Handle(m, ev))
            {
                _handlers.TryRemove(causationId, out var x);
                _log.LogDebug("Command execution confirmed: {CommandType}", ev.GetType().GetFriendlyName());
            }
        } 
        else 
            _log.LogDebug("Session event unhandled. CausationId: {CausationId}, SessionId: {SessionId}, Stream: {StreamId}", causationId, SessionId, _streamOut);
    }

    public ValueTask DisposeAsync() => _subscription?.DisposeAsync() ?? ValueTask.CompletedTask;
    public void Dispose() => _ = DisposeAsync();
}

public abstract class ThrowsFaultExceptionAttribute(Type thrownType) : Attribute
{
    public Type ThrownType { get; init; } = thrownType;
}


// --- File: MicroPlumberd.Services\CommandBusPool.cs ---


using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services;

class CommandBusPool : IAsyncDisposable, ICommandBusPool
{
    private class CommandBusOwner : ICommandBusOwner
    {
        private readonly CommandBusPool _parent;
        private readonly ICommandBus _commandBus;

        public Task SendAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = false,
            CancellationToken token = default)
        {
            return _commandBus.SendAsync(recipientId, command, timeout, fireAndForget, token);
        }


        internal CommandBusOwner(CommandBusPool parent, ICommandBus cb)
        {
            _parent = parent;
            this._commandBus = cb;
        }

        public void Dispose()
        {
            _parent.Return(this);
        }

        public ICommandBus CommandBus => _commandBus;
    }
    private readonly IServiceProvider _sp;
    protected readonly int _maxCount;
    private ConcurrentStack<CommandBusOwner> _pool;
    private SemaphoreSlim _semaphore;
    private bool _disposed;
    public CommandBusPool(IServiceProvider sp, int maxCount)
    {
        _sp = sp;
        _maxCount = maxCount;
    }

    internal void Return(ICommandBusOwner o)
    {
        if (o is not CommandBusOwner cbo)
            throw new ArgumentException();

        if (_disposed)
        {
            cbo.CommandBus.DisposeAsync();
            return;
        }

        _pool.Push(cbo);
        _semaphore.Release();
    }
    public ICommandBusPool Init()
    {
        if (_semaphore != null!) return this;
        _semaphore = new SemaphoreSlim(_maxCount);
        _pool = new ConcurrentStack<CommandBusOwner>(Create(number: _maxCount).Select(x=>new CommandBusOwner(this,x)));
        return this;
    }

    public async ValueTask<ICommandBusOwner> RentScope(CancellationToken ct = default)
    {
        await _semaphore.WaitAsync(ct);
        if (!_pool.TryPop(out var x))
            throw new InvalidOperationException();
        return x;
    }
    public virtual IEnumerable<ICommandBus> Create(int number)
    {
        // Command is configured to be singleton in the container.
        var pl = _sp.GetRequiredService<IPlumber>();
        var logger = _sp.GetRequiredService<ILogger<CommandBus>>();
        for (int i = 0; i < number; ++i) 
            yield return new CommandBus(pl,this, logger);
    }

    public virtual async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;
        
        if (_semaphore is IAsyncDisposable semaphoreAsyncDisposable)
            await semaphoreAsyncDisposable.DisposeAsync();
        else
            _semaphore.Dispose();

        foreach (var i in _pool.ToArray())
            await i.CommandBus.DisposeAsync();
    }
}


// --- File: MicroPlumberd.Services\CommandBusPoolScoped.cs ---


using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd.Services;

sealed class CommandBusPoolScoped(IServiceProvider sp, int maxCount) : CommandBusPool(sp, maxCount)
{
    private readonly IServiceScope _scope = sp.CreateScope();

    public override IEnumerable<ICommandBus> Create(int number)
    {
        for (int i = 0; i < _maxCount; ++i)
            yield return _scope.ServiceProvider.GetRequiredService<ICommandBus>();
    }

}


// --- File: MicroPlumberd.Services\CommandExecutionResults.cs ---


using System.Net;

namespace MicroPlumberd.Services;

public class CommandExecutionResults 
{
    public async ValueTask<bool> Handle(Metadata m, object ev)
    {
        switch (ev)
        {
            case CommandExecuted ce:
            {
                IsSuccess = true;
                IsReady.SetResult(true);
                return true;
            }
            case ICommandFailedEx ef:
            {
                IsSuccess = false;
                ErrorMessage = ef.Message;
                ErrorData = ef.Fault;
                ErrorCode = ef.Code;
                IsReady.SetResult(true);
                return true;
            }
            case ICommandFailed cf:
            {
                IsSuccess = false;
                ErrorMessage = cf.Message;
                ErrorCode = cf.Code;
                IsReady.SetResult(true);
                return true;
            }
        }

        return false;
    }

    public HttpStatusCode ErrorCode { get; private set; }


    public string ErrorMessage { get; private set; }
    public object? ErrorData { get; private set; }
    public bool IsSuccess { get; private set; }
    public TaskCompletionSource<bool> IsReady { get; private set; } = new TaskCompletionSource<bool>();
    
}


// --- File: MicroPlumberd.Services\CommandHandlerAttribute.cs ---


namespace MicroPlumberd.Services;

/// <summary>
/// Attribute for marking a class suitable for command-handler code-generation.
/// The class should have methods with signature:
/// <code>
/// public async Task Handle(Guid id, YourFancyCommand cmd) { /* ... */ }
/// </code>
///
/// Where type of id can be any Parsable class/struct.
/// </summary>
[AttributeUsage(AttributeTargets.Class)]
public class CommandHandlerAttribute : Attribute
{
}



// --- File: MicroPlumberd.Services\CommandHandlerExecutor.cs ---


using System.Collections.Concurrent;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Net;
using EventStore.Client;
using MicroPlumberd.Utils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services;

static class CommandHandlerExecutor
{
    /// <summary>
    /// Creates a new concrete instance of the CommandHandlerExecutor.
    /// </summary>
    /// <param name="plumber">plumber instance</param>
    /// <param name="t">Type fo the handler</param>
    /// <returns></returns> <summary>
    public static IEventHandler Create(IPlumber plumber, Type t)
    {
        var executorType = typeof(CommandHandlerExecutor<>).MakeGenericType(t);
        return (IEventHandler)plumber.Config.ServiceProvider.GetRequiredService(executorType);
    }
}

/// <summary>
/// Provides extension methods for working with metadata.
/// </summary>
public static class MetadataExtensions
{
    /// <summary>
    /// Retrieves the session ID from the metadata.
    /// </summary>
    /// <param name="m">The metadata.</param>
    /// <returns>The session ID, or null if not found.</returns>
    public static Guid? SessionId(this Metadata m)
    {
        if (m.Data.TryGetProperty("SessionId", out var v))
            return Guid.Parse(v.GetString()!);
        return null;
    }
}

class CommandHandlerExecutor<THandler>(IPlumber plumber, ILogger<CommandHandlerExecutor<THandler>> log) : IEventHandler, ITypeRegister
    where THandler:ICommandHandler, IServiceTypeRegister
{
    private readonly IServicesConvention _serviceConventions = plumber.Config.Conventions.ServicesConventions();
    class Invoker<TCommand>(CommandHandlerExecutor<THandler> parent) : IInvoker { public async Task Handle(Metadata m, object ev) => 
        await parent.Handle<TCommand>(m, (TCommand)ev); }
    interface IInvoker { Task Handle(Metadata m, object ev); }

    private readonly ConcurrentDictionary<Type, IInvoker> _cached = new();
    public async Task Handle(Metadata m, object ev)
    {
        var invoker = _cached.GetOrAdd(ev.GetType(), x => (IInvoker)Activator.CreateInstance(typeof(Invoker<>).MakeGenericType(typeof(THandler), ev.GetType()), this)!);
        if (_serviceConventions.CommandHandlerSkipFilter(m, ev))
            return;
        await invoker.Handle(m, ev);
    }

    private static IdDuckTyping _duckId = new IdDuckTyping();
    private async Task Handle<TCommand>(Metadata m, TCommand command)
    {
        
        await using var scope = plumber.Config.ServiceProvider.CreateAsyncScope();
        var ch = (ICommandHandler<TCommand>)scope.ServiceProvider.GetRequiredService(typeof(ICommandHandler<TCommand>));
        var recipientId = m.RecipientId();
        var sessionId = m.SessionId() ?? Guid.Empty;
        if (sessionId == Guid.Empty) return;

        var cmdStream = _serviceConventions.SessionOutStreamFromSessionIdConvention(sessionId);
        var cmdName = _serviceConventions.CommandNameConvention(command.GetType());
        //var cmdId = m.CausationId() ?? m.EventId;//(command is IId id) ? id.Uuid : m.EventId;
        var id = _duckId.GetId(command);
        var cmdId = id is Guid g ? g : Guid.Parse(id.ToString());

        Stopwatch sw = new Stopwatch();
        try
        {
            sw.Start();
            await ch.Execute(recipientId, command);
            log.LogDebug("Command {CommandType} executed.", command.GetType().Name);
            var evt = new CommandExecuted() { CommandId = cmdId, Duration = sw.Elapsed };
            var evtName = $"{cmdName}Executed";

            await plumber.AppendEventToStream(cmdStream, evt, StreamState.Any, evtName);
            log.LogDebug("Command {CommandType} appended to session steam {CommandStream}.", command.GetType().Name,
                cmdStream);

        }
        catch (ValidationException ex)
        {
            var evt = new CommandFailed()
            {
                CommandId = cmdId,
                Duration = sw.Elapsed,
                Message = ex.Message,
                Code = HttpStatusCode.BadRequest
            };
            var evtName = $"{cmdName}Failed";
            await plumber.AppendEventToStream(cmdStream, evt, StreamState.Any, evtName);
        }
        catch (FaultException ex)
        {
            var faultData = ex.GetFaultData();
            var evt = CommandFailed.Create(cmdId, ex.Message, sw.Elapsed, (HttpStatusCode)ex.Code, faultData);
            var evtName = $"{cmdName}Failed<{faultData.GetType().Name}>";
            await plumber.AppendEventToStream(cmdStream, evt, StreamState.Any, evtName);
            log.LogDebug(ex,"Command {CommandType}Failed<{FaultType}> appended to session steam {CommandStream}.", 
                command.GetType().Name,
                faultData.GetType().Name,
                cmdStream);
        }
        catch(Exception ex)
        {
            var evt = new CommandFailed()
            {
                CommandId = cmdId,
                Duration = sw.Elapsed,
                Message = ex.Message,
                Code = HttpStatusCode.InternalServerError
            };
            var evtName = $"{cmdName}Failed";
            await plumber.AppendEventToStream(cmdStream, evt, StreamState.Any, evtName);
            log.LogDebug(ex,"Command {CommandType}Failed appended to session steam {CommandStream}.", command.GetType().Name,
                cmdStream);
        }
    }
    
    public static IServiceCollection RegisterHandlers(IServiceCollection services)
    {
        return THandler.RegisterHandlers(services);
    }
    
    static IEnumerable<Type> ITypeRegister.Types => THandler.CommandTypes;
}


// --- File: MicroPlumberd.Services\CommandHandlerMetadataExtensions.cs ---


namespace MicroPlumberd.Services;

public static class CommandHandlerMetadataExtensions
{
    public static string RecipientId(this Metadata m) => m.TryGetValue<string>("RecipientId", out var v)
        ? v
        : throw new InvalidOperationException("RecipientId not found in command");
}


// --- File: MicroPlumberd.Services\CommandHandlerService.cs ---


using System.Diagnostics;
using System.Text;
using EventStore.Client;
using MicroPlumberd.Utils;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services;

sealed class CommandHandlerService(ILogger<CommandHandlerService> log, IPlumber plumber, IEnumerable<ICommandHandlerStarter> starters) : BackgroundService, IEventHandler
{
    private readonly Dictionary<Type, IEventHandler> _handlersByCommand = new();
    private IAsyncDisposable? _subscription;
    private Dictionary<string, Type> _eventMapper;
    public bool IsReady { get; private set; }
    
    public override void Dispose()
    {
        if(_subscription != null)
            Task.WaitAll(_subscription.DisposeAsync().AsTask());
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        try
        {
            _handlersByCommand.Clear();
            foreach (var i in starters)
            {
                var executor = CommandHandlerExecutor.Create(plumber, i.HandlerType);
                foreach (var c in i.CommandTypes) _handlersByCommand.Add(c, executor);
            }

            if (_handlersByCommand.Count == 0)
            {
                IsReady = true;
                return;
            }
            this._eventMapper = _handlersByCommand.Keys.ToDictionary(x => x.Name);
            var events = _handlersByCommand.Keys.Select(x => x.Name).ToArray();

            var settings = plumber.Config.Conventions.ServicesConventions();
            var outputStream = settings.AppCommandStreamConvention();

            if (settings.AreCommandHandlersExecutedPersistently())
                this._subscription = await plumber.SubscribeEventHandlerPersistently(MapCommandType, events, this,
                    outputStream, AppDomain.CurrentDomain.FriendlyName, StreamPosition.End, true, token: stoppingToken);
            else
                this._subscription = await plumber.SubscribeEventHandler(MapCommandType, events, this, outputStream,
                    FromStream.End, true);
            IsReady = true;
        }
        catch (OperationCanceledException ex)
        {
            // do nothing
        }
        catch(Exception ex)
        {
            throw;
        }
    }

    private bool MapCommandType(string evtType, out Type t)
    {
        Debug.WriteLine($"Handling {evtType} command.");
        if (_eventMapper.TryGetValue(evtType, out t))
        {
            Debug.WriteLine($"Handling command: {evtType}");
            return true;
        }

        log.LogError(new StringBuilder().Append("Found unrecognized command type in app command stream. ")
            .Append(evtType)
            .ToString());

        return false;
    }

    
    public async Task Handle(Metadata m, object ev)
    {
        if (_handlersByCommand.TryGetValue(ev.GetType(), out var executor))
        {
            var tmp = InvocationContext.Current.Clone();
            _ = Task.Run(async () =>
            {
                using var scope = new InvocationScope(tmp);
                if(IdDuckTyping.Instance.TryGetGuidId(ev, out var id))
                    scope.SetCausation(id);
                await executor.Handle(m, ev);
            });
        } 
    }

   
}


// --- File: MicroPlumberd.Services\CommandHandlerStarter.cs ---


using EventStore.Client;

namespace MicroPlumberd.Services;

class CommandHandlerStarter<THandler>(IPlumber plumber) : ICommandHandlerStarter
    where THandler : ICommandHandler, IServiceTypeRegister
{
    public async Task Start()
    {
        await plumber.SubscribeCommandHandler<THandler>(Persistently, StreamStartPosition);
    }

    public IEnumerable<Type> CommandTypes => THandler.CommandTypes;
    public Type HandlerType => typeof(THandler);

    public ICommandHandlerStarter Configure(bool? persistently, StreamPosition? start)
    {
        this.Persistently = persistently;
        this.StreamStartPosition = start;
        return this;
    }

    public StreamPosition? StreamStartPosition { get; private set; }

    public bool? Persistently { get; private set; }
}

public static class StreamPositionExtensions
{
    public static StreamPosition ToStreamPosition(this FromStream fs)
    {
        StreamPosition sp = StreamPosition.Start;
        if (fs == FromStream.End)
            sp = StreamPosition.End;
        else if (fs != FromStream.Start)
        {
            var i = fs.ToUInt64();
            sp = StreamPosition.FromInt64((long)i);
        }

        return sp;
    }
}
class EventHandlerStarter<THandler>(IPlumber plumber) : IEventHandlerStarter
    where THandler : class, IEventHandler, ITypeRegister
{
    private FromStream _startPosition;
    private FromRelativeStreamPosition _relativeStartPosition;
    private bool _persistently;
    public async Task Start(CancellationToken stoppingToken)
    {
        if (!_persistently)
            await plumber.SubscribeEventHandler<THandler>(start: _relativeStartPosition, token: stoppingToken);
        else
            await plumber.SubscribeEventHandlerPersistently<THandler>(startFrom: _startPosition.ToStreamPosition(), token: stoppingToken);
    }

    public EventHandlerStarter<THandler> Configure(bool persistently = false, FromStream? start = null)
    {
        this._persistently = persistently;
        this._startPosition = start ?? FromStream.Start;
        this._relativeStartPosition = _startPosition;
        return this;
    }
    public EventHandlerStarter<THandler> Configure(FromRelativeStreamPosition? start = null)
    {
        this._persistently = false;
        this._relativeStartPosition = start ?? FromRelativeStreamPosition.Start;
        return this;
    }

}
class EventStateHandlerStarter<THandler>(IPlumber plumber) : IEventHandlerStarter
    where THandler : class, IEventHandler, ITypeRegister
{
    
    private FromRelativeStreamPosition _relativeStartPosition;
    
    public async Task Start(CancellationToken stoppingToken)
    {
        await plumber.SubscribeStateEventHandler<THandler>(start:_relativeStartPosition, token: stoppingToken);
    }

   
    public EventStateHandlerStarter<THandler> Configure(FromRelativeStreamPosition? start = null)
    {
        this._relativeStartPosition = start ?? FromRelativeStreamPosition.End - 1;
        return this;
    }

}


// --- File: MicroPlumberd.Services\ContainerExtensions.cs ---


using EventStore.Client;

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services;

class EventHandlerExecutor<TOwner>(TOwner handler) : IEventHandler<TOwner>
    where TOwner : IEventHandler
{
    public Task Handle(Metadata m, object ev) => handler.Handle(m, ev);
}
class ScopedEventHandlerExecutor<TOwner>(IServiceProvider sp) : IEventHandler<TOwner>
    where TOwner : IEventHandler
{
    public async Task Handle(Metadata m, object ev)
    {
        await using var scope = sp.CreateAsyncScope(); 
        await scope.ServiceProvider.GetRequiredService<TOwner>().Handle(m, ev);
    }
}
public static class ContainerExtensions
{
    public static IServiceCollection AddPlumberd(this IServiceCollection collection,
        EventStoreClientSettings? settings = null, Action<IServiceProvider, IPlumberConfig>? configure = null, bool scopedCommandBus = false, int commandBusPoolSize = 64) =>
        collection.AddPlumberd(sp => settings, configure, scopedCommandBus, commandBusPoolSize);

    /// <summary>
    /// Adds the MicroPlumberd services to the specified <see cref="IServiceCollection"/>.
    /// </summary>
    /// <param name="collection">
    /// The <see cref="IServiceCollection"/> to which the services will be added.
    /// </param>
    /// <param name="settingsFactory">
    /// A factory function to create <see cref="EventStoreClientSettings"/> for configuring the Event Store client.
    /// </param>
    /// <param name="configure">
    /// An optional action to configure the <see cref="IPlumberConfig"/> instance.
    /// </param>
    /// <param name="scopedCommandBus">
    /// A boolean value indicating whether the <see cref="ICommandBus"/> should be registered as scoped.
    /// </param>
    /// <param name="commandBusPoolSize">
    /// The size of the command bus pool - it's used for QueueAsync operation on ICommandBus. Defaults to 64.
    /// </param>
    /// <returns>
    /// The updated <see cref="IServiceCollection"/> with the MicroPlumberd services added.
    /// </returns>
    public static IServiceCollection AddPlumberd(this IServiceCollection collection,
        Func<IServiceProvider, EventStoreClientSettings> settingsFactory, Action<IServiceProvider, IPlumberConfig>? configure = null, bool scopedCommandBus = false, int commandBusPoolSize=64)
    {
        collection.AddSingleton(sp => Plumber.Create(settingsFactory(sp), x =>
        {
            configure?.Invoke(sp, x);
            x.ServiceProvider = sp;
        }));
        collection.AddSingleton<StartupHealthCheck>();
        
        collection.AddBackgroundServiceIfMissing<CommandHandlerService>();
        collection.AddBackgroundServiceIfMissing<EventHandlerService>();
        
        collection.TryAddSingleton(typeof(ISnapshotPolicy<>), typeof(AttributeSnaphotPolicy<>));
        if (scopedCommandBus)
        {
            collection.TryAddScoped<ICommandBus>(sp =>
            {
                var pool = (CommandBusPoolScoped)sp.GetRequiredService<ICommandBusPool>();
                var sb = new CommandBus(sp.GetRequiredService<IPlumber>(), pool,
                    sp.GetRequiredService<ILogger<CommandBus>>());
                pool.Init();
                return sb;
            });
            collection.TryAddSingleton<ICommandBusPool>(sp => new CommandBusPoolScoped(sp, commandBusPoolSize));
        }
        else
        {
            collection.TryAddSingleton<ICommandBus, CommandBus>();
            collection.TryAddSingleton<ICommandBusPool>(sp => new CommandBusPool(sp, commandBusPoolSize).Init());
        }
        collection.TryAddSingleton(typeof(IEventHandler<>), typeof(EventHandlerExecutor<>));
        
        
        collection.TryDecorate<ICommandBus, CommandBusAttributeValidator>();

        return collection;
    }

    public static IServiceCollection AddBackgroundServiceIfMissing<TService>(this IServiceCollection services)
        where TService : BackgroundService
    {
        // Check if the service is already added
        var serviceDescriptor = services.FirstOrDefault(descriptor =>
            descriptor.ServiceType == typeof(IHostedService) &&
            descriptor.ImplementationType == typeof(TService));

        // Add the service if it's missing
        if (serviceDescriptor != null) return services;
        
        services.TryAddSingleton<TService>();
        services.AddHostedService(sp => sp.GetRequiredService<TService>());

        return services;
    }
    public static IServiceCollection AddEventHandler<TEventHandler>(this IServiceCollection services, bool persistently = false, FromStream? start = null) where TEventHandler : class, IEventHandler, ITypeRegister
    {
        services.AddSingleton<EventHandlerStarter<TEventHandler>>();
        services.AddSingleton<IEventHandlerStarter>(sp => sp.GetRequiredService<EventHandlerStarter<TEventHandler>>().Configure(persistently, start));
        services.AddSingleton<IEventHandler<TEventHandler>, ScopedEventHandlerExecutor<TEventHandler>>();
        services.TryAddScoped<TEventHandler>();
        return services;
    }
    public static IServiceCollection AddStateEventHandler<TEventHandler>(this IServiceCollection services) where TEventHandler : class, IEventHandler, ITypeRegister
    {   
        services.AddSingleton<EventStateHandlerStarter<TEventHandler>>();
        services.AddSingleton<IEventHandlerStarter>(sp => sp.GetRequiredService<EventStateHandlerStarter<TEventHandler>>().Configure(FromRelativeStreamPosition.End-1));
        services.AddSingleton<IEventHandler<TEventHandler>, ScopedEventHandlerExecutor<TEventHandler>>();
        services.TryAddScoped<TEventHandler>();
        return services;
    }
    public static IServiceCollection AddEventHandler<TEventHandler>(this IServiceCollection services, FromRelativeStreamPosition start) where TEventHandler : class, IEventHandler, ITypeRegister
    {
        services.AddSingleton<EventHandlerStarter<TEventHandler>>();
        services.AddSingleton<IEventHandlerStarter>(sp => sp.GetRequiredService<EventHandlerStarter<TEventHandler>>().Configure(start));
        services.AddSingleton<IEventHandler<TEventHandler>, ScopedEventHandlerExecutor<TEventHandler>>();
        services.TryAddScoped<TEventHandler>();
        return services;
    }
    public static IServiceCollection AddCommandHandler<TCommandHandler>(this IServiceCollection services, bool persistently = false, StreamPosition? start = null) where TCommandHandler:ICommandHandler, IServiceTypeRegister
    {
        services.AddSingleton<CommandHandlerStarter<TCommandHandler>>();
        services.AddSingleton<ICommandHandlerStarter>(sp => sp.GetRequiredService<CommandHandlerStarter<TCommandHandler>>().Configure(persistently, start));
        services.TryAddSingleton(typeof(CommandHandlerExecutor<>));
        TCommandHandler.RegisterHandlers(services);
        return services;
    }
}


// --- File: MicroPlumberd.Services\EventHandlerService.cs ---


using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using EventStore.Client;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
[assembly: InternalsVisibleTo("MicroPlumberd.Tests.App.Dsl")]
namespace MicroPlumberd.Services;

sealed class EventHandlerService(IEnumerable<IEventHandlerStarter> starters) : BackgroundService
{
    public bool IsReady { get; private set; } = false;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        try
        {
            foreach (var i in starters)
                await i.Start(stoppingToken);
            IsReady = true;
        }
        catch (OperationCanceledException ex)
        {
            // we dont do enything. operation was canceled.
        }
        catch (Exception ex)
        {
            throw;
        }
    }
}

internal sealed class StartupHealthCheck(EventHandlerService eventHandlers, CommandHandlerService commandHandlers, ILogger<StartupHealthCheck> logger) : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())
    {
        if (!eventHandlers.IsReady)
            return HealthCheckResult.Unhealthy("Event handlers' projections are not ready.");
        if(!commandHandlers.IsReady)
            return HealthCheckResult.Unhealthy("Command handlers' projections are not ready.");
        
        return HealthCheckResult.Healthy();
    }
}
public static class HealthCheckExtensions
{
    public static IHealthChecksBuilder AddPlumberdHealthChecks(this IHealthChecksBuilder builder)
    {
        builder.AddTypeActivatedCheck<StartupHealthCheck>("Plumberd Startup Health Check");
            return builder;
    }
}


// --- File: MicroPlumberd.Services\Events.cs ---


using System.Net;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using System.Text.Json;

namespace MicroPlumberd.Services;

interface ICommandSource
{
    public Guid CommandId { get; }
}

[DataContract]
internal record CommandExecuted : ICommandSource
{
    [DataMember(Order=1)]
    public Guid CommandId { get; set; }
    [DataMember(Order=2)]
    public TimeSpan Duration { get; set; }
}
[DataContract]
internal record CommandFailed : ICommandFailed
{
    [DataMember(Order = 1)]
    public Guid CommandId { get; set; }
    [DataMember(Order = 2)]
    public TimeSpan Duration { get; set; }
    [DataMember(Order = 3)]
    public string Message { get; set; }
    [DataMember(Order = 4)]
    public HttpStatusCode Code { get; set; }

    public static ICommandFailedEx Create(Guid commandId, string message, TimeSpan duration, HttpStatusCode code, object fault)
    {
        var type = typeof(CommandFailed<>).MakeGenericType(fault.GetType());
        return (ICommandFailedEx)Activator.CreateInstance(type, commandId, message,duration, code, fault)!;
    }
}

interface ICommandFailed : ICommandSource
{
    
    TimeSpan Duration { get; }
    string Message { get; }
    public HttpStatusCode Code { get; }

}
interface ICommandFailedEx : ICommandFailed
{
    object Fault { get; }

}
[DataContract]
internal record CommandFailed<TFault> : CommandFailed, ICommandFailedEx
{
    public CommandFailed() { }

    object ICommandFailedEx.Fault => this.Fault;
    public CommandFailed(Guid commandId, string message, TimeSpan duration, HttpStatusCode code, TFault Fault)
    {
        this.Fault = Fault;
        this.CommandId = commandId;
        this.Duration = duration;
        this.Message = message;
        this.Code = code;
    }
    [DataMember(Order = 1)]
    public TFault Fault { get; set; }
  
}



// --- File: MicroPlumberd.Services\ICommandBusOwner.cs ---


namespace MicroPlumberd.Services;

public interface ICommandBusOwner : IDisposable
{
    Task SendAsync(object recipientId, object command, TimeSpan? timeout = null, bool fireAndForget = false,
        CancellationToken token = default);
}


// --- File: MicroPlumberd.Services\ICommandBusPool.cs ---


namespace MicroPlumberd.Services;

/// <summary>
/// Represents a pool of command buses that can be rented and returned for managing command execution.
/// </summary>
public interface ICommandBusPool
{
    /// <summary>
    /// Rents an <see cref="ICommandBusOwner"/> instance from the pool, allowing the caller to send commands
    /// using the rented command bus. The rented instance must be returned to the pool after use by calling dispose
    /// </summary>
    /// <param name="ct">A <see cref="CancellationToken"/> to observe while waiting for a command bus to become available.</param>
    /// <returns>
    /// A <see cref="ValueTask{TResult}"/> representing the asynchronous operation. The result contains
    /// an <see cref="ICommandBusOwner"/> instance that can be used to send commands.
    /// </returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if the pool is empty and no command bus is available for rent.
    /// </exception>
    ValueTask<ICommandBusOwner> RentScope(CancellationToken ct = default);
}


// --- File: MicroPlumberd.Services\ICommandHandler.cs ---


namespace MicroPlumberd.Services;

public interface ICommandHandler
{
    Task<object?> Execute(string id, object command);
}
public interface ICommandHandler<in TCommand> : ICommandHandler
{
    Task<object?> ICommandHandler.Execute(string id, object command) => Execute(id, (TCommand)command);
    Task<object?> Execute(string id, TCommand command);
}
public interface ICommandHandler<in TId, in TCommand> : ICommandHandler<TCommand>
where TId:IParsable<TId>
{
    Task<object?> Execute(TId id, TCommand command);

    Task<object?> ICommandHandler<TCommand>.Execute(string id, TCommand command) => Execute(TId.Parse(id,null), command);
}


// --- File: MicroPlumberd.Services\ICommandHandlerStarter.cs ---


namespace MicroPlumberd.Services;

interface IEventHandlerStarter
{
    Task Start(CancellationToken stoppingToken);
}
interface ICommandHandlerStarter
{
    IEnumerable<Type> CommandTypes { get; }
    Type HandlerType { get; }
}


// --- File: MicroPlumberd.Services\IServiceTypeRegister.cs ---


using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd.Services;

public interface IServiceTypeRegister
{
    static abstract IEnumerable<Type> ReturnTypes { get; }
    static abstract IEnumerable<Type> FaultTypes { get; }
    static abstract IEnumerable<Type> CommandTypes { get; }
    static abstract IServiceCollection RegisterHandlers(IServiceCollection services);
}


// --- File: MicroPlumberd.Services\PlumberdConventionsExtensions.cs ---


namespace MicroPlumberd.Services;




// --- File: MicroPlumberd.Services\PlumberExtensions.cs ---


using System.Runtime.CompilerServices;
using EventStore.Client;
using Microsoft.Extensions.DependencyInjection;
namespace MicroPlumberd.Services;

public static class PlumberExtensions
{
    public static Task<IAsyncDisposable> SubscribeCommandHandler<TCommandHandler>(this IPlumber plumber, bool? subscribePersistently, StreamPosition? streamStartPosition) where TCommandHandler:ICommandHandler, IServiceTypeRegister
    {
        var commandHandlerType = typeof(TCommandHandler);
        var servicesConventions = plumber.Config.Conventions.ServicesConventions();
        var outputStream = servicesConventions.OutputSteamNameFromCommandHandlerConvention(commandHandlerType);
        var groupName = servicesConventions.GroupNameFromCommandHandlerConvention(commandHandlerType);
        var executor = plumber.Config.ServiceProvider.GetRequiredService<CommandHandlerExecutor<TCommandHandler>>();
        var persistently = subscribePersistently ?? plumber.Config.Conventions.ServicesConventions().IsHandlerExecutionPersistent(typeof(TCommandHandler));
        if (persistently)
            return plumber.SubscribeEventHandlerPersistently(executor, outputStream, groupName, startFrom: streamStartPosition ?? StreamPosition.End);
        else return plumber.SubscribeEventHandler(executor, outputStream, FromStream.End);
    }

  
}


// --- File: MicroPlumberd.Services\ServicesConvention.cs ---


using System.Reflection;

namespace MicroPlumberd.Services;

/// <summary>
/// Represents a delegate that returns the output stream name from a command handler type.
/// </summary>
/// <param name="commandHandlerType">The type of the command handler.</param>
/// <returns>The name of the output stream.</returns>
public delegate string OutputSteamNameFromCommandHandler(Type commandHandlerType);
/// <summary>
/// Represents a delegate that returns the group name for a given command handler type.
/// </summary>
/// <param name="commandHandlerType">The type of the command handler.</param>
/// <returns>The group name for the command handler.</returns>
public delegate string GroupNameFromCommandHandler(Type commandHandlerType);
/// <summary>
/// Represents a delegate that returns the name of a command based on its type.
/// </summary>
/// <param name="command">The type of the command.</param>
/// <returns>The name of the command.</returns>
public delegate string CommandName(Type command);
/// <summary>
/// Represents a delegate that returns a collection of command message types.
/// </summary>
/// <param name="command">The command type.</param>
/// <returns>A collection of tuples containing the message name and message type.</returns>
public delegate IEnumerable<(string, Type)> CommandMessageTypes(Type command);
/// <summary>
/// Represents a delegate that returns a string representing the application's command stream.
/// </summary>
/// <returns>A string representing the application command stream.</returns>
public delegate string AppCommandStream();

/// <summary>
/// Represents a delegate that takes a session ID and returns a session stream.
/// </summary>
/// <param name="id">The session ID.</param>
/// <returns>The session stream.</returns>
public delegate string SessionStreamFromSessionId(Guid id);
/// <summary>
/// Convention setting interface for plumberd framework.
/// </summary>
public interface IServicesConvention
{
    /// <summary>
    /// Gets or sets the convention for output stream name from command handler.
    /// </summary>
    OutputSteamNameFromCommandHandler OutputSteamNameFromCommandHandlerConvention { get; set; }
    /// <summary>
    /// Gets or sets the convention for determining the group name for a persisted subscription for a command handler.
    /// </summary>
    GroupNameFromCommandHandler GroupNameFromCommandHandlerConvention { get; set; }
    /// <summary>
    /// Gets or sets the application command's stream convention.
    /// </summary>
    AppCommandStream AppCommandStreamConvention { get; set; }
    /// <summary>
    /// Gets or sets the command message types.
    /// </summary>
    CommandMessageTypes CommandMessageTypes { get; set; }
    /// <summary>
    /// Gets or sets the command name convention.
    /// </summary>
    CommandName CommandNameConvention { get; set; }
    /// <summary>
    /// Gets or sets the convention for session command input stream from session ID.
    /// </summary>
    SessionStreamFromSessionId SessionInStreamFromSessionIdConvention { get; set; }
    /// <summary>
    /// Gets or sets the convention for obtaining the session output stream from the session ID.
    /// </summary>
    SessionStreamFromSessionId SessionOutStreamFromSessionIdConvention { get; set; }
    /// <summary>
    /// Used only for manual subscribing: plumberd.SubscribeCommandHandler<THandler>()
    /// </summary>
    IsHandlerExecutionPersistent IsHandlerExecutionPersistent { get; set; }
    /// <summary>
    /// Gets or sets a function that determines whether the command handlers are executed persistently.
    /// </summary>
    /// <remarks>
    /// The value of this property should be a function that returns a boolean value indicating whether the handlers should be executed persistently.
    /// </remarks>
    Func<bool> AreCommandHandlersExecutedPersistently { get; set; }
    /// <summary>
    /// Gets or sets the filter used to determine whether a command handler should skip a command.
    /// </summary>
    /// <remarks>
    /// The filter is a function that takes a <see cref="Metadata"/> object and an object as parameters,
    /// and returns a boolean value indicating whether the command handler should be skipped.
    /// </remarks>
    Func<Metadata, object, bool> CommandHandlerSkipFilter {get; set;}
}

/// <summary>
/// Represents the configuration for services.
/// </summary>
public interface IServicesConfig
{
    /// <summary>
    /// Gets or sets the default timeout for services.
    /// </summary>
    TimeSpan DefaultTimeout { get; set; } 
}
class ServicesConfig : IServicesConfig
{
    public TimeSpan DefaultTimeout { get; set; } = TimeSpan.FromMinutes(2);
}

/// <summary>
/// Represents a delegate that determines whether the execution of a handler is persistent.
/// </summary>
/// <param name="handlerType">The type of the handler.</param>
/// <returns><c>true</c> if the execution of the handler is persistent; otherwise, <c>false</c>.</returns>
public delegate bool IsHandlerExecutionPersistent(Type handlerType);
class ServicesConvention : IServicesConvention
{
    public IsHandlerExecutionPersistent IsHandlerExecutionPersistent { get; set; } = static x => false;
    public Func<bool> AreCommandHandlersExecutedPersistently { get; set; } = () => false;
    public Func<Metadata, object, bool> CommandHandlerSkipFilter { get; set; } = (m, e) => false;
    public OutputSteamNameFromCommandHandler OutputSteamNameFromCommandHandlerConvention { get; set; } = static x => $">{x.GetFriendlyName()}";
    public GroupNameFromCommandHandler GroupNameFromCommandHandlerConvention { get; set; } = static x => $"{x.GetFriendlyName()}";
    public AppCommandStream AppCommandStreamConvention { get; set; } = static () => $">{AppDomain.CurrentDomain.FriendlyName}";
    public CommandName CommandNameConvention { get; set; } = static x => $"{x.Name}";
    
    public SessionStreamFromSessionId SessionInStreamFromSessionIdConvention { get; set; } = static x => $">SessionIn-{x}";
    public SessionStreamFromSessionId SessionOutStreamFromSessionIdConvention { get; set; } = static x => $">SessionOut-{x}";
    public CommandMessageTypes CommandMessageTypes { get; set; }

    public ServicesConvention()
    {
        CommandMessageTypes = x => CommandMappings.Discover(this.CommandNameConvention,x);
    }
}
/// <summary>
/// Provides extension methods for working with conventionson service-layer.
/// </summary>
public static class PlumberdConventionsExtensions
{
    /// <summary>
    /// Retrieves the services conventions from the specified root conventions.
    /// </summary>
    /// <param name="conventions">The conventions to retrieve the services conventions from.</param>
    /// <returns>The services conventions.</returns>
    public static IServicesConvention ServicesConventions(this IConventions conventions) =>
        conventions.GetExtension<ServicesConvention>();

    /// <summary>
    /// Retrieves the services conventions from the specified read-only conventions.
    /// </summary>
    /// <param name="conventions">The read-only conventions to retrieve the services conventions from.</param>
    /// <returns>The services conventions.</returns>
    public static IServicesConvention ServicesConventions(this IReadOnlyConventions conventions) =>
        conventions.GetExtension<ServicesConvention>();

    /// <summary>
    /// Retrieves the services configuration from the specified plumber configuration.
    /// </summary>
    /// <param name="config">The plumber configuration to retrieve the services configuration from.</param>
    /// <returns>The services configuration.</returns>
    public static IServicesConfig ServicesConfig(this IPlumberConfig config) =>
        config.GetExtension<ServicesConfig>();

    /// <summary>
    /// Retrieves the services configuration from the specified read-only plumber configuration.
    /// </summary>
    /// <param name="config">The read-only plumber configuration to retrieve the services configuration from.</param>
    /// <returns>The services configuration.</returns>
    public static IServicesConfig ServicesConfig(this IPlumberReadOnlyConfig config) =>
        config.GetExtension<ServicesConfig>();
}

class CommandMappings
{
    public static IEnumerable<(string, Type)> Discover(CommandName commandNameConvention, Type command)
    {
        var cmdType = commandNameConvention(command);

        yield return (cmdType, command);
        yield return ($"{cmdType}Executed", typeof(CommandExecuted));
        yield return ($"{cmdType}Failed", typeof(CommandFailed));
        foreach (var c in command
                     .GetCustomAttributes()
                     .Where(x => x is ThrowsFaultExceptionAttribute)
                     .OfType<ThrowsFaultExceptionAttribute>()
                     .Select(x => x.ThrownType))
            yield return ($"{cmdType}Failed<{c.Name}>", typeof(CommandFailed<>).MakeGenericType(c));
    }
}


// --- File: MicroPlumberd.Services\ThrowsFaultExceptionAttribute.cs ---


namespace MicroPlumberd.Services;

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple=true)]
public class ThrowsFaultExceptionAttribute<TMessage>() : ThrowsFaultExceptionAttribute(typeof(TMessage));


// --- File: MicroPlumberd.Services.LiteDb\Class1.cs ---


using EventStore.Client;
using LiteDB;
using LiteDB.Engine;
using System.Xml;

namespace MicroPlumberd.Services.LiteDb
{
    public class PayloadData<TPayload> 
    {
        public Guid Id { get; set; }
        public TPayload Payload { get; set; }
    }

    public class Event
    {
        public long Id { get; set; }
        public Guid EventId { get; set; }
        public string EventName { get; set; }
        public long StreamPosition { get; set; }

        public string StreamFullName { get; set; }
        
        public string StreamId { get; set; }
        public string StreamCategory { get; set; }
        public IDictionary<string, string> Metadata { get; set; }
    }

    public class Stream
    {
        public Guid Id { get; set; }
        public string Category { get; set; }
        public string FullName { get; set; }

        public long Position { get; set; }
    }

    

    public class LiteEventStore
    {
        public interface IPlayloadEvents
        {
            Guid Insert(object evt, Guid evtId);
        }
        interface IGenericCollectionFactory
        {
            IPlayloadEvents Create(LiteDatabase db, string name);
        }

        class PayloadsFactory<T> : IGenericCollectionFactory
        {
            public IPlayloadEvents Create(LiteDatabase db, string name)
            {
                return new PayloadCollection<T>(db.GetCollection<PayloadData<T>>(name));
            }
        }
        class PayloadCollection<T> : IPlayloadEvents
        {
            public ILiteCollection<PayloadData<T>> Collection { get; }
            public PayloadCollection(ILiteCollection<PayloadData<T>> collection)
            {
                Collection = collection;
            }


            public Guid Insert(object evt, Guid evtId)
            {
                return Collection.Insert(new PayloadData<T>() { Payload = (T)evt, Id = evtId}).AsGuid;
            }
        }
        private readonly LiteDatabase _storage;
        public bool BeginTrans() => _storage.BeginTrans();

        public bool Commit() => _storage.Commit();

        public bool Rollback() => _storage.Rollback();

        public LiteEventStore(LiteDatabase storage)
        {
            _storage = storage;
            var mapper = BsonMapper.Global;

            mapper.Entity<Event>()
                .Id(x => x.Id,true);

            
            
        }

        public IPlayloadEvents GetCollection(Type t, string name)
        {
            var ct= typeof(PayloadsFactory<>).MakeGenericType(t);
            var factory = (IGenericCollectionFactory)Activator.CreateInstance(ct);
            return factory.Create(_storage, name);
        }
        public ILiteCollection<PayloadData<TPayload>> Payloads<TPayload>(string name) => _storage.GetCollection<PayloadData<TPayload>>(name);
        public ILiteCollection<Event> Events => _storage.GetCollection<Event>("events");
        public ILiteCollection<Stream> Streams => _storage.GetCollection<Stream>("streams");

        public Guid InsertPayload(object evt, string evtName, Uuid evId)
        {
            var evts = this.GetCollection(evt.GetType(), evtName);
            return evts.Insert(evt, evId.ToGuid());
        }
    }


    public class LiteDbPlumber(LiteEventStore storage) : IPlumber
    {
        public IPlumberReadOnlyConfig Config { get; }
        public EventStoreClient Client { get; }
        public EventStorePersistentSubscriptionsClient PersistentSubscriptionClient { get; }
        public EventStoreProjectionManagementClient ProjectionManagementClient { get; }
        public IProjectionRegister ProjectionRegister { get; }
        public ITypeHandlerRegisters TypeHandlerRegisters { get; }
        public async Task<IWriteResult> AppendEvent(object evt, object? id = null, object? metadata = null, StreamState? state = null, string? evtName = null, CancellationToken token = default)
        {
            if (evt == null) throw new ArgumentException("evt cannot be null.");


            evtName ??= Config.Conventions.GetEventNameConvention(null, evt.GetType());
            var m = Config.Conventions.GetMetadata(null, evt, metadata);
            var st = state ?? StreamState.Any;
            var streamId = Config.Conventions.StreamNameFromEventConvention(evt.GetType(), id);
            var evId = Config.Conventions.GetEventIdConvention(null, evt);

            storage.BeginTrans();
            var stream = storage.Streams.FindOne(x => x.FullName == streamId);
            stream.Position += 1;
            storage.Streams.Update(stream);
            
            var evtId = storage.InsertPayload(evt, evtName, evId);
            storage.Events.Insert(new Event()
            {
                EventId = evtId,
                EventName = evtName,
                StreamId = id?.ToString() ?? string.Empty,
                StreamFullName = streamId,
                StreamPosition = stream.Position,
            });

            storage.Commit();
            return null;
        }

        public ISubscriptionSet SubscribeSet()
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TEventHandler? eh = default, string? outputStream = null,
            FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
            CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TEventHandler? model = default(TEventHandler?),
            string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
            bool ensureOutputStreamProjection = true, int minCheckPointCount = 1, CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public Task Rehydrate<T>(T model, string streamId, TypeEventConverter converter, StreamPosition? position = null,
            CancellationToken token = default) where T : IEventHandler
        {
            throw new NotImplementedException();
        }

        public async Task<T> Get<T>(object id, CancellationToken token = default) where T : IAggregate<T>, ITypeRegister, IId
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> SaveChanges<T>(T aggregate, object? metadata = null, CancellationToken token = default) where T : IAggregate<T>, IId
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> SaveNew<T>(T aggregate, object? metadata = null, CancellationToken token = default) where T : IAggregate<T>, IId
        {
            throw new NotImplementedException();
        }

        public async Task<Snapshot<T>?> GetSnapshot<T>(Guid id, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<Snapshot?> GetSnapshot(object id, Type snapshotType, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendState(object state, object id, long? version = null, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendState<T>(T state, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<SubscriptionRunnerState<T>?> GetState<T>(object id, string? streamId = null, CancellationToken token = default) where T : class
        {
            throw new NotImplementedException();
        }

        public IAsyncEnumerable<(T, Metadata)> ReadEventsOfType<T>(string? streamId = null, StreamPosition? start = null, Direction? direction = null,
            long maxCount = 9223372036854775807, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(IEnumerable<string>? eventTypes, TEventHandler? eh = default,
            string? outputStream = null, FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
            CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeStateEventHandler<TEventHandler>(TEventHandler? eh = default(TEventHandler?), string? outputStream = null,
            FromRelativeStreamPosition? start = null, bool ensureOutputStreamProjection = true,
            CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public Task TryCreateJoinProjection(string outputStream, IEnumerable<string> eventTypes, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public Task TryCreateJoinProjection<TEventHandler>(string? outputStream = null, CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public Task<IWriteResult> AppendStreamMetadataFromEvent<TEvent>(object id, StreamState? state = null, TimeSpan? maxAge = null,
            StreamPosition? truncateBefore = null, TimeSpan? cacheControl = null, StreamAcl? acl = null, int? maxCount = null)
        {
            throw new NotImplementedException();
        }

        public Task<IWriteResult> AppendStreamMetadataFromHandler<THandler>(StreamState? state = null, TimeSpan? maxAge = null,
            StreamPosition? truncateBefore = null, TimeSpan? cacheControl = null, StreamAcl? acl = null, int? maxCount = null)
        {
            throw new NotImplementedException();
        }

        public Task<IWriteResult> AppendStreamMetadataFromAggregate<TAggregate>(object id, StreamState? state = null, TimeSpan? maxAge = null,
            StreamPosition? truncateBefore = null, TimeSpan? cacheControl = null, StreamAcl? acl = null, int? maxCount = null)
        {
            throw new NotImplementedException();
        }

        public Task<IWriteResult> AppendStreamMetadata(string streamId, StreamState? state, TimeSpan? maxAge, StreamPosition? truncateBefore,
            TimeSpan? cacheControl, StreamAcl? acl, int? maxCount)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendLink(string streamId, ulong streamPosition, string streamSourceId, StreamState? state = null,
            CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        

        public async Task<IWriteResult> AppendSnapshot(object snapshot, object id, long version, StreamState? state = null,
            CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public IAsyncEnumerable<(object, Metadata)> ReadFull(string streamId, TypeEventConverter converter, StreamPosition? start = null,
            Direction? direction = null, long maxCount = 9223372036854775807, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public IAsyncEnumerable<object> Read(string streamId, TypeEventConverter converter, StreamPosition? start = null,
            Direction? direction = null, long maxCount = 9223372036854775807, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public IAsyncEnumerable<object> Read<TOwner>(StreamPosition? start = null, Direction? direction = null,
            long maxCount = 9223372036854775807, CancellationToken token = default) where TOwner : ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TypeEventConverter mapFunc, IEnumerable<string>? events,
            TEventHandler? model, string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
            bool ensureOutputStreamProjection = true, int minCheckPointCount = 1, CancellationToken token = default) where TEventHandler : class, IEventHandler
        {
            throw new NotImplementedException();
        }

        public IAsyncEnumerable<object> Read<TOwner>(object id, StreamPosition? start = null, Direction? direction = null,
            long maxCount = 9223372036854775807, CancellationToken token = default) where TOwner : ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TypeEventConverter mapFunc, IEnumerable<string>? events,
            TEventHandler? model, string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
            bool ensureOutputStreamProjection = true, CancellationToken token = default) where TEventHandler : class, IEventHandler
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendLink(string streamId, Metadata metadata, StreamState? state = null, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task Rehydrate<T>(T model, Guid id, StreamPosition? position = null, CancellationToken token = default) where T : IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task Rehydrate<T>(T model, string stream, StreamPosition? position = null, CancellationToken token = default) where T : IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public ISubscriptionRunner SubscribePersistently(string streamName, string groupName, int bufferSize = 10,
            UserCredentials? userCredentials = null, CancellationToken cancellationToken = new CancellationToken())
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandlerPersistently<TEventHandler>(TEventHandler? model = default(TEventHandler?),
            string? outputStream = null, string? groupName = null, IPosition? startFrom = null,
            bool ensureOutputStreamProjection = true, CancellationToken token = default) where TEventHandler : class, IEventHandler, ITypeRegister
        {
            throw new NotImplementedException();
        }

        public async Task<IAsyncDisposable> SubscribeEventHandler<TEventHandler>(TypeEventConverter mapFunc, IEnumerable<string>? eventTypes,
            TEventHandler? eh = default, string? outputStream = null, FromStream? start = null,
            bool ensureOutputStreamProjection = true) where TEventHandler : class, IEventHandler
        {
            throw new NotImplementedException();
        }

        public ISubscriptionRunner Subscribe(string streamName, FromRelativeStreamPosition start,
            UserCredentials? userCredentials = null, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IEventRecord?> FindEventInStream(string streamId, Guid id, TypeEventConverter eventMapping,
            Direction scanDirection = Direction.Backwards, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IEventRecord<T>?> FindEventInStream<T>(string streamId, Guid id, TypeEventConverter eventMapping = null,
            Direction scanDirection = Direction.Backwards, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendEvents(string streamId, StreamState state, IEnumerable<object> events, object? metadata = null,
            CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendEventToStream(string streamId, object evt, StreamState? state = null, string? evtName = null,
            object? metadata = null, CancellationToken token = default)
        {
            throw new NotImplementedException();
        }

        public async Task<IWriteResult> AppendEvents(string streamId, StreamRevision rev, IEnumerable<object> events, object? metadata = null,
            CancellationToken token = default)
        {
            throw new NotImplementedException();
        }
    }
}



// --- File: MicroPlumberd.Services.ProcessManager\IProcessManagerClient.cs ---


namespace MicroPlumberd.Services.ProcessManagers;

public interface IProcessManagerClient
{
    IPlumber Plumber { get; }
    ICommandBus Bus { get; }

    Task<TProcessManager> GetManager<TProcessManager>(Guid commandRecipientId)
        where TProcessManager : IProcessManager, ITypeRegister;

    Task<IAsyncDisposable> SubscribeProcessManager<TProcessManager>() where TProcessManager : IProcessManager, ITypeRegister;
}



// --- File: MicroPlumberd.Services.ProcessManager\ProcessManagerClient.cs ---


using MicroPlumberd.Services;
using MicroPlumberd.Services.ProcessManagers;
using MicroPlumberd.Utils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd
{
    sealed class ProcessManagerService(IPlumber plumber, IEnumerable<IProcessManagerStarter> starters)
        : BackgroundService
    {
        public override void Dispose()
        {
            Task.WaitAll(starters.Select(x => x.DisposeAsync().AsTask()).ToArray());
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            foreach (var i in starters)
                await i.Start();
        }
    }
    public static class ContainerExtensions
    {
        public static IServiceCollection AddProcessManager<TProcessManager>(this IServiceCollection services) where TProcessManager : IProcessManager, ITypeRegister
        {
            services.TryAddSingleton<IProcessManagerClient, ProcessManagerClient>();
            services.AddSingleton<IProcessManagerStarter, CommandHandlerStarter<TProcessManager>>();
            services.AddBackgroundServiceIfMissing<ProcessManagerService>();
            return services;
        }
    }

    interface IProcessManagerStarter : IAsyncDisposable
    {
        Task Start();
    }
    class CommandHandlerStarter<TProcessManager>(IProcessManagerClient client) : IProcessManagerStarter where TProcessManager : IProcessManager, ITypeRegister
    {
        private IAsyncDisposable _sub;

        public async Task Start()
        {
            _sub = await client.SubscribeProcessManager<TProcessManager>();
        }

        public async ValueTask DisposeAsync()
        {
            await _sub.DisposeAsync();
        }
    }
}

namespace MicroPlumberd.Services.ProcessManagers
{
    public class ProcessManagerClient : IProcessManagerClient
    {
        private readonly IServiceProvider _serviceProvider;
        private readonly IPlumber _plumber;
        

        public ProcessManagerClient(IServiceProvider serviceProvider, IPlumber plumber, ICommandBus bus)
        {
            _serviceProvider = serviceProvider;
            _plumber = plumber;
            
            Bus = bus;
        }

        public ICommandBus Bus { get; }
        public IPlumber Plumber { get => _plumber; }

        public async Task<IAsyncDisposable> SubscribeProcessManager<TProcessManager>() where TProcessManager : IProcessManager, ITypeRegister
        {
            ProcessManagerExecutor<TProcessManager> executor = new ProcessManagerExecutor<TProcessManager>(this, _serviceProvider.GetRequiredService<ILogger<ProcessManagerExecutor<TProcessManager>>>());
            ProcessManagerExecutor<TProcessManager>.Sender sender =
                new ProcessManagerExecutor<TProcessManager>.Sender(this);
            var c = AsyncDisposableCollection.New();
            c += await Plumber.SubscribeEventHandlerPersistently(sender, $"{typeof(TProcessManager).Name}Outbox", ensureOutputStreamProjection: true);
            c += await Plumber.SubscribeEventHandlerPersistently(executor, $"{typeof(TProcessManager).Name}Inbox", ensureOutputStreamProjection: true);

            await Plumber.ProjectionManagementClient.EnsureLookupProjection(Plumber.ProjectionRegister,
                typeof(TProcessManager).Name, "RecipientId", $"{typeof(TProcessManager).Name}Lookup");

            return c;
        }
        internal T CreateProcessManager<T>()
        {
            if (_serviceProvider != null) return _serviceProvider.GetService<T>() ?? Activator.CreateInstance<T>();
            return Activator.CreateInstance<T>();
        }

        public async Task<TProcessManager> GetManager<TProcessManager>(Guid commandRecipientId) where TProcessManager : IProcessManager, ITypeRegister
        {
            var lookup = new ProcessManagerExecutor<TProcessManager>.Lookup();

            // This stream is created straight from 
            await _plumber.Rehydrate(lookup, $"{typeof(TProcessManager).Name}Lookup-{commandRecipientId}");

            var managerId = lookup.GetProcessManagerIdByReceiverId(commandRecipientId) ?? Guid.NewGuid();
            var manager = CreateProcessManager<TProcessManager>();
            if (manager is IIdAware a) a.Id = managerId;

            await _plumber.Rehydrate(manager, $"{typeof(TProcessManager).Name}-{managerId}");

            return manager;
        }
    }
}



// --- File: MicroPlumberd.Services.ProcessManager\ProcessManagerExecutor.cs ---


using System;
using System.Collections.Concurrent;
using EventStore.Client;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace MicroPlumberd.Services.ProcessManagers;

public class ProcessManagerExecutor<TProcessManager>(ProcessManagerClient pmClient, ILogger<ProcessManagerExecutor<TProcessManager>> log)  : IEventHandler, ITypeRegister
    where TProcessManager : IProcessManager, ITypeRegister
{
    public class Lookup : IEventHandler, ITypeRegister
    {
        private readonly Dictionary<Guid, Guid> _managerByReceiverId = new Dictionary<Guid, Guid>();
        public Guid? GetProcessManagerIdByReceiverId(Guid receiverId) => _managerByReceiverId.TryGetValue(receiverId, out var v) ? v : null;

        private void Given(Metadata m, ICommandEnqueued ev)
        {
            _managerByReceiverId[ev.RecipientId] = m.Id;
        }

        public async Task Handle(Metadata m, object ev)
        {
            if (ev is ICommandEnqueued sf)
                Given(m, sf);
        }
        
        public static IEnumerable<Type> Types=> TProcessManager.CommandTypes;
    }
    internal class Sender(IProcessManagerClient pmClient) : IEventHandler, ITypeRegister
    {
        public async Task Handle(Metadata m, object cmd)
        {
            var c = (ICommandEnqueued)cmd;
            try
            {
                await pmClient.Bus.SendAsync(c.RecipientId, c.Command);
            }
            catch (Exception ex)
            {
                var manager = await pmClient.GetManager<TProcessManager>(c.RecipientId);

                CommandInvocationFailed evt = new CommandInvocationFailed() { Command = CommandRequest.Create(c.RecipientId, c.Command), Message = ex.Message, RecipientId = c.RecipientId };
                var plm = pmClient.Plumber;
                var streamId = plm.Config.Conventions.GetStreamIdConvention(typeof(TProcessManager), manager.Id);
                await plm.AppendEvents(streamId, StreamState.Any, evt);

                Guid causationId = m.CausationId() ?? throw new InvalidOperationException("Causation id is not provided.");
                var causationEvent = await plm.FindEventInStream(streamId, causationId, pmClient.Plumber.TypeHandlerRegisters.GetEventNameConverterFor<TProcessManager>());

                ExecutionContext context = new ExecutionContext(causationEvent.Metadata, causationEvent.Event, c.RecipientId, CommandRequest.Create(c.RecipientId,c.Command),ex);
                var compensationCommand = await manager.HandleError(context);
                if (compensationCommand != null)
                {
                    var evt2 =  CommandEnqueued.Create(compensationCommand.RecipientId, compensationCommand.Command);
                    await plm.AppendEvents(streamId, StreamState.StreamExists, evt2);
                }
            }

        }

        public static IEnumerable<Type> Types => TProcessManager.CommandTypes;
    }

    
    public async Task Handle(Metadata m, object evt)
    {
        var plb = pmClient.Plumber;
        IProcessAction? action = null;
        string streamId = string.Empty;
        if (TProcessManager.StartEvent == evt.GetType())
        {
            Guid aggId = Guid.Parse(m.SourceStreamId.Substring(m.SourceStreamId.IndexOf('-')+1));
            var manager = await pmClient.GetManager<TProcessManager>(aggId);
            streamId = plb.Config.Conventions.GetStreamIdConvention(typeof(TProcessManager), manager.Id);
            action = await manager.StartWhen(m, evt);
        }
        else
        {
            var manager = await pmClient.GetManager<TProcessManager>(m.Id);
            streamId = plb.Config.Conventions.GetStreamIdConvention(typeof(TProcessManager), manager.Id);
            if (manager.Version < 0)
            {
                log.LogDebug("We've received event to process-manager that was not created.");
                return;
            }
            action = await manager.When(m, evt);
        }

        await plb.AppendLink(streamId,m);
        if (action is ICommandRequest cmd) 
            await plb.AppendEvents(streamId, StreamState.Any, CommandEnqueued.Create(cmd.RecipientId, cmd.Command));
        else if (action is IStateChangeAction s) 
            await plb.AppendEvents(streamId, StreamRevision.FromInt64(s.Version), s.Events);
    }
    
   
    public static IEnumerable<Type> Types => TProcessManager.Types;
}


// --- File: MicroPlumberd.Services.Uniqueness\IUniqueCategoryProvider.cs ---


namespace MicroPlumberd.Services.Uniqueness;

interface IUniqueCategoryProvider
{
    static abstract string Category { get;  }
}


// --- File: MicroPlumberd.Services.Uniqueness\IUniqueFrom.cs ---


namespace MicroPlumberd.Services.Uniqueness;

public interface IUniqueFrom<out TCategory, in TCommand>
{
    public static abstract TCategory From(TCommand cmd);
}


// --- File: MicroPlumberd.Services.Uniqueness\IUniqueNameReservation.cs ---


namespace MicroPlumberd.Services.Uniqueness;

interface IUniqueNameReservation<TProvider>
    where TProvider : IUniqueCategoryProvider
{
    Task Reserve(string name, Guid source, TimeSpan? duration = null);
    Task Confirm(Guid source);

    Task<bool> RollbackReservation(Guid reservationId);
    Task<bool> DeleteConfirmedNameReservation(Guid reservationId);
}


// --- File: MicroPlumberd.Services.Uniqueness\UniqueAttribute.cs ---


namespace MicroPlumberd.Services.Uniqueness;

[AttributeUsage(AttributeTargets.Property | AttributeTargets.Class)]
public class UniqueAttribute<TCategory> : Attribute, IUniqueCategoryProvider
{
       
    public static string Category => typeof(TCategory).Name;
}


// --- File: MicroPlumberd.Services.Uniqueness\UniqueNameReservation.cs ---


using System.Collections.Generic;
using System.Linq.Expressions;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MicroPlumberd.Services.Uniqueness
{
    class UniqueNameReservation
    {
        public long Id { get; init; }
        
        public string Name { get; init; }
        public Guid SourceId { get; init; }
        public DateTime ValidUntil { get; init; }
        public bool IsConfirmed { get; set; }
    }
}


// --- File: MicroPlumberd.Services.Uniqueness\UniqueNameReservationService.cs ---


using Microsoft.EntityFrameworkCore;

namespace MicroPlumberd.Services.Uniqueness;

class UniqueNameReservationService<TProvider> : IUniqueNameReservation<TProvider>
    where TProvider : IUniqueCategoryProvider
{
    public async Task Reserve(string name, Guid source, TimeSpan? duration)
    {
        if (name == null) throw new ArgumentNullException("name");
            
        duration ??= TimeSpan.FromMinutes(10);
        await using var db = new UniquenessDb<TProvider>();
        var toDelete =
            db.Reservations.Where(x => x.Name == name && x.ValidUntil < DateTime.Now && !x.IsConfirmed);
        db.Reservations.RemoveRange(toDelete);
        await db.SaveChangesAsync();

        // we might already have a confirmed reservation.
        var prvReservation =
            await db.Reservations
                .FirstOrDefaultAsync(x => x.SourceId == source && x.IsConfirmed);

        if (prvReservation != null && prvReservation.Name.Equals(name, StringComparison.OrdinalIgnoreCase))
            return;
        else
        {
            // this is brand new reservation or next reservation
            var reservation = new UniqueNameReservation()
            {
                Name = name,
                SourceId = source,
                ValidUntil = DateTime.Now.Add(duration.Value)
            };
            await db.Reservations.AddAsync(reservation);
        }

        await db.SaveChangesAsync();

    }

    public async Task Confirm(Guid source)
    {
        await using var db = new UniquenessDb<TProvider>();
        var reservation = await db.Reservations.SingleOrDefaultAsync(
            x => x.SourceId == source && !x.IsConfirmed);
        if (await db.Reservations.AnyAsync(x => x.SourceId == source && x.IsConfirmed))
            return;

        if (reservation.ValidUntil > DateTime.Now)
        {
            var prvReservation = await db.Reservations
                .FirstOrDefaultAsync(x => x.SourceId == source && x.IsConfirmed);
            if (prvReservation != null) db.Reservations.Remove(prvReservation);

            reservation.IsConfirmed = true;
            await db.SaveChangesAsync();
        }
        else
        {
            throw new Exception("Cannot confirm"); // arguably could mitigate f-ckup.
        }
    }



    public async Task<bool> RollbackReservation(Guid reservationId)
    {
        await using var db = new UniquenessDb<TProvider>();
        var toDelete = await db.Reservations
            .SingleOrDefaultAsync(x => x.SourceId == reservationId && !x.IsConfirmed );
        if (toDelete == null) return false;
        db.Reservations.Remove(toDelete);
        await db.SaveChangesAsync();
        return true;
    }
    public async Task<bool> DeleteConfirmedNameReservation(Guid reservationId)
    {
        await using var db = new UniquenessDb<TProvider>();
        var toDelete = await db.Reservations
            .SingleOrDefaultAsync(x => x.SourceId == reservationId && x.IsConfirmed );
        if (toDelete == null) return false;

        db.Reservations.Remove(toDelete);
        await db.SaveChangesAsync();
        return true;

    }
}


// --- File: MicroPlumberd.Services.Uniqueness\UniquenessDb.cs ---


using Microsoft.EntityFrameworkCore;

namespace MicroPlumberd.Services.Uniqueness;

class UniquenessDb<TProvider> : DbContext
    where TProvider:IUniqueCategoryProvider
{
    public DbSet<UniqueNameReservation> Reservations { get; set; }
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<UniqueNameReservation>().ToTable(TProvider.Category);
        modelBuilder.Entity<UniqueNameReservation>().HasIndex(x => new { x.Name }).IsUnique(true);
        modelBuilder.Entity<UniqueNameReservation>().HasIndex(x => new { x.SourceId }).IsUnique(false);
    }
}


// --- File: MicroPlumberd.SourceGenerators\AggregateSourceGenerator.cs ---


using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MicroPlumberd.SourceGenerators
{
    [Generator]
    public class AggregateSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this example
            //System.Diagnostics.Debugger.Launch();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxTrees = context.Compilation.SyntaxTrees;

            foreach (var syntaxTree in syntaxTrees)
            {
                var usingDirectives = syntaxTree.GetRoot().DescendantNodes()
                    .OfType<UsingDirectiveSyntax>()
                    .Select(u => u.ToString())
                    .Distinct()
                    .ToList();
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var classDeclarations = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classDeclarations)
                {
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
                    if (classSymbol == null) continue;


                    var baseType = classDecl.BaseList?.Types
                        .Select(bt => bt.Type)
                        .OfType<GenericNameSyntax>()
                        .FirstOrDefault(gn => gn.Identifier.ValueText.Contains("AggregateBase"));

                    if (baseType == null) continue;
                    var idType = baseType.TypeArgumentList.Arguments.FirstOrDefault();
                    var stateClassName = baseType.TypeArgumentList.Arguments.LastOrDefault();

                    if (stateClassName == null) continue;

                    if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "AggregateAttribute" || ad.AttributeClass.Name == "Aggregate"))
                    {
                        var namespaceDecl = classDecl.Parent as NamespaceDeclarationSyntax;
                        var fileScopedNamespace = classDecl.SyntaxTree.GetRoot().DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
                        var namespaceName = namespaceDecl?.Name.ToString() ?? fileScopedNamespace?.Name.ToString() ?? string.Empty;
                        var className = classDecl.Identifier.ValueText;
                        var methods = classDecl.Members.OfType<MethodDeclarationSyntax>()
                            .Where(m => m.Identifier.ValueText == "Given" &&
                                        m.ParameterList.Parameters.Count == 2 &&
                                        m.ParameterList.Parameters[1].Type.ToString() != "object" )
                            .ToList();

                        var sb = new StringBuilder();
                        var givenTypes = methods.Select(x => x.ParameterList.Parameters[1].Type).ToArray();
                        // Add using directives
                        foreach (var usingDirective in usingDirectives)
                        {
                            sb.AppendLine(usingDirective);
                        }
                        sb.AppendLine(); // Add a line break after using directives

                        if (!string.IsNullOrEmpty(namespaceName))
                        {
                            sb.AppendLine($"namespace {namespaceName};");
                        }

                        
                        sb.AppendLine($"partial class {className} : IAggregate<{className}>, ITypeRegister ");
                        sb.AppendLine("{");

                        //[AcceptedType(typeof(FooUpdated)), AcceptedType(typeof(FooCategory))]
                        var attrs = givenTypes.Select(x => $"AcceptedType(typeof({x.ToString()}))");
                        sb.AppendLine($"[{string.Join(", ",attrs) }]");
                        sb.AppendLine($"    protected override {stateClassName} Given({stateClassName} state, object ev)");
                        sb.AppendLine("    {");
                        sb.AppendLine("        switch(ev)");
                        sb.AppendLine("        {");

                        foreach (var eventType in givenTypes)
                        {
                            sb.AppendLine($"            case {eventType.ToString()} e: return Given(state, e);");
                        }

                        sb.AppendLine("            default: return state;");
                        
                        sb.AppendLine("        };");
                        sb.AppendLine("    }");

                        sb.AppendLine($"   public static {className} Empty(object id) => new {className}(({idType})id);");


                        var typeOfs = methods.Select(x => x.ParameterList.Parameters[1].Type)
                            .Select(x => $"typeof({x})");
                        var events = string.Join(",", typeOfs);
                        sb.AppendLine($"    static IEnumerable<Type> ITypeRegister.Types => [{events}];");

                        
                        sb.AppendLine("}");
                        context.AddSource($"{className}_Aggregate.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
                    }
                }
            }
        }
    }
}


// --- File: MicroPlumberd.SourceGenerators\CommandHandlerSourceGenerator.cs ---


using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MicroPlumberd.SourceGenerators
{
    [Generator]
    public class CommandHandlerSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this example
            //System.Diagnostics.Debugger.Launch();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxTrees = context.Compilation.SyntaxTrees;

            foreach (var syntaxTree in syntaxTrees)
            {
                var usingDirectives = syntaxTree.GetRoot().DescendantNodes()
                    .OfType<UsingDirectiveSyntax>()
                    .Select(u => u.ToString())
                    .Distinct()
                    .ToList();
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var classDeclarations = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classDeclarations)
                {
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
                    if (classSymbol == null) continue;
                    

                    if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "CommandHandlerAttribute" || ad.AttributeClass.Name == "CommandHandler"))
                    {
                        var namespaceDecl = classDecl.Parent as NamespaceDeclarationSyntax;
                        var fileScopedNamespace = classDecl.SyntaxTree.GetRoot().DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
                        var namespaceName = namespaceDecl?.Name.ToString() ?? fileScopedNamespace?.Name.ToString() ?? string.Empty;
                        var className = classDecl.Identifier.ValueText;
                        var methods = classDecl.Members.OfType<MethodDeclarationSyntax>()
                            .Where(m => m.Identifier.ValueText == "Handle" &&
                                        m.ParameterList.Parameters.Count == 2 &&
                                        m.Modifiers.Any(SyntaxKind.PublicKeyword))
                            .ToList();


                        var errorMsg = methods.SelectMany(method => method.AttributeLists.SelectMany(attrList => attrList.Attributes))
                            .Where(attribute => attribute.Name.ToString().Contains("ThrowsFaultException<") )
                            .SelectMany(attribute =>
                            {
                                var genericName = attribute.Name as GenericNameSyntax;
                                return genericName != null ?
                                    new[] { genericName.TypeArgumentList.Arguments.FirstOrDefault()?.ToString() } :
                                    new string[] { };
                            })
                            .Where(typeName => typeName != null)
                            .Distinct()
                            .ToArray();

                        var sb = new StringBuilder();

                        // Add using directives
                        foreach (var usingDirective in usingDirectives) sb.AppendLine(usingDirective);
                        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                        sb.AppendLine("using MicroPlumberd.Services;");
                        //sb.AppendLine("using MicroPlumberd.DirectConnect;");

                        sb.AppendLine(); // Add a line break after using directives

                        if (!string.IsNullOrEmpty(namespaceName)) sb.AppendLine($"namespace {namespaceName};");

                        
                        var commands =  methods.Select(x => x.ParameterList.Parameters[1].Type.ToString()).ToArray();
                        var handerArgs = methods.Select(x => new
                        {
                            CommandType=x.ParameterList.Parameters[1].Type.ToString(),
                            IdType = x.ParameterList.Parameters[0].Type.ToString(),
                        }).ToArray();
                        var returnTypes = methods.Select(x => GetGenericArgument(x.ReturnType.ToString()))
                            .Where(x=>x!= null && x != "Task")
                            .Distinct()
                            .ToArray();

                        var args = methods.Select(x =>
                            {
                                var idType = x.ParameterList.Parameters[0].Type.ToString();
                                var cmdType = x.ParameterList.Parameters[1].Type.ToString();
                                if (x.ReturnType is GenericNameSyntax gn)
                                {
                                    var resultType = gn.TypeArgumentList.Arguments.FirstOrDefault()?.ToString();
                                    return (cmdType: cmdType, resultType, idType);
                                }
                                else if (x.ReturnType.ToString() == "Task")
                                {
                                    return (cmdType: cmdType, null, idType);
                                }
                                else return (null,null, idType);

                            })
                            .Where(x => x.cmdType != null)
                            .Distinct()
                            .ToArray();

                        sb.AppendLine($"partial class {className} : IServiceTypeRegister, {string.Join(", ", handerArgs.Select(x=> $"ICommandHandler<{x.IdType},{x.CommandType}>"))} ");
                        sb.AppendLine("{");
                        foreach(var a in args) { 
                            if(a.resultType != null)
                                sb.AppendLine($"    async Task<object?> ICommandHandler<{a.idType},{a.cmdType}>.Execute({a.idType} id, {a.cmdType} cmd) => await this.Handle(id, cmd);");
                            else
                                sb.AppendLine($"    async Task<object?> ICommandHandler<{a.idType},{a.cmdType}>.Execute({a.idType} id, {a.cmdType} cmd) {{ await this.Handle(id, cmd); return null; }}");
                        }



                        sb.AppendLine("    public async Task<object?> Execute(string id, object command) => command switch");
                        sb.AppendLine("    {");
                        foreach (var command in commands)
                        {
                            sb.AppendLine($"        {command} c => await ((ICommandHandler<{command}>)this).Execute(id, c),");
                        }
                        sb.AppendLine($"        _ => null");
                        sb.AppendLine("    };");

                        sb.AppendLine("    static IServiceCollection IServiceTypeRegister.RegisterHandlers(IServiceCollection services)");
                        sb.AppendLine("    {");
                        foreach (var command in commands)
                        {
                            //.Decorate<ICommandHandler<CreateFoo>, CommandHandlerAttributeValidator<CreateFoo>>()
                            sb.AppendLine($"        services.AddScoped<ICommandHandler<{command}>, {className}>();");
                            sb.AppendLine($"        services.Decorate<ICommandHandler<{command}>, CommandHandlerAttributeValidator<{command}>>();");
                        }
                        sb.AppendLine("    return services;");
                        sb.AppendLine("    }");

                        if(commands.Any())
                            sb.AppendLine($"   private static readonly Type[] _commandTypes = new[] {{ {string.Join(",", commands.Select(x=>$"typeof({x})")) } }};");
                        else
                            sb.AppendLine($"   private static readonly Type[] _commandTypes = Array.Empty<Type>();");


                        if (returnTypes.Any())
                            sb.AppendLine($"   private static readonly Type[] _returnTypes = new[] {{ {string.Join(",", returnTypes.Select(x => $"typeof({x})"))} }};");
                        else
                            sb.AppendLine($"   private static readonly Type[] _returnTypes = Array.Empty<Type>();");
                        
                        if(errorMsg.Any())
                            sb.AppendLine($"   private static readonly Type[] _faultTypes = new[] {{ {string.Join(",", errorMsg.Select(x => $"typeof({x})"))} }};");
                        else
                            sb.AppendLine($"   private static readonly Type[] _faultTypes = Array.Empty<Type>();");

                        sb.AppendLine("    static IEnumerable<Type> IServiceTypeRegister.CommandTypes => _commandTypes;");
                        sb.AppendLine("    static IEnumerable<Type> IServiceTypeRegister.ReturnTypes => _returnTypes;");
                        sb.AppendLine("    static IEnumerable<Type> IServiceTypeRegister.FaultTypes => _faultTypes;");

                        sb.AppendLine("}");
                        context.AddSource($"{className}_CommandHandler.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
                    }
                }
            }
        }
        private string GetGenericArgument(string genericType)
        {
            try
            {
                var start = genericType.IndexOf('<') + 1;
                var length = genericType.IndexOf('>') - start;
                return start > 0 && length > 0 ? genericType.Substring(start, length) : genericType;
            }
            catch
            {
                return null;
            }
        }
    }
}


// --- File: MicroPlumberd.SourceGenerators\EventHandlerSourceGenerator.cs ---


using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MicroPlumberd.SourceGenerators
{
    [Generator]
    public class EventHandlerSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this example
            //System.Diagnostics.Debugger.Launch();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxTrees = context.Compilation.SyntaxTrees;

            foreach (var syntaxTree in syntaxTrees)
            {
                var usingDirectives = syntaxTree.GetRoot().DescendantNodes()
                    .OfType<UsingDirectiveSyntax>()
                    .Select(u => u.ToString())
                    .Distinct()
                    .ToList();
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var classDeclarations = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classDeclarations)
                {
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
                    if (classSymbol == null) continue;

                    if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "EventHandlerAttribute" || ad.AttributeClass.Name == "EventHandler"))
                    {
                        var namespaceDecl = classDecl.Parent as NamespaceDeclarationSyntax;
                        var fileScopedNamespace = classDecl.SyntaxTree.GetRoot().DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
                        var namespaceName = namespaceDecl?.Name.ToString() ?? fileScopedNamespace?.Name.ToString() ?? string.Empty;
                        var className = classDecl.Identifier.ValueText;
                        var methods = classDecl.Members.OfType<MethodDeclarationSyntax>()
                            .Where(m => m.Identifier.ValueText == "Given" &&
                                        m.ParameterList.Parameters.Count == 2 &&
                                        m.ParameterList.Parameters[0].Type.ToString() == "Metadata" &&
                                        m.Modifiers.Any(SyntaxKind.PrivateKeyword))
                            .ToList();

                        var sb = new StringBuilder();

                        // Add using directives
                        foreach (var usingDirective in usingDirectives)
                        {
                            sb.AppendLine(usingDirective);
                        }
                        sb.AppendLine(); // Add a line break after using directives

                        if (!string.IsNullOrEmpty(namespaceName))
                        {
                            sb.AppendLine($"namespace {namespaceName};");
                        }

                        sb.AppendLine($"partial class {className} : IEventHandler,ITypeRegister");
                        sb.AppendLine("{");
                        sb.AppendLine("    Task IEventHandler.Handle(Metadata m, object ev) => Given(m,ev);");
                        sb.AppendLine("    public async Task Given(Metadata m, object ev)");
                        sb.AppendLine("    {");
                        sb.AppendLine("        switch (ev)");
                        sb.AppendLine("        {");

                        foreach (var method in methods)
                        {
                            var eventType = method.ParameterList.Parameters[1].Type.ToString();
                            sb.AppendLine($"            case {eventType} e: await Given(m, e); break;");
                        }

                        sb.AppendLine("            default:");
                        sb.AppendLine("                throw new ArgumentException(\"Unknown event type\", ev.GetType().Name);");
                        sb.AppendLine("        }");
                        sb.AppendLine("    }");


                        var typeOfs = methods.Select(x => x.ParameterList.Parameters[1].Type)
                            .Select(x => $"typeof({x})");
                        var events = string.Join(",", typeOfs);
                        sb.AppendLine($"    static IEnumerable<Type> ITypeRegister.Types => [{events}];");

                        sb.AppendLine("}");
                        context.AddSource($"{className}_EventHandler.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
                    }
                }
            }
        }
    }
}


// --- File: MicroPlumberd.SourceGenerators\ProcessManagerSourceGenerator.cs ---


using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MicroPlumberd.SourceGenerators
{
    [Generator]
    public class ProcessManagerSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this example
            //System.Diagnostics.Debugger.Launch();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxTrees = context.Compilation.SyntaxTrees;

            foreach (var syntaxTree in syntaxTrees)
            {
                var usingDirectives = syntaxTree.GetRoot().DescendantNodes()
                    .OfType<UsingDirectiveSyntax>()
                    .Select(u => u.ToString())
                    .Distinct()
                    .ToList();
                var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
                var classDeclarations = syntaxTree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>();

                foreach (var classDecl in classDeclarations)
                {
                    var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
                    if (classSymbol == null) continue;
                    

                    if (classSymbol.GetAttributes().Any(ad => ad.AttributeClass.Name == "ProcessManagerAttribute" || ad.AttributeClass.Name == "ProcessManager"))
                    {
                        var namespaceDecl = classDecl.Parent as NamespaceDeclarationSyntax;
                        var fileScopedNamespace = classDecl.SyntaxTree.GetRoot().DescendantNodes().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
                        var namespaceName = namespaceDecl?.Name.ToString() ?? fileScopedNamespace?.Name.ToString() ?? string.Empty;
                        var className = classDecl.Identifier.ValueText;
                        var whenMethods = classDecl.Members.OfType<MethodDeclarationSyntax>()
                            .Where(m => m.Identifier.ValueText == "When" &&
                                        m.ParameterList.Parameters.Count == 2 &&
                                        m.ParameterList.Parameters[0].Type.ToString() == "Metadata" &&
                                        m.ParameterList.Parameters.Count == 2)
                            .ToList();

                        var givenMethods = classDecl.Members.OfType<MethodDeclarationSyntax>()
                            .Where(m => m.Identifier.ValueText == "Given" &&
                                        m.ParameterList.Parameters.Count == 2 &&
                                        m.ParameterList.Parameters[0].Type.ToString() == "Metadata" &&
                                        m.ParameterList.Parameters.Count == 2)
                            .ToList();

                        var startMethod = classDecl.Members
                            .OfType<MethodDeclarationSyntax>()
                            .FirstOrDefault(m => m.Identifier.ValueText == "StartWhen" &&
                                                 m.ParameterList.Parameters.Count == 2 &&
                                                 m.ParameterList.Parameters[0].Type.ToString() == "Metadata" &&
                                                 m.ParameterList.Parameters.Count == 2);

                        var sb = new StringBuilder();

                        // Add using directives
                        foreach (var usingDirective in usingDirectives) sb.AppendLine(usingDirective);
                        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
                        sb.AppendLine("using MicroPlumberd.Services;");
                        sb.AppendLine(); // Add a line break after using directives

                        if (!string.IsNullOrEmpty(namespaceName)) sb.AppendLine($"namespace {namespaceName};");

                        var ehMethods = startMethod != null ? 
                            whenMethods.Union(givenMethods).Union(new []{ startMethod}) : 
                            whenMethods.Union(givenMethods);

                        var events = ehMethods
                            .Select(x => x.ParameterList.Parameters[1].Type.GetFriendlyTypeName())
                            .Where(x=>x!= "object")
                            .Distinct()
                            .ToArray();

                        var returnTypes = ehMethods
                            .Select(x=>x.ReturnType)
                            .OfType<GenericNameSyntax>()
                            .Where(x=>x.Identifier.ValueText == "Task")
                            .Select(x => x.TypeArgumentList.Arguments[0])
                            .Distinct()
                            .ToArray();

                        var commandTypes = returnTypes
                            .OfType<GenericNameSyntax>()
                            .Where(x=>x.Identifier.ValueText == "ICommandRequest")
                            .Select(x => x.TypeArgumentList.Arguments[0].GetFriendlyTypeName())
                            .Distinct()
                            .ToArray();

                        sb.AppendLine($"partial class {className} : ProcessManagerBase<Guid>, IProcessManager, ITypeRegister");
                        sb.AppendLine("{");

                        sb.AppendLine("static IEnumerable<Type> IProcessManager.CommandTypes");
                        sb.AppendLine("{");
                        sb.AppendLine("    get");
                        sb.AppendLine("    {");
                        foreach (var i in commandTypes)
                        {
                            sb.AppendLine($"        yield return typeof(CommandEnqueued<{i}>);");
                        }
                        sb.AppendLine("    }");
                        sb.AppendLine("}");

                        if (startMethod != null)
                        {
                            var startEvt = startMethod.ParameterList.Parameters[1].Type.GetFriendlyTypeName();
                            sb.AppendLine($"static Type IProcessManager.StartEvent => typeof({startEvt});");
                            sb.AppendLine($"async Task<ICommandRequest> IProcessManager.StartWhen(Metadata m, object evt) => await StartWhen(m, ({startEvt})evt);");
                        }

                        sb.AppendLine($"    static IEnumerable<Type> ITypeRegister.Types => [{string.Join(",", events.Select(x=> $"typeof({x})"))}];");

                        sb.AppendLine("async Task IEventHandler.Handle(Metadata m, object evt)");
                        sb.AppendLine("{");
                        sb.AppendLine("    switch(evt)");
                        sb.AppendLine("    {");
                        foreach (var i in givenMethods.Select(x => x.ParameterList.Parameters[1].Type.GetFriendlyTypeName())) 
                            sb.AppendLine($"        case {i} e: await Given(m, e); return;");
                        sb.AppendLine($"        default: return;");
                        sb.AppendLine("    }");
                        sb.AppendLine("}");

                        sb.AppendLine("async Task<ICommandRequest?> IProcessManager.When(Metadata m, object evt)");
                        sb.AppendLine("{");
                        sb.AppendLine("    switch(evt)");
                        sb.AppendLine("    {");
                        foreach (var i in whenMethods.Select(x => x.ParameterList.Parameters[1].Type.GetFriendlyTypeName()))
                            sb.AppendLine($"        case {i} e: return await When(m, e);");
                        sb.AppendLine($"        default: return null;");
                        sb.AppendLine("    }");
                        sb.AppendLine("}");


                        sb.AppendLine("}");
                        context.AddSource($"{className}_ProcessManager.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
                    }
                }
            }
        }

        
        
    }
    public static class TypeSyntaxExtensions
    {
        public static string GetFriendlyTypeName(this TypeSyntax typeSyntax)
        {
            // Check if the type is a generic type
            if (typeSyntax is GenericNameSyntax genericName)
            {
                // Retrieve the generic type identifier (e.g., "Vector")
                string identifier = genericName.Identifier.ValueText;

                // Retrieve the type arguments (e.g., "<int>")
                string typeArguments = string.Join(", ", genericName.TypeArgumentList.Arguments.Select(arg => arg.ToString()));

                // Construct and return the friendly generic type name (e.g., "Vector<int>")
                return $"{identifier}<{typeArguments}>";
            }

            // If not a generic type, just return the type syntax's text
            return typeSyntax.ToString();
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Bytes\ByteRate.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Class to hold a ByteSize and a measurement interval, for the purpose of calculating the rate of transfer
/// </summary>
public class ByteRate
{
    /// <summary>
    /// Quantity of bytes
    /// </summary>
    public ByteSize Size { get; }

    /// <summary>
    /// Interval that bytes were transferred in
    /// </summary>
    public TimeSpan Interval { get; }

    /// <summary>
    /// Create a ByteRate with given quantity of bytes across an interval
    /// </summary>
    public ByteRate(ByteSize size, TimeSpan interval)
    {
        this.Size = size;
        this.Interval = interval;
    }

    /// <summary>
    /// Calculate rate for the quantity of bytes and interval defined by this instance
    /// </summary>
    /// <param name="timeUnit">Unit of time to calculate rate for (defaults is per second)</param>
    public string Humanize(TimeUnit timeUnit = TimeUnit.Second) =>
        Humanize(null, timeUnit);

    /// <summary>
    /// Calculate rate for the quantity of bytes and interval defined by this instance
    /// </summary>
    /// <param name="timeUnit">Unit of time to calculate rate for (defaults is per second)</param>
    /// <param name="format">The string format to use for the number of bytes</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public string Humanize(string? format, TimeUnit timeUnit = TimeUnit.Second, CultureInfo? culture = null)
    {
        var displayInterval = timeUnit switch
        {
            TimeUnit.Second => TimeSpan.FromSeconds(1),
            TimeUnit.Minute => TimeSpan.FromMinutes(1),
            TimeUnit.Hour => TimeSpan.FromHours(1),
            _ => throw new NotSupportedException("timeUnit must be Second, Minute, or Hour"),
        };
        return new ByteSize(Size.Bytes / Interval.TotalSeconds * displayInterval.TotalSeconds)
            .Humanize(format, culture) + '/' + timeUnit.ToSymbol(culture);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Bytes\ByteSize.cs ---


//The MIT License (MIT)

//Copyright (c) 2013-2014 Omar Khudeira (http://omar.io)

//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.

using System;
using System.Linq;
using static System.Globalization.NumberStyles;

namespace Humanizer;
#pragma warning disable 1591
public struct ByteSize(double byteSize) :
    IComparable<ByteSize>,
    IEquatable<ByteSize>,
    IComparable,
    IFormattable
{
    public static readonly ByteSize MinValue = FromBits(long.MinValue);
    public static readonly ByteSize MaxValue = FromBits(long.MaxValue);

    public const long BitsInByte = 8;
    public const long BytesInKilobyte = 1024;
    public const long BytesInMegabyte = 1048576;
    public const long BytesInGigabyte = 1073741824;
    public const long BytesInTerabyte = 1099511627776;

    public const string BitSymbol = "b";
    public const string Bit = "bit";
    public const string ByteSymbol = "B";
    public const string Byte = "byte";
    public const string KilobyteSymbol = "KB";
    public const string Kilobyte = "kilobyte";
    public const string MegabyteSymbol = "MB";
    public const string Megabyte = "megabyte";
    public const string GigabyteSymbol = "GB";
    public const string Gigabyte = "gigabyte";
    public const string TerabyteSymbol = "TB";
    public const string Terabyte = "terabyte";

    public long Bits { get; } = (long) Math.Ceiling(byteSize * BitsInByte);
    public double Bytes { get; } = byteSize;
    public double Kilobytes { get; } = byteSize / BytesInKilobyte;
    public double Megabytes { get; } = byteSize / BytesInMegabyte;
    public double Gigabytes { get; } = byteSize / BytesInGigabyte;
    public double Terabytes { get; } = byteSize / BytesInTerabyte;

    public string LargestWholeNumberSymbol => GetLargestWholeNumberSymbol();

    public string GetLargestWholeNumberSymbol(IFormatProvider? provider = null)
    {
        var cultureFormatter = Configurator.GetFormatter(provider as CultureInfo);

        // Absolute value is used to deal with negative values
        if (Math.Abs(Terabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Terabyte, Terabytes, toSymbol: true);
        }

        if (Math.Abs(Gigabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Gigabyte, Gigabytes, toSymbol: true);
        }

        if (Math.Abs(Megabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Megabyte, Megabytes, toSymbol: true);
        }

        if (Math.Abs(Kilobytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Kilobyte, Kilobytes, toSymbol: true);
        }

        if (Math.Abs(Bytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Byte, Bytes, toSymbol: true);
        }

        return cultureFormatter.DataUnitHumanize(DataUnit.Bit, Bits, toSymbol: true);
    }

    public string LargestWholeNumberFullWord => GetLargestWholeNumberFullWord();

    public string GetLargestWholeNumberFullWord(IFormatProvider? provider = null)
    {
        var cultureFormatter = Configurator.GetFormatter(provider as CultureInfo);

        // Absolute value is used to deal with negative values
        if (Math.Abs(Terabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Terabyte, Terabytes, toSymbol: false);
        }

        if (Math.Abs(Gigabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Gigabyte, Gigabytes, toSymbol: false);
        }

        if (Math.Abs(Megabytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Megabyte, Megabytes, toSymbol: false);
        }

        if (Math.Abs(Kilobytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Kilobyte, Kilobytes, toSymbol: false);
        }

        if (Math.Abs(Bytes) >= 1)
        {
            return cultureFormatter.DataUnitHumanize(DataUnit.Byte, Bytes, toSymbol: false);
        }

        return cultureFormatter.DataUnitHumanize(DataUnit.Bit, Bits, toSymbol: false);
    }

    public double LargestWholeNumberValue
    {
        get
        {
            // Absolute value is used to deal with negative values
            if (Math.Abs(Terabytes) >= 1)
            {
                return Terabytes;
            }

            if (Math.Abs(Gigabytes) >= 1)
            {
                return Gigabytes;
            }

            if (Math.Abs(Megabytes) >= 1)
            {
                return Megabytes;
            }

            if (Math.Abs(Kilobytes) >= 1)
            {
                return Kilobytes;
            }

            if (Math.Abs(Bytes) >= 1)
            {
                return Bytes;
            }

            return Bits;
        }
    }

    // Get ceiling because bis are whole units

    public static ByteSize FromBits(long value) =>
        new(value / (double) BitsInByte);

    public static ByteSize FromBytes(double value) =>
        new(value);

    public static ByteSize FromKilobytes(double value) =>
        new(value * BytesInKilobyte);

    public static ByteSize FromMegabytes(double value) =>
        new(value * BytesInMegabyte);

    public static ByteSize FromGigabytes(double value) =>
        new(value * BytesInGigabyte);

    public static ByteSize FromTerabytes(double value) =>
        new(value * BytesInTerabyte);

    /// <summary>
    /// Converts the value of the current ByteSize object to a string.
    /// The metric prefix symbol (bit, byte, kilo, mega, giga, tera) used is
    /// the largest metric prefix such that the corresponding value is greater
    ///  than or equal to one.
    /// </summary>
    public override string ToString() =>
        ToString(NumberFormatInfo.CurrentInfo);

    public string ToString(IFormatProvider? provider)
    {
        provider ??= CultureInfo.DefaultThreadCurrentCulture;

        return string.Format("{0:0.##} {1}", LargestWholeNumberValue, GetLargestWholeNumberSymbol(provider));
    }

    public string ToString(string? format) =>
        ToString(format, NumberFormatInfo.CurrentInfo);

    public string ToString(string? format, IFormatProvider? provider) =>
        ToString(format, provider, toSymbol: true);

    string ToString(string? format, IFormatProvider? provider, bool toSymbol)
    {
        format ??= "G";
        provider ??= CultureInfo.DefaultThreadCurrentCulture;

        if (format == "G")
            format = "0.##";

        if (!format.Contains("#") && !format.Contains("0"))
        {
            format = "0.## " + format;
        }

        format = format.Replace("#.##", "0.##");

        var culture = provider as CultureInfo ?? CultureInfo.DefaultThreadCurrentCulture;

        bool has(string s) => culture.CompareInfo.IndexOf(format, s, CompareOptions.IgnoreCase) != -1;
        string output(double n) => n.ToString(format, provider);

        var cultureFormatter = Configurator.GetFormatter(provider as CultureInfo);

        if (has(TerabyteSymbol))
        {
            format = format.Replace(TerabyteSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Terabyte, Terabytes, toSymbol));
            return output(Terabytes);
        }

        if (has(GigabyteSymbol))
        {
            format = format.Replace(GigabyteSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Gigabyte, Gigabytes, toSymbol));
            return output(Gigabytes);
        }

        if (has(MegabyteSymbol))
        {
            format = format.Replace(MegabyteSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Megabyte, Megabytes, toSymbol));
            return output(Megabytes);
        }

        if (has(KilobyteSymbol))
        {
            format = format.Replace(KilobyteSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Kilobyte, Kilobytes, toSymbol));
            return output(Kilobytes);
        }

        // Byte and Bit symbol look must be case-sensitive
        if (format.IndexOf(ByteSymbol, StringComparison.Ordinal) != -1)
        {
            format = format.Replace(ByteSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Byte, Bytes, toSymbol));
            return output(Bytes);
        }

        if (format.IndexOf(BitSymbol, StringComparison.Ordinal) != -1)
        {
            format = format.Replace(BitSymbol, cultureFormatter.DataUnitHumanize(DataUnit.Bit, Bits, toSymbol));
            return output(Bits);
        }

        var formattedLargeWholeNumberValue = LargestWholeNumberValue.ToString(format, provider);

        formattedLargeWholeNumberValue = formattedLargeWholeNumberValue.Equals(string.Empty)
            ? "0"
            : formattedLargeWholeNumberValue;

        return $"{formattedLargeWholeNumberValue} {(toSymbol ? GetLargestWholeNumberSymbol(provider) : GetLargestWholeNumberFullWord(provider))}";
    }

    /// <summary>
    /// Converts the value of the current ByteSize object to a string with
    /// full words. The metric prefix symbol (bit, byte, kilo, mega, giga,
    /// tera) used is the largest metric prefix such that the corresponding
    /// value is greater than or equal to one.
    /// </summary>
    public string ToFullWords(string? format = null, IFormatProvider? provider = null) =>
        ToString(format, provider, toSymbol: false);

    public override bool Equals(object? value)
    {
        if (value == null)
        {
            return false;
        }

        ByteSize other;
        if (value is ByteSize size)
        {
            other = size;
        }
        else
        {
            return false;
        }

        return Equals(other);
    }

    public bool Equals(ByteSize value) =>
        Bits == value.Bits;

    public override int GetHashCode() =>
        Bits.GetHashCode();

    public int CompareTo(object? obj)
    {
        if (obj == null)
        {
            return 1;
        }

        if (obj is ByteSize size)
        {
            return CompareTo(size);
        }

        throw new ArgumentException("Object is not a ByteSize");
    }

    public int CompareTo(ByteSize other) =>
        Bits.CompareTo(other.Bits);

    public ByteSize Add(ByteSize bs) =>
        new(Bytes + bs.Bytes);

    public ByteSize AddBits(long value) =>
        this + FromBits(value);

    public ByteSize AddBytes(double value) =>
        this + FromBytes(value);

    public ByteSize AddKilobytes(double value) =>
        this + FromKilobytes(value);

    public ByteSize AddMegabytes(double value) =>
        this + FromMegabytes(value);

    public ByteSize AddGigabytes(double value) =>
        this + FromGigabytes(value);

    public ByteSize AddTerabytes(double value) =>
        this + FromTerabytes(value);

    public ByteSize Subtract(ByteSize bs) =>
        new(Bytes - bs.Bytes);

    public static ByteSize operator +(ByteSize b1, ByteSize b2) =>
        new(b1.Bytes + b2.Bytes);

    public static ByteSize operator -(ByteSize b1, ByteSize b2) =>
        new(b1.Bytes - b2.Bytes);

    public static ByteSize operator ++(ByteSize b) =>
        new(b.Bytes + 1);

    public static ByteSize operator -(ByteSize b) =>
        new(-b.Bytes);

    public static ByteSize operator --(ByteSize b) =>
        new(b.Bytes - 1);

    public static bool operator ==(ByteSize b1, ByteSize b2) =>
        b1.Bits == b2.Bits;

    public static bool operator !=(ByteSize b1, ByteSize b2) =>
        b1.Bits != b2.Bits;

    public static bool operator <(ByteSize b1, ByteSize b2) =>
        b1.Bits < b2.Bits;

    public static bool operator <=(ByteSize b1, ByteSize b2) =>
        b1.Bits <= b2.Bits;

    public static bool operator >(ByteSize b1, ByteSize b2) =>
        b1.Bits > b2.Bits;

    public static bool operator >=(ByteSize b1, ByteSize b2) =>
        b1.Bits >= b2.Bits;

    public static bool TryParse(string? s, out ByteSize result) =>
        TryParse(s, null, out result);

    public static bool TryParse(string? s, IFormatProvider? formatProvider, out ByteSize result)
    {
        // Arg checking
        if (string.IsNullOrWhiteSpace(s))
        {
            result = default;
            return false;
        }

        // Acquiring culture-specific parsing info
        var numberFormat = GetNumberFormatInfo(formatProvider);

        const NumberStyles numberStyles = AllowDecimalPoint | AllowThousands | AllowLeadingSign;
        var numberSpecialChars = new[]
        {
            Convert.ToChar(numberFormat.NumberDecimalSeparator),
            Convert.ToChar(numberFormat.NumberGroupSeparator),
            Convert.ToChar(numberFormat.PositiveSign),
            Convert.ToChar(numberFormat.NegativeSign),
        };

        // Setup the result
        result = new();

        // Get the index of the first non-digit character
        // ReSharper disable once RedundantSuppressNullableWarningExpression
        s = s!.TrimStart(); // Protect against leading spaces

        int num;
        var found = false;

        // Pick first non-digit number
        for (num = 0; num < s.Length; num++)
        {
            if (!(char.IsDigit(s[num]) || numberSpecialChars.Contains(s[num])))
            {
                found = true;
                break;
            }
        }

        if (found == false)
        {
            return false;
        }

        var lastNumber = num;

        // Cut the input string in half
        var numberPart = s
            .Substring(0, lastNumber)
            .Trim();
        var sizePart = s
            .Substring(lastNumber, s.Length - lastNumber)
            .Trim();

        // Get the numeric part
        if (!double.TryParse(numberPart, numberStyles, formatProvider, out var number))
        {
            return false;
        }

        // Get the magnitude part
        switch (sizePart.ToUpper())
        {
            case ByteSymbol:
                if (sizePart == BitSymbol)
                {
                    // Bits
                    if (number % 1 != 0) // Can't have partial bits
                    {
                        return false;
                    }

                    result = FromBits((long) number);
                }
                else
                {
                    // Bytes
                    result = FromBytes(number);
                }

                break;

            case KilobyteSymbol:
                result = FromKilobytes(number);
                break;

            case MegabyteSymbol:
                result = FromMegabytes(number);
                break;

            case GigabyteSymbol:
                result = FromGigabytes(number);
                break;

            case TerabyteSymbol:
                result = FromTerabytes(number);
                break;

            default:
                return false;
        }

        return true;
    }

    static NumberFormatInfo GetNumberFormatInfo(IFormatProvider? formatProvider)
    {
        if (formatProvider is NumberFormatInfo numberFormat)
            return numberFormat;

        var culture = formatProvider as CultureInfo ?? CultureInfo.DefaultThreadCurrentCulture;

        return culture.NumberFormat;
    }

    public static ByteSize Parse(string s) =>
        Parse(s, null);

    public static ByteSize Parse(string s, IFormatProvider? formatProvider)
    {
        if (s == null)
        {
            throw new ArgumentNullException(nameof(s));
        }

        if (TryParse(s, formatProvider, out var result))
        {
            return result;
        }

        throw new FormatException("Value is not in the correct format");
    }
}
#pragma warning restore 1591



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Bytes\ByteSizeExtensions.cs ---


// ReSharper disable once CheckNamespace

using System;

namespace Humanizer;

/// <summary>
/// Provides extension methods for ByteSize
/// </summary>
public static class ByteSizeExtensions
{
    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this byte input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this sbyte input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this short input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this ushort input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this int input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this uint input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bits
    /// </summary>
    public static ByteSize Bits(this long input) =>
        ByteSize.FromBits(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this byte input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this sbyte input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this short input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this ushort input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this int input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this uint input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this double input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as bytes
    /// </summary>
    public static ByteSize Bytes(this long input) =>
        ByteSize.FromBytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this byte input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this sbyte input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this short input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this ushort input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this int input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this uint input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this double input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as kilobytes
    /// </summary>
    public static ByteSize Kilobytes(this long input) =>
        ByteSize.FromKilobytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this byte input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this sbyte input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this short input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this ushort input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this int input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this uint input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this double input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as megabytes
    /// </summary>
    public static ByteSize Megabytes(this long input) =>
        ByteSize.FromMegabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this byte input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this sbyte input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this short input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this ushort input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this int input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this uint input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this double input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as gigabytes
    /// </summary>
    public static ByteSize Gigabytes(this long input) =>
        ByteSize.FromGigabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this byte input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this sbyte input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this short input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this ushort input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this int input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this uint input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this double input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Considers input as terabytes
    /// </summary>
    public static ByteSize Terabytes(this long input) =>
        ByteSize.FromTerabytes(input);

    /// <summary>
    /// Turns a byte quantity into human readable form, eg 2 GB
    /// </summary>
    /// <param name="format">The string format to use</param>
    public static string Humanize(this ByteSize input, string? format = null) =>
        string.IsNullOrWhiteSpace(format) ? input.ToString() : input.ToString(format);

    /// <summary>
    /// Turns a byte quantity into human readable form, eg 2 GB
    /// </summary>
    /// <param name="formatProvider">The format provider to use</param>
    public static string Humanize(this ByteSize input, IFormatProvider formatProvider) =>
        input.ToString(formatProvider);

    /// <summary>
    /// Turns a byte quantity into human readable form, eg 2 GB
    /// </summary>
    /// <param name="format">The string format to use</param>
    /// <param name="formatProvider">The format provider to use</param>
    public static string Humanize(this ByteSize input, string? format, IFormatProvider? formatProvider) =>
        string.IsNullOrWhiteSpace(format) ? input.ToString(formatProvider) : input.ToString(format, formatProvider);

    /// <summary>
    /// Turns a quantity of bytes in a given interval into a rate that can be manipulated
    /// </summary>
    /// <param name="size">Quantity of bytes</param>
    /// <param name="interval">Interval to create rate for</param>
    public static ByteRate Per(this ByteSize size, TimeSpan interval) =>
        new(size, interval);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\CollectionFormatterRegistry.cs ---


namespace Humanizer;

class CollectionFormatterRegistry : LocaliserRegistry<ICollectionFormatter>
{
    public CollectionFormatterRegistry()
        : base(new DefaultCollectionFormatter("&"))
    {
        Register("en", new OxfordStyleCollectionFormatter());
        Register("it", new DefaultCollectionFormatter("e"));
        Register("de", new DefaultCollectionFormatter("und"));
        Register("dk", new DefaultCollectionFormatter("og"));
        Register("nl", new DefaultCollectionFormatter("en"));
        Register("pt", new DefaultCollectionFormatter("e"));
        Register("ro", new DefaultCollectionFormatter("i"));
        Register("nn", new DefaultCollectionFormatter("og"));
        Register("nb", new DefaultCollectionFormatter("og"));
        Register("sv", new DefaultCollectionFormatter("och"));
        Register("is", new DefaultCollectionFormatter("og"));
        Register("es", new DefaultCollectionFormatter("y"));
        Register("lb", new DefaultCollectionFormatter("an"));
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\Configurator.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Provides a configuration point for Humanizer
/// </summary>
public static class Configurator
{
    /// <summary>
    /// A registry of formatters used to format collections based on the current locale
    /// </summary>
    public static LocaliserRegistry<ICollectionFormatter> CollectionFormatters { get; } = new CollectionFormatterRegistry();

    /// <summary>
    /// A registry of formatters used to format strings based on the current locale
    /// </summary>
    public static LocaliserRegistry<IFormatter> Formatters { get; } = new FormatterRegistry();

    /// <summary>
    /// A registry of number to words converters used to localise ToWords and ToOrdinalWords methods
    /// </summary>
    public static LocaliserRegistry<INumberToWordsConverter> NumberToWordsConverters { get; } = new NumberToWordsConverterRegistry();

    /// <summary>
    /// A registry of ordinalizers used to localise Ordinalize method
    /// </summary>
    public static LocaliserRegistry<IOrdinalizer> Ordinalizers { get; } = new OrdinalizerRegistry();

    /// <summary>
    /// A registry of ordinalizers used to localise Ordinalize method
    /// </summary>
    public static LocaliserRegistry<IDateToOrdinalWordConverter> DateToOrdinalWordsConverters { get; } = new DateToOrdinalWordsConverterRegistry();

#if NET6_0_OR_GREATER
    /// <summary>
    /// A registry of ordinalizers used to localise Ordinalize method
    /// </summary>
    public static LocaliserRegistry<IDateOnlyToOrdinalWordConverter> DateOnlyToOrdinalWordsConverters { get; } = new DateOnlyToOrdinalWordsConverterRegistry();

    /// <summary>
    /// A registry of time to clock notation converters used to localise ToClockNotation methods
    /// </summary>
    public static LocaliserRegistry<ITimeOnlyToClockNotationConverter> TimeOnlyToClockNotationConverters { get; } = new TimeOnlyToClockNotationConvertersRegistry();
#endif

    internal static ICollectionFormatter CollectionFormatter => CollectionFormatters.ResolveForUiCulture();

    /// <summary>
    /// The formatter to be used
    /// </summary>
    /// <param name="culture">The culture to retrieve formatter for. Null means that current thread's UI culture should be used.</param>
    internal static IFormatter GetFormatter(CultureInfo? culture) =>
        Formatters.ResolveForCulture(culture);

    /// <summary>
    /// The converter to be used
    /// </summary>
    /// <param name="culture">The culture to retrieve number to words converter for. Null means that current thread's UI culture should be used.</param>
    internal static INumberToWordsConverter GetNumberToWordsConverter(CultureInfo? culture) =>
        NumberToWordsConverters.ResolveForCulture(culture);

    /// <summary>
    /// The ordinalizer to be used
    /// </summary>
    internal static IOrdinalizer Ordinalizer => Ordinalizers.ResolveForUiCulture();

    /// <summary>
    /// The ordinalizer to be used
    /// </summary>
    internal static IDateToOrdinalWordConverter DateToOrdinalWordsConverter => DateToOrdinalWordsConverters.ResolveForUiCulture();

#if NET6_0_OR_GREATER
    /// <summary>
    /// The ordinalizer to be used
    /// </summary>
    internal static IDateOnlyToOrdinalWordConverter DateOnlyToOrdinalWordsConverter => DateOnlyToOrdinalWordsConverters.ResolveForUiCulture();

    internal static ITimeOnlyToClockNotationConverter TimeOnlyToClockNotationConverter => TimeOnlyToClockNotationConverters.ResolveForUiCulture();
#endif

    /// <summary>
    /// The strategy to be used for DateTime.Humanize
    /// </summary>
    public static IDateTimeHumanizeStrategy DateTimeHumanizeStrategy { get; set; } = new DefaultDateTimeHumanizeStrategy();

    /// <summary>
    /// The strategy to be used for DateTimeOffset.Humanize
    /// </summary>
    public static IDateTimeOffsetHumanizeStrategy DateTimeOffsetHumanizeStrategy { get; set; } = new DefaultDateTimeOffsetHumanizeStrategy();

#if NET6_0_OR_GREATER
    /// <summary>
    /// The strategy to be used for DateOnly.Humanize
    /// </summary>
    public static IDateOnlyHumanizeStrategy DateOnlyHumanizeStrategy { get; set; } = new DefaultDateOnlyHumanizeStrategy();

    /// <summary>
    /// The strategy to be used for TimeOnly.Humanize
    /// </summary>
    public static ITimeOnlyHumanizeStrategy TimeOnlyHumanizeStrategy { get; set; } = new DefaultTimeOnlyHumanizeStrategy();
#endif

    static readonly Func<PropertyInfo, bool> DefaultEnumDescriptionPropertyLocator = p => p.Name == "Description";
    static Func<PropertyInfo, bool> enumDescriptionPropertyLocator = DefaultEnumDescriptionPropertyLocator;
    static bool enumDescriptionPropertyLocatorHasBeenUsed;

    internal static Func<PropertyInfo, bool> EnumDescriptionPropertyLocator
    {
        get
        {
            enumDescriptionPropertyLocatorHasBeenUsed = true;
            return enumDescriptionPropertyLocator;
        }
        private set => enumDescriptionPropertyLocator = value;
    }

    /// <summary>
    /// Use a predicate function for description property of attribute to use for Enum.Humanize
    /// </summary>
    public static void UseEnumDescriptionPropertyLocator(Func<PropertyInfo, bool> func)
    {
        if (enumDescriptionPropertyLocatorHasBeenUsed)
        {
            throw new("UseEnumDescriptionPropertyLocator must be called before any Enum.Humanize has already been. Move the call to UseEnumDescriptionPropertyLocator to the app startup or a ModuleInitializer.");
        }

        EnumDescriptionPropertyLocator = func;
    }

    internal static void ResetUseEnumDescriptionPropertyLocator()
    {
        enumDescriptionPropertyLocatorHasBeenUsed = false;
        EnumDescriptionPropertyLocator = DefaultEnumDescriptionPropertyLocator;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\DateOnlyToOrdinalWordsConverterRegistry.cs ---


#if NET6_0_OR_GREATER
namespace Humanizer;

class DateOnlyToOrdinalWordsConverterRegistry : LocaliserRegistry<IDateOnlyToOrdinalWordConverter>
{
    public DateOnlyToOrdinalWordsConverterRegistry() : base(new DefaultDateOnlyToOrdinalWordConverter())
    {
        Register("en-US", new UsDateOnlyToOrdinalWordsConverter());
        Register("fr", new FrDateOnlyToOrdinalWordsConverter());
        Register("es", new EsDateOnlyToOrdinalWordsConverter());
        Register("lt", new LtDateOnlyToOrdinalWordsConverter());
    }
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\DateToOrdinalWordsConverterRegistry.cs ---


namespace Humanizer;

class DateToOrdinalWordsConverterRegistry : LocaliserRegistry<IDateToOrdinalWordConverter>
{
    public DateToOrdinalWordsConverterRegistry()
        : base(new DefaultDateToOrdinalWordConverter())
    {
        Register("en-US", new UsDateToOrdinalWordsConverter());
        Register("fr", new FrDateToOrdinalWordsConverter());
        Register("es", new EsDateToOrdinalWordsConverter());
        Register("lt", new LtDateToOrdinalWordsConverter());
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\FormatterRegistry.cs ---


namespace Humanizer;

class FormatterRegistry : LocaliserRegistry<IFormatter>
{
    public FormatterRegistry()
        : base(c => new DefaultFormatter(c))
    {
        Register("ar", c => new ArabicFormatter(c));
        Register("de", c => new GermanFormatter(c));
        Register("he", c => new HebrewFormatter(c));
        Register("ro", c => new RomanianFormatter(c));
        Register("ru", c => new RussianFormatter(c));
        Register("sl", c => new SlovenianFormatter(c));
        Register("hr", c => new CroatianFormatter(c));
        Register("sr", c => new SerbianFormatter(c));
        Register("sr-Latn", c => new SerbianFormatter(c));
        Register("uk", c => new UkrainianFormatter(c));
        Register("fr", c => new FrenchFormatter(c));
        Register("fr-BE", c => new FrenchFormatter(c));
        RegisterCzechSlovakPolishFormatter("cs");
        RegisterCzechSlovakPolishFormatter("pl");
        RegisterCzechSlovakPolishFormatter("sk");
        Register("bg", c => new BulgarianFormatter(c));
        RegisterDefaultFormatter("ku");
        RegisterDefaultFormatter("pt");
        RegisterDefaultFormatter("sv");
        RegisterDefaultFormatter("tr");
        RegisterDefaultFormatter("vi");
        RegisterDefaultFormatter("en-US");
        RegisterDefaultFormatter("af");
        RegisterDefaultFormatter("az");
        RegisterDefaultFormatter("da");
        RegisterDefaultFormatter("el");
        RegisterDefaultFormatter("es");
        RegisterDefaultFormatter("fa");
        RegisterDefaultFormatter("fi-FI");
        RegisterDefaultFormatter("fil-PH");
        RegisterDefaultFormatter("hu");
        RegisterDefaultFormatter("hy");
        RegisterDefaultFormatter("id");
        Register("is", c => new IcelandicFormatter(c));
        RegisterDefaultFormatter("ja");
        RegisterDefaultFormatter("ko-KR");
        RegisterDefaultFormatter("lv");
        Register("mt", c => new MalteseFormatter(c));
        RegisterDefaultFormatter("ms-MY");
        RegisterDefaultFormatter("nb");
        RegisterDefaultFormatter("nb-NO");
        RegisterDefaultFormatter("nl");
        RegisterDefaultFormatter("bn-BD");
        RegisterDefaultFormatter("it");
        RegisterDefaultFormatter("ta");
        RegisterDefaultFormatter("uz-Latn-UZ");
        RegisterDefaultFormatter("uz-Cyrl-UZ");
        RegisterDefaultFormatter("zh-CN");
        RegisterDefaultFormatter("zh-Hans");
        RegisterDefaultFormatter("zh-Hant");
        RegisterDefaultFormatter("th-TH");
        RegisterDefaultFormatter("en-IN");
        Register("lt", c => new LithuanianFormatter(c));
        Register("lb", c => new LuxembourgishFormatter(c));
    }

    void RegisterDefaultFormatter(string localeCode) =>
        Register(localeCode, c => new DefaultFormatter(c));

    void RegisterCzechSlovakPolishFormatter(string localeCode) =>
        Register(localeCode, c => new CzechSlovakPolishFormatter(c));
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\LocaliserRegistry.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

/// <summary>
/// A registry of localised system components with their associated locales
/// </summary>
public class LocaliserRegistry<TLocaliser>
    where TLocaliser : class
{
    readonly Dictionary<string, Func<CultureInfo, TLocaliser>> _localisers = new();
    readonly Func<CultureInfo, TLocaliser> _defaultLocaliser;

    /// <summary>
    /// Creates a localiser registry with the default localiser set to the provided value
    /// </summary>
    public LocaliserRegistry(TLocaliser defaultLocaliser) =>
        _defaultLocaliser = _ => defaultLocaliser;

    /// <summary>
    /// Creates a localiser registry with the default localiser factory set to the provided value
    /// </summary>
    public LocaliserRegistry(Func<CultureInfo, TLocaliser> defaultLocaliser) =>
        _defaultLocaliser = defaultLocaliser;

    /// <summary>
    /// Gets the localiser for the current thread's UI culture
    /// </summary>
    public TLocaliser ResolveForUiCulture() =>
        ResolveForCulture(null);

    /// <summary>
    /// Gets the localiser for the specified culture
    /// </summary>
    /// <param name="culture">The culture to retrieve localiser for. If not specified, current thread's UI culture is used.</param>
    public TLocaliser ResolveForCulture(CultureInfo? culture)
    {
        var cultureInfo = culture ?? CultureInfo.DefaultThreadCurrentCulture;
        return FindLocaliser(cultureInfo)(cultureInfo);
    }

    /// <summary>
    /// Registers the localiser for the culture provided
    /// </summary>
    public void Register(string localeCode, TLocaliser localiser) =>
        _localisers[localeCode] = _ => localiser;

    /// <summary>
    /// Registers the localiser factory for the culture provided
    /// </summary>
    public void Register(string localeCode, Func<CultureInfo, TLocaliser> localiser) =>
        _localisers[localeCode] = localiser;

    Func<CultureInfo, TLocaliser> FindLocaliser(CultureInfo culture)
    {
        for (var c = culture; !string.IsNullOrEmpty(c.Name); c = c.Parent)
        {
            if (_localisers.TryGetValue(c.Name, out var localiser))
            {
                return localiser;
            }
        }

        return _defaultLocaliser;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\NumberToWordsConverterRegistry.cs ---


namespace Humanizer;

class NumberToWordsConverterRegistry : LocaliserRegistry<INumberToWordsConverter>
{
    public NumberToWordsConverterRegistry()
        : base(new EnglishNumberToWordsConverter())
    {
        Register("af", new AfrikaansNumberToWordsConverter());
        Register("en", new EnglishNumberToWordsConverter());
        Register("ar", new ArabicNumberToWordsConverter());
        Register("cs", c => new CzechNumberToWordsConverter(c));
        Register("fa", new FarsiNumberToWordsConverter());
        Register("es", new SpanishNumberToWordsConverter());
        Register("pl", c => new PolishNumberToWordsConverter(c));
        Register("pt", new PortugueseNumberToWordsConverter());
        Register("pt-BR", new BrazilianPortugueseNumberToWordsConverter());
        Register("ro", new RomanianNumberToWordsConverter());
        Register("ru", new RussianNumberToWordsConverter());
        Register("fi", new FinnishNumberToWordsConverter());
        Register("fr-BE", new FrenchBelgianNumberToWordsConverter());
        Register("fr-CH", new FrenchSwissNumberToWordsConverter());
        Register("fr", new FrenchNumberToWordsConverter());
        Register("nl", new DutchNumberToWordsConverter());
        Register("he", c => new HebrewNumberToWordsConverter(c));
        Register("sl", c => new SlovenianNumberToWordsConverter(c));
        Register("de", new GermanNumberToWordsConverter());
        Register("de-CH", new GermanSwissLiechtensteinNumberToWordsConverter());
        Register("de-LI", new GermanSwissLiechtensteinNumberToWordsConverter());
        Register("bn-BD", new BanglaNumberToWordsConverter());
        Register("tr", new TurkishNumberToWordConverter());
        Register("is", new IcelandicNumberToWordsConverter());
        Register("it", new ItalianNumberToWordsConverter());
        Register("mt", new MalteseNumberToWordsConvertor());
        Register("uk", new UkrainianNumberToWordsConverter());
        Register("uz-Latn-UZ", new UzbekLatnNumberToWordConverter());
        Register("uz-Cyrl-UZ", new UzbekCyrlNumberToWordConverter());
        Register("sv", new SwedishNumberToWordsConverter());
        Register("sr", c => new SerbianCyrlNumberToWordsConverter(c));
        Register("sr-Latn", c => new SerbianNumberToWordsConverter(c));
        Register("ta", new TamilNumberToWordsConverter());
        Register("hr", c => new CroatianNumberToWordsConverter(c));
        Register("nb", new NorwegianBokmalNumberToWordsConverter());
        Register("vi", new VietnameseNumberToWordsConverter());
        Register("zh-CN", new ChineseNumberToWordsConverter());
        Register("bg", new BulgarianNumberToWordsConverter());
        Register("hy", new ArmenianNumberToWordsConverter());
        Register("az", new AzerbaijaniNumberToWordsConverter());
        Register("ja", new JapaneseNumberToWordsConverter());
        Register("ku", new CentralKurdishNumberToWordsConverter());
        Register("el", new GreekNumberToWordsConverter());
        Register("th-TH", new ThaiNumberToWordsConverter());
        Register("lv", new LatvianNumberToWordsConverter());
        Register("ko-KR", new KoreanNumberToWordsConverter());
        Register("en-IN", new IndianNumberToWordsConverter());
        Register("lt", new LithuanianNumberToWordsConverter());
        Register("lb", new LuxembourgishNumberToWordsConverter());
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\OrdinalizerRegistry.cs ---


namespace Humanizer;

class OrdinalizerRegistry : LocaliserRegistry<IOrdinalizer>
{
    public OrdinalizerRegistry()
        : base(new DefaultOrdinalizer())
    {
        Register("de", new GermanOrdinalizer());
        Register("en", new EnglishOrdinalizer());
        Register("es", c => new SpanishOrdinalizer(c));
        Register("fr", new FrenchOrdinalizer());
        Register("is", new IcelandicOrdinalizer());
        Register("it", new ItalianOrdinalizer());
        Register("nl", new DutchOrdinalizer());
        Register("pt", new PortugueseOrdinalizer());
        Register("ro", new RomanianOrdinalizer());
        Register("ru", new RussianOrdinalizer());
        Register("tr", new TurkishOrdinalizer());
        Register("uk", new UkrainianOrdinalizer());
        Register("hy", new ArmenianOrdinalizer());
        Register("az", new AzerbaijaniOrdinalizer());
        Register("lb", new LuxembourgishOrdinalizer());
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Configuration\TimeOnlyToClockNotationConvertersRegistry.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class TimeOnlyToClockNotationConvertersRegistry : LocaliserRegistry<ITimeOnlyToClockNotationConverter>
{
    public TimeOnlyToClockNotationConvertersRegistry() : base(new DefaultTimeOnlyToClockNotationConverter())
    {
        Register("pt-BR", new BrazilianPortugueseTimeOnlyToClockNotationConverter());
        Register("fr", new FrTimeOnlyToClockNotationConverter());
        Register("es", new EsTimeOnlyToClockNotationConverter());
        Register("lb", new LbTimeOnlyToClockNotationConverter());
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\DateTimeHumanizeAlgorithms.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Algorithms used to convert distance between two dates into words.
/// </summary>
static class DateTimeHumanizeAlgorithms
{
    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public static string PrecisionHumanize(DateTime input, DateTime comparisonBase, double precision, CultureInfo? culture)
    {
        var ts = new TimeSpan(Math.Abs(comparisonBase.Ticks - input.Ticks));
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;

        return PrecisionHumanize(ts, tense, precision, culture);
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public static string PrecisionHumanize(DateOnly input, DateOnly comparisonBase, double precision, CultureInfo? culture)
    {
        var diffDays = Math.Abs(comparisonBase.DayOfYear - input.DayOfYear);
        var ts = new TimeSpan(diffDays, 0, 0, 0);
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;

        return PrecisionHumanize(ts, tense, precision, culture);
    }

    /// <summary>
    /// Returns localized &amp; humanized distance of time between two times; given a specific precision.
    /// </summary>
    public static string PrecisionHumanize(TimeOnly input, TimeOnly comparisonBase, double precision, CultureInfo? culture)
    {
        var ts = new TimeSpan(Math.Abs(comparisonBase.Ticks - input.Ticks));
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;

        return PrecisionHumanize(ts, tense, precision, culture);
    }
#endif
    static string PrecisionHumanize(TimeSpan ts, Tense tense, double precision, CultureInfo? culture)
    {
        int seconds = ts.Seconds, minutes = ts.Minutes, hours = ts.Hours, days = ts.Days;
        int years = 0, months = 0;

        // start approximate from smaller units towards bigger ones
        if (ts.Milliseconds >= 999 * precision)
        {
            seconds += 1;
        }

        if (seconds >= 59 * precision)
        {
            minutes += 1;
        }

        if (minutes >= 59 * precision)
        {
            hours += 1;
        }

        if (hours >= 23 * precision)
        {
            days += 1;
        }

        // month calculation
        if (days >= 30 * precision & days <= 31)
        {
            months = 1;
        }

        if (days > 31 && days < 365 * precision)
        {
            var factor = Convert.ToInt32(Math.Floor((double)days / 30));
            var maxMonths = Convert.ToInt32(Math.Ceiling((double)days / 30));
            months = days >= 30 * (factor + precision) ? maxMonths : maxMonths - 1;
        }

        // year calculation
        if (days >= 365 * precision && days <= 366)
        {
            years = 1;
        }

        if (days > 365)
        {
            var factor = Convert.ToInt32(Math.Floor((double)days / 365));
            var maxMonths = Convert.ToInt32(Math.Ceiling((double)days / 365));
            years = days >= 365 * (factor + precision) ? maxMonths : maxMonths - 1;
        }

        // start computing result from larger units to smaller ones
        var formatter = Configurator.GetFormatter(culture);
        if (years > 0)
        {
            return formatter.DateHumanize(TimeUnit.Year, tense, years);
        }

        if (months > 0)
        {
            return formatter.DateHumanize(TimeUnit.Month, tense, months);
        }

        if (days > 0)
        {
            return formatter.DateHumanize(TimeUnit.Day, tense, days);
        }

        if (hours > 0)
        {
            return formatter.DateHumanize(TimeUnit.Hour, tense, hours);
        }

        if (minutes > 0)
        {
            return formatter.DateHumanize(TimeUnit.Minute, tense, minutes);
        }

        if (seconds > 0)
        {
            return formatter.DateHumanize(TimeUnit.Second, tense, seconds);
        }

        return formatter.DateHumanize(TimeUnit.Millisecond, tense, 0);
    }

    // http://stackoverflow.com/questions/11/how-do-i-calculate-relative-time
    /// <summary>
    /// Calculates the distance of time in words between two provided dates
    /// </summary>
    public static string DefaultHumanize(DateTime input, DateTime comparisonBase, CultureInfo? culture)
    {
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;
        var ts = new TimeSpan(Math.Abs(comparisonBase.Ticks - input.Ticks));

        var sameMonth = comparisonBase.Date.AddMonths(tense == Tense.Future ? 1 : -1) == input.Date;

        var days = Math.Abs((input.Date - comparisonBase.Date).Days);

        return DefaultHumanize(ts, sameMonth, days, tense, culture);
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Calculates the distance of time in words between two provided dates
    /// </summary>
    public static string DefaultHumanize(DateOnly input, DateOnly comparisonBase, CultureInfo? culture)
    {
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;
        var diffDays = Math.Abs(comparisonBase.DayNumber - input.DayNumber);
        var ts = new TimeSpan(diffDays, 0, 0, 0);

        var sameMonth = comparisonBase.AddMonths(tense == Tense.Future ? 1 : -1) == input;

        var days = Math.Abs(input.DayNumber - comparisonBase.DayNumber);

        return DefaultHumanize(ts, sameMonth, days, tense, culture);
    }

    /// <summary>
    /// Calculates the distance of time in words between two provided times
    /// </summary>
    public static string DefaultHumanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo? culture)
    {
        var tense = input > comparisonBase ? Tense.Future : Tense.Past;
        var ts = new TimeSpan(Math.Abs(comparisonBase.Ticks - input.Ticks));

        return DefaultHumanize(ts, true, 0, tense, culture);
    }
#endif

    static string DefaultHumanize(TimeSpan ts, bool sameMonth, int days, Tense tense, CultureInfo? culture)
    {
        var formatter = Configurator.GetFormatter(culture);

        if (ts.TotalMilliseconds < 500)
        {
            return formatter.DateHumanize(TimeUnit.Millisecond, tense, 0);
        }

        if (ts.TotalSeconds < 60)
        {
            return formatter.DateHumanize(TimeUnit.Second, tense, ts.Seconds);
        }

        if (ts.TotalSeconds < 120)
        {
            return formatter.DateHumanize(TimeUnit.Minute, tense, 1);
        }

        if (ts.TotalMinutes < 60)
        {
            return formatter.DateHumanize(TimeUnit.Minute, tense, ts.Minutes);
        }

        if (ts.TotalMinutes < 90)
        {
            return formatter.DateHumanize(TimeUnit.Hour, tense, 1);
        }

        if (ts.TotalHours < 24)
        {
            return formatter.DateHumanize(TimeUnit.Hour, tense, ts.Hours);
        }

        if (ts.TotalHours < 48)
        {
            return formatter.DateHumanize(TimeUnit.Day, tense, days);
        }

        if (ts.TotalDays < 28)
        {
            return formatter.DateHumanize(TimeUnit.Day, tense, ts.Days);
        }

        if (ts.TotalDays is >= 28 and < 30)
        {
            if (sameMonth)
            {
                return formatter.DateHumanize(TimeUnit.Month, tense, 1);
            }

            return formatter.DateHumanize(TimeUnit.Day, tense, ts.Days);
        }

        if (ts.TotalDays < 345)
        {
            var months = Convert.ToInt32(Math.Floor(ts.TotalDays / 29.5));
            return formatter.DateHumanize(TimeUnit.Month, tense, months);
        }

        var years = Convert.ToInt32(Math.Floor(ts.TotalDays / 365));
        if (years == 0)
        {
            years = 1;
        }

        return formatter.DateHumanize(TimeUnit.Year, tense, years);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\DefaultDateOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// The default 'distance of time' -> words calculator.
/// </summary>
public class DefaultDateOnlyHumanizeStrategy : IDateOnlyHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates
    /// </summary>
    public string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.DefaultHumanize(input, comparisonBase, culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\DefaultDateTimeHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// The default 'distance of time' -> words calculator.
/// </summary>
public class DefaultDateTimeHumanizeStrategy : IDateTimeHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates
    /// </summary>
    public string Humanize(DateTime input, DateTime comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.DefaultHumanize(input, comparisonBase, culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\DefaultDateTimeOffsetHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// The default 'distance of time' -> words calculator.
/// </summary>
public class DefaultDateTimeOffsetHumanizeStrategy : IDateTimeOffsetHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates
    /// </summary>
    public string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.DefaultHumanize(input.UtcDateTime, comparisonBase.UtcDateTime, culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\DefaultTimeOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// The default 'distance of time' -> words calculator.
/// </summary>
public class DefaultTimeOnlyHumanizeStrategy : ITimeOnlyHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided times
    /// </summary>
    public string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.DefaultHumanize(input, comparisonBase, culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\IDateOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// Implement this interface to create a new strategy for DateOnly.Humanize and hook it in the Configurator.DateOnlyHumanizeStrategy
/// </summary>
public interface IDateOnlyHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates used for DateOnly.Humanize
    /// </summary>
    string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo? culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\IDateTimeHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Implement this interface to create a new strategy for DateTime.Humanize and hook it in the Configurator.DateTimeHumanizeStrategy
/// </summary>
public interface IDateTimeHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates used for DateTime.Humanize
    /// </summary>
    string Humanize(DateTime input, DateTime comparisonBase, CultureInfo? culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\IDateTimeOffsetHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Implement this interface to create a new strategy for DateTime.Humanize and hook it in the Configurator.DateTimeOffsetHumanizeStrategy
/// </summary>
public interface IDateTimeOffsetHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates used for DateTimeOffset.Humanize
    /// </summary>
    string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo? culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\ITimeOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// Implement this interface to create a new strategy for TimeOnly.Humanize and hook it in the Configurator.TimeOnlyHumanizeStrategy
/// </summary>
public interface ITimeOnlyHumanizeStrategy
{
    /// <summary>
    /// Calculates the distance of time in words between two provided dates used for TimeOnly.Humanize
    /// </summary>
    string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo? culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\PrecisionDateOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// Precision-based calculator for distance between two times
/// </summary>
public class PrecisionDateOnlyHumanizeStrategy : IDateOnlyHumanizeStrategy
{
    readonly double _precision;

    /// <summary>
    /// Constructs a precision-based calculator for distance of time with default precision 0.75.
    /// </summary>
    /// <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
    public PrecisionDateOnlyHumanizeStrategy(double precision = .75) =>
        _precision = precision;

    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.PrecisionHumanize(input, comparisonBase, _precision, culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\PrecisionDateTimeHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Precision-based calculator for distance between two times
/// </summary>
public class PrecisionDateTimeHumanizeStrategy : IDateTimeHumanizeStrategy
{
    readonly double _precision;

    /// <summary>
    /// Constructs a precision-based calculator for distance of time with default precision 0.75.
    /// </summary>
    /// <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
    public PrecisionDateTimeHumanizeStrategy(double precision = .75) =>
        _precision = precision;

    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public string Humanize(DateTime input, DateTime comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.PrecisionHumanize(input, comparisonBase, _precision, culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\PrecisionDateTimeOffsetHumanizeStrategy.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Precision-based calculator for distance between two times
/// </summary>
public class PrecisionDateTimeOffsetHumanizeStrategy : IDateTimeOffsetHumanizeStrategy
{
    readonly double _precision;

    /// <summary>
    /// Constructs a precision-based calculator for distance of time with default precision 0.75.
    /// </summary>
    /// <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
    public PrecisionDateTimeOffsetHumanizeStrategy(double precision = .75) =>
        _precision = precision;

    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.PrecisionHumanize(input.UtcDateTime, comparisonBase.UtcDateTime, _precision, culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateTimeHumanizeStrategy\PrecisionTimeOnlyHumanizeStrategy.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// Precision-based calculator for distance between two times
/// </summary>
public class PrecisionTimeOnlyHumanizeStrategy : ITimeOnlyHumanizeStrategy
{
    readonly double _precision;

    /// <summary>
    /// Constructs a precision-based calculator for distance of time with default precision 0.75.
    /// </summary>
    /// <param name="precision">precision of approximation, if not provided  0.75 will be used as a default precision.</param>
    public PrecisionTimeOnlyHumanizeStrategy(double precision = .75) =>
        _precision = precision;

    /// <summary>
    /// Returns localized &amp; humanized distance of time between two dates; given a specific precision.
    /// </summary>
    public string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo? culture) =>
        DateTimeHumanizeAlgorithms.PrecisionHumanize(input, comparisonBase, _precision, culture);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\In.cs ---


using System;

namespace Humanizer;

public partial class In
{
    /// <summary>
    /// Returns the first of January of the provided year
    /// </summary>
    public static DateTime TheYear(int year) =>
        new(year, 1, 1);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\In.Months.cs ---


using System;

namespace Humanizer;

public partial class In
{
    /// <summary>
    /// Returns 1st of January of the current year
    /// </summary>
    public static DateTime January
        => new(DateTime.UtcNow.Year, 1, 1);

    /// <summary>
    /// Returns 1st of January of the year passed in
    /// </summary>
    public static DateTime JanuaryOf(int year)
        => new(year, 1, 1);

    /// <summary>
    /// Returns 1st of February of the current year
    /// </summary>
    public static DateTime February
        => new(DateTime.UtcNow.Year, 2, 1);

    /// <summary>
    /// Returns 1st of February of the year passed in
    /// </summary>
    public static DateTime FebruaryOf(int year)
        => new(year, 2, 1);

    /// <summary>
    /// Returns 1st of March of the current year
    /// </summary>
    public static DateTime March
        => new(DateTime.UtcNow.Year, 3, 1);

    /// <summary>
    /// Returns 1st of March of the year passed in
    /// </summary>
    public static DateTime MarchOf(int year)
        => new(year, 3, 1);

    /// <summary>
    /// Returns 1st of April of the current year
    /// </summary>
    public static DateTime April
        => new(DateTime.UtcNow.Year, 4, 1);

    /// <summary>
    /// Returns 1st of April of the year passed in
    /// </summary>
    public static DateTime AprilOf(int year)
        => new(year, 4, 1);

    /// <summary>
    /// Returns 1st of May of the current year
    /// </summary>
    public static DateTime May
        => new(DateTime.UtcNow.Year, 5, 1);

    /// <summary>
    /// Returns 1st of May of the year passed in
    /// </summary>
    public static DateTime MayOf(int year)
        => new(year, 5, 1);

    /// <summary>
    /// Returns 1st of June of the current year
    /// </summary>
    public static DateTime June
        => new(DateTime.UtcNow.Year, 6, 1);

    /// <summary>
    /// Returns 1st of June of the year passed in
    /// </summary>
    public static DateTime JuneOf(int year)
        => new(year, 6, 1);

    /// <summary>
    /// Returns 1st of July of the current year
    /// </summary>
    public static DateTime July
        => new(DateTime.UtcNow.Year, 7, 1);

    /// <summary>
    /// Returns 1st of July of the year passed in
    /// </summary>
    public static DateTime JulyOf(int year)
        => new(year, 7, 1);

    /// <summary>
    /// Returns 1st of August of the current year
    /// </summary>
    public static DateTime August
        => new(DateTime.UtcNow.Year, 8, 1);

    /// <summary>
    /// Returns 1st of August of the year passed in
    /// </summary>
    public static DateTime AugustOf(int year)
        => new(year, 8, 1);

    /// <summary>
    /// Returns 1st of September of the current year
    /// </summary>
    public static DateTime September
        => new(DateTime.UtcNow.Year, 9, 1);

    /// <summary>
    /// Returns 1st of September of the year passed in
    /// </summary>
    public static DateTime SeptemberOf(int year)
        => new(year, 9, 1);

    /// <summary>
    /// Returns 1st of October of the current year
    /// </summary>
    public static DateTime October
        => new(DateTime.UtcNow.Year, 10, 1);

    /// <summary>
    /// Returns 1st of October of the year passed in
    /// </summary>
    public static DateTime OctoberOf(int year)
        => new(year, 10, 1);

    /// <summary>
    /// Returns 1st of November of the current year
    /// </summary>
    public static DateTime November
        => new(DateTime.UtcNow.Year, 11, 1);

    /// <summary>
    /// Returns 1st of November of the year passed in
    /// </summary>
    public static DateTime NovemberOf(int year)
        => new(year, 11, 1);

    /// <summary>
    /// Returns 1st of December of the current year
    /// </summary>
    public static DateTime December
        => new(DateTime.UtcNow.Year, 12, 1);

    /// <summary>
    /// Returns 1st of December of the year passed in
    /// </summary>
    public static DateTime DecemberOf(int year)
        => new(year, 12, 1);

}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\In.SomeTimeFrom.cs ---


using System;

namespace Humanizer;

/// <summary>
/// </summary>
public partial class In
{
    /// <summary>
    /// </summary>
    public static class One
    {
        /// <summary>
        /// 1 seconds from now
        /// </summary>
        public static DateTime Second
            => DateTime.UtcNow.AddSeconds(1);

        /// <summary>
        /// 1 seconds from the provided date
        /// </summary>
        public static DateTime SecondFrom(DateTime date)
            => date.AddSeconds(1);

        /// <summary>
        /// 1 minutes from now
        /// </summary>
        public static DateTime Minute
            => DateTime.UtcNow.AddMinutes(1);

        /// <summary>
        /// 1 minutes from the provided date
        /// </summary>
        public static DateTime MinuteFrom(DateTime date)
            => date.AddMinutes(1);

        /// <summary>
        /// 1 hours from now
        /// </summary>
        public static DateTime Hour
            => DateTime.UtcNow.AddHours(1);

        /// <summary>
        /// 1 hours from the provided date
        /// </summary>
        public static DateTime HourFrom(DateTime date)
            => date.AddHours(1);

        /// <summary>
        /// 1 days from now
        /// </summary>
        public static DateTime Day
            => DateTime.UtcNow.AddDays(1);

        /// <summary>
        /// 1 days from the provided date
        /// </summary>
        public static DateTime DayFrom(DateTime date)
            => date.AddDays(1);

        /// <summary>
        /// 1 weeks from now
        /// </summary>
        public static DateTime Week
            => DateTime.UtcNow.AddDays(7);

        /// <summary>
        /// 1 weeks from the provided date
        /// </summary>
        public static DateTime WeekFrom(DateTime date)
            => date.AddDays(7);

        /// <summary>
        /// 1 months from now
        /// </summary>
        public static DateTime Month
            => DateTime.UtcNow.AddMonths(1);

        /// <summary>
        /// 1 months from the provided date
        /// </summary>
        public static DateTime MonthFrom(DateTime date)
            => date.AddMonths(1);

        /// <summary>
        /// 1 years from now
        /// </summary>
        public static DateTime Year
            => DateTime.UtcNow.AddYears(1);

        /// <summary>
        /// 1 years from the provided date
        /// </summary>
        public static DateTime YearFrom(DateTime date)
            => date.AddYears(1);
    }

    /// <summary>
    /// </summary>
    public static class Two
    {
        /// <summary>
        /// 2 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(2);

        /// <summary>
        /// 2 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(2);

        /// <summary>
        /// 2 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(2);

        /// <summary>
        /// 2 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(2);

        /// <summary>
        /// 2 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(2);

        /// <summary>
        /// 2 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(2);

        /// <summary>
        /// 2 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(2);

        /// <summary>
        /// 2 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(2);

        /// <summary>
        /// 2 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(14);

        /// <summary>
        /// 2 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(14);

        /// <summary>
        /// 2 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(2);

        /// <summary>
        /// 2 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(2);

        /// <summary>
        /// 2 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(2);

        /// <summary>
        /// 2 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(2);
    }

    /// <summary>
    /// </summary>
    public static class Three
    {
        /// <summary>
        /// 3 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(3);

        /// <summary>
        /// 3 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(3);

        /// <summary>
        /// 3 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(3);

        /// <summary>
        /// 3 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(3);

        /// <summary>
        /// 3 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(3);

        /// <summary>
        /// 3 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(3);

        /// <summary>
        /// 3 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(3);

        /// <summary>
        /// 3 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(3);

        /// <summary>
        /// 3 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(21);

        /// <summary>
        /// 3 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(21);

        /// <summary>
        /// 3 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(3);

        /// <summary>
        /// 3 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(3);

        /// <summary>
        /// 3 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(3);

        /// <summary>
        /// 3 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(3);
    }

    /// <summary>
    /// </summary>
    public static class Four
    {
        /// <summary>
        /// 4 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(4);

        /// <summary>
        /// 4 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(4);

        /// <summary>
        /// 4 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(4);

        /// <summary>
        /// 4 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(4);

        /// <summary>
        /// 4 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(4);

        /// <summary>
        /// 4 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(4);

        /// <summary>
        /// 4 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(4);

        /// <summary>
        /// 4 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(4);

        /// <summary>
        /// 4 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(28);

        /// <summary>
        /// 4 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(28);

        /// <summary>
        /// 4 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(4);

        /// <summary>
        /// 4 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(4);

        /// <summary>
        /// 4 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(4);

        /// <summary>
        /// 4 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(4);
    }

    /// <summary>
    /// </summary>
    public static class Five
    {
        /// <summary>
        /// 5 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(5);

        /// <summary>
        /// 5 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(5);

        /// <summary>
        /// 5 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(5);

        /// <summary>
        /// 5 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(5);

        /// <summary>
        /// 5 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(5);

        /// <summary>
        /// 5 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(5);

        /// <summary>
        /// 5 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(5);

        /// <summary>
        /// 5 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(5);

        /// <summary>
        /// 5 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(35);

        /// <summary>
        /// 5 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(35);

        /// <summary>
        /// 5 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(5);

        /// <summary>
        /// 5 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(5);

        /// <summary>
        /// 5 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(5);

        /// <summary>
        /// 5 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(5);
    }

    /// <summary>
    /// </summary>
    public static class Six
    {
        /// <summary>
        /// 6 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(6);

        /// <summary>
        /// 6 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(6);

        /// <summary>
        /// 6 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(6);

        /// <summary>
        /// 6 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(6);

        /// <summary>
        /// 6 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(6);

        /// <summary>
        /// 6 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(6);

        /// <summary>
        /// 6 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(6);

        /// <summary>
        /// 6 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(6);

        /// <summary>
        /// 6 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(42);

        /// <summary>
        /// 6 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(42);

        /// <summary>
        /// 6 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(6);

        /// <summary>
        /// 6 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(6);

        /// <summary>
        /// 6 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(6);

        /// <summary>
        /// 6 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(6);
    }

    /// <summary>
    /// </summary>
    public static class Seven
    {
        /// <summary>
        /// 7 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(7);

        /// <summary>
        /// 7 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(7);

        /// <summary>
        /// 7 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(7);

        /// <summary>
        /// 7 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(7);

        /// <summary>
        /// 7 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(7);

        /// <summary>
        /// 7 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(7);

        /// <summary>
        /// 7 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(7);

        /// <summary>
        /// 7 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(7);

        /// <summary>
        /// 7 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(49);

        /// <summary>
        /// 7 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(49);

        /// <summary>
        /// 7 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(7);

        /// <summary>
        /// 7 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(7);

        /// <summary>
        /// 7 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(7);

        /// <summary>
        /// 7 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(7);
    }

    /// <summary>
    /// </summary>
    public static class Eight
    {
        /// <summary>
        /// 8 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(8);

        /// <summary>
        /// 8 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(8);

        /// <summary>
        /// 8 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(8);

        /// <summary>
        /// 8 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(8);

        /// <summary>
        /// 8 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(8);

        /// <summary>
        /// 8 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(8);

        /// <summary>
        /// 8 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(8);

        /// <summary>
        /// 8 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(8);

        /// <summary>
        /// 8 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(56);

        /// <summary>
        /// 8 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(56);

        /// <summary>
        /// 8 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(8);

        /// <summary>
        /// 8 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(8);

        /// <summary>
        /// 8 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(8);

        /// <summary>
        /// 8 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(8);
    }

    /// <summary>
    /// </summary>
    public static class Nine
    {
        /// <summary>
        /// 9 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(9);

        /// <summary>
        /// 9 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(9);

        /// <summary>
        /// 9 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(9);

        /// <summary>
        /// 9 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(9);

        /// <summary>
        /// 9 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(9);

        /// <summary>
        /// 9 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(9);

        /// <summary>
        /// 9 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(9);

        /// <summary>
        /// 9 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(9);

        /// <summary>
        /// 9 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(63);

        /// <summary>
        /// 9 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(63);

        /// <summary>
        /// 9 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(9);

        /// <summary>
        /// 9 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(9);

        /// <summary>
        /// 9 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(9);

        /// <summary>
        /// 9 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(9);
    }

    /// <summary>
    /// </summary>
    public static class Ten
    {
        /// <summary>
        /// 10 seconds from now
        /// </summary>
        public static DateTime Seconds
            => DateTime.UtcNow.AddSeconds(10);

        /// <summary>
        /// 10 seconds from the provided date
        /// </summary>
        public static DateTime SecondsFrom(DateTime date)
            => date.AddSeconds(10);

        /// <summary>
        /// 10 minutes from now
        /// </summary>
        public static DateTime Minutes
            => DateTime.UtcNow.AddMinutes(10);

        /// <summary>
        /// 10 minutes from the provided date
        /// </summary>
        public static DateTime MinutesFrom(DateTime date)
            => date.AddMinutes(10);

        /// <summary>
        /// 10 hours from now
        /// </summary>
        public static DateTime Hours
            => DateTime.UtcNow.AddHours(10);

        /// <summary>
        /// 10 hours from the provided date
        /// </summary>
        public static DateTime HoursFrom(DateTime date)
            => date.AddHours(10);

        /// <summary>
        /// 10 days from now
        /// </summary>
        public static DateTime Days
            => DateTime.UtcNow.AddDays(10);

        /// <summary>
        /// 10 days from the provided date
        /// </summary>
        public static DateTime DaysFrom(DateTime date)
            => date.AddDays(10);

        /// <summary>
        /// 10 weeks from now
        /// </summary>
        public static DateTime Weeks
            => DateTime.UtcNow.AddDays(70);

        /// <summary>
        /// 10 weeks from the provided date
        /// </summary>
        public static DateTime WeeksFrom(DateTime date)
            => date.AddDays(70);

        /// <summary>
        /// 10 months from now
        /// </summary>
        public static DateTime Months
            => DateTime.UtcNow.AddMonths(10);

        /// <summary>
        /// 10 months from the provided date
        /// </summary>
        public static DateTime MonthsFrom(DateTime date)
            => date.AddMonths(10);

        /// <summary>
        /// 10 years from now
        /// </summary>
        public static DateTime Years
            => DateTime.UtcNow.AddYears(10);

        /// <summary>
        /// 10 years from the provided date
        /// </summary>
        public static DateTime YearsFrom(DateTime date)
            => date.AddYears(10);
    }

}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\InDate.cs ---


#if NET6_0_OR_GREATER
namespace Humanizer;

public partial class InDate
{
    /// <summary>
    /// Returns the first of January of the provided year
    /// </summary>
    public static DateOnly TheYear(int year) =>
        new(year, 1, 1);
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\InDate.Months.cs ---



#if NET6_0_OR_GREATER
namespace Humanizer;

public partial class InDate
{
    /// <summary>
    /// Returns 1st of January of the current year
    /// </summary>
    public static DateOnly January
        => new(DateTime.UtcNow.Year, 1, 1);

    /// <summary>
    /// Returns 1st of January of the year passed in
    /// </summary>
    public static DateOnly JanuaryOf(int year)
        => new(year, 1, 1);

    /// <summary>
    /// Returns 1st of February of the current year
    /// </summary>
    public static DateOnly February
        => new(DateTime.UtcNow.Year, 2, 1);

    /// <summary>
    /// Returns 1st of February of the year passed in
    /// </summary>
    public static DateOnly FebruaryOf(int year)
        => new(year, 2, 1);

    /// <summary>
    /// Returns 1st of March of the current year
    /// </summary>
    public static DateOnly March
        => new(DateTime.UtcNow.Year, 3, 1);

    /// <summary>
    /// Returns 1st of March of the year passed in
    /// </summary>
    public static DateOnly MarchOf(int year)
        => new(year, 3, 1);

    /// <summary>
    /// Returns 1st of April of the current year
    /// </summary>
    public static DateOnly April
        => new(DateTime.UtcNow.Year, 4, 1);

    /// <summary>
    /// Returns 1st of April of the year passed in
    /// </summary>
    public static DateOnly AprilOf(int year)
        => new(year, 4, 1);

    /// <summary>
    /// Returns 1st of May of the current year
    /// </summary>
    public static DateOnly May
        => new(DateTime.UtcNow.Year, 5, 1);

    /// <summary>
    /// Returns 1st of May of the year passed in
    /// </summary>
    public static DateOnly MayOf(int year)
        => new(year, 5, 1);

    /// <summary>
    /// Returns 1st of June of the current year
    /// </summary>
    public static DateOnly June
        => new(DateTime.UtcNow.Year, 6, 1);

    /// <summary>
    /// Returns 1st of June of the year passed in
    /// </summary>
    public static DateOnly JuneOf(int year)
        => new(year, 6, 1);

    /// <summary>
    /// Returns 1st of July of the current year
    /// </summary>
    public static DateOnly July
        => new(DateTime.UtcNow.Year, 7, 1);

    /// <summary>
    /// Returns 1st of July of the year passed in
    /// </summary>
    public static DateOnly JulyOf(int year)
        => new(year, 7, 1);

    /// <summary>
    /// Returns 1st of August of the current year
    /// </summary>
    public static DateOnly August
        => new(DateTime.UtcNow.Year, 8, 1);

    /// <summary>
    /// Returns 1st of August of the year passed in
    /// </summary>
    public static DateOnly AugustOf(int year)
        => new(year, 8, 1);

    /// <summary>
    /// Returns 1st of September of the current year
    /// </summary>
    public static DateOnly September
        => new(DateTime.UtcNow.Year, 9, 1);

    /// <summary>
    /// Returns 1st of September of the year passed in
    /// </summary>
    public static DateOnly SeptemberOf(int year)
        => new(year, 9, 1);

    /// <summary>
    /// Returns 1st of October of the current year
    /// </summary>
    public static DateOnly October
        => new(DateTime.UtcNow.Year, 10, 1);

    /// <summary>
    /// Returns 1st of October of the year passed in
    /// </summary>
    public static DateOnly OctoberOf(int year)
        => new(year, 10, 1);

    /// <summary>
    /// Returns 1st of November of the current year
    /// </summary>
    public static DateOnly November
        => new(DateTime.UtcNow.Year, 11, 1);

    /// <summary>
    /// Returns 1st of November of the year passed in
    /// </summary>
    public static DateOnly NovemberOf(int year)
        => new(year, 11, 1);

    /// <summary>
    /// Returns 1st of December of the current year
    /// </summary>
    public static DateOnly December
        => new(DateTime.UtcNow.Year, 12, 1);

    /// <summary>
    /// Returns 1st of December of the year passed in
    /// </summary>
    public static DateOnly DecemberOf(int year)
        => new(year, 12, 1);

}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\InDate.SomeTimeFrom.cs ---


#if NET6_0_OR_GREATER
namespace Humanizer;

/// <summary>
/// </summary>
public partial class InDate
{
    /// <summary>
    /// </summary>
    public static class One
    {
        /// <summary>
        /// 1 days from now
        /// </summary>
        public static DateOnly Day
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(1));

        /// <summary>
        /// 1 days from the provided date
        /// </summary>
        public static DateOnly DayFrom(DateOnly date)
            => date.AddDays(1);

        /// <summary>
        /// 1 days from the provided date
        /// </summary>
        public static DateOnly DayFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(1));

        /// <summary>
        /// 1 weeks from now
        /// </summary>
        public static DateOnly Week
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(7));

        /// <summary>
        /// 1 weeks from the provided date
        /// </summary>
        public static DateOnly WeekFrom(DateOnly date)
            => date.AddDays(7);

        /// <summary>
        /// 1 weeks from the provided date
        /// </summary>
        public static DateOnly WeekFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(7));

        /// <summary>
        /// 1 months from now
        /// </summary>
        public static DateOnly Month
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(1));

        /// <summary>
        /// 1 months from the provided date
        /// </summary>
        public static DateOnly MonthFrom(DateOnly date)
            => date.AddMonths(1);

        /// <summary>
        /// 1 months from the provided date
        /// </summary>
        public static DateOnly MonthFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(1));

        /// <summary>
        /// 1 years from now
        /// </summary>
        public static DateOnly Year
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(1));

        /// <summary>
        /// 1 years from the provided date
        /// </summary>
        public static DateOnly YearFrom(DateOnly date)
            => date.AddYears(1);

        /// <summary>
        /// 1 years from the provided date
        /// </summary>
        public static DateOnly YearFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(1));
    }

    /// <summary>
    /// </summary>
    public static class Two
    {
        /// <summary>
        /// 2 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(2));

        /// <summary>
        /// 2 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(2);

        /// <summary>
        /// 2 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(2));

        /// <summary>
        /// 2 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(14));

        /// <summary>
        /// 2 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(14);

        /// <summary>
        /// 2 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(14));

        /// <summary>
        /// 2 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(2));

        /// <summary>
        /// 2 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(2);

        /// <summary>
        /// 2 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(2));

        /// <summary>
        /// 2 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(2));

        /// <summary>
        /// 2 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(2);

        /// <summary>
        /// 2 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(2));
    }

    /// <summary>
    /// </summary>
    public static class Three
    {
        /// <summary>
        /// 3 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(3));

        /// <summary>
        /// 3 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(3);

        /// <summary>
        /// 3 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(3));

        /// <summary>
        /// 3 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(21));

        /// <summary>
        /// 3 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(21);

        /// <summary>
        /// 3 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(21));

        /// <summary>
        /// 3 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(3));

        /// <summary>
        /// 3 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(3);

        /// <summary>
        /// 3 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(3));

        /// <summary>
        /// 3 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(3));

        /// <summary>
        /// 3 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(3);

        /// <summary>
        /// 3 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(3));
    }

    /// <summary>
    /// </summary>
    public static class Four
    {
        /// <summary>
        /// 4 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(4));

        /// <summary>
        /// 4 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(4);

        /// <summary>
        /// 4 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(4));

        /// <summary>
        /// 4 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(28));

        /// <summary>
        /// 4 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(28);

        /// <summary>
        /// 4 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(28));

        /// <summary>
        /// 4 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(4));

        /// <summary>
        /// 4 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(4);

        /// <summary>
        /// 4 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(4));

        /// <summary>
        /// 4 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(4));

        /// <summary>
        /// 4 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(4);

        /// <summary>
        /// 4 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(4));
    }

    /// <summary>
    /// </summary>
    public static class Five
    {
        /// <summary>
        /// 5 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(5));

        /// <summary>
        /// 5 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(5);

        /// <summary>
        /// 5 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(5));

        /// <summary>
        /// 5 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(35));

        /// <summary>
        /// 5 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(35);

        /// <summary>
        /// 5 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(35));

        /// <summary>
        /// 5 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(5));

        /// <summary>
        /// 5 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(5);

        /// <summary>
        /// 5 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(5));

        /// <summary>
        /// 5 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(5));

        /// <summary>
        /// 5 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(5);

        /// <summary>
        /// 5 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(5));
    }

    /// <summary>
    /// </summary>
    public static class Six
    {
        /// <summary>
        /// 6 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(6));

        /// <summary>
        /// 6 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(6);

        /// <summary>
        /// 6 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(6));

        /// <summary>
        /// 6 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(42));

        /// <summary>
        /// 6 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(42);

        /// <summary>
        /// 6 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(42));

        /// <summary>
        /// 6 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(6));

        /// <summary>
        /// 6 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(6);

        /// <summary>
        /// 6 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(6));

        /// <summary>
        /// 6 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(6));

        /// <summary>
        /// 6 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(6);

        /// <summary>
        /// 6 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(6));
    }

    /// <summary>
    /// </summary>
    public static class Seven
    {
        /// <summary>
        /// 7 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(7));

        /// <summary>
        /// 7 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(7);

        /// <summary>
        /// 7 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(7));

        /// <summary>
        /// 7 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(49));

        /// <summary>
        /// 7 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(49);

        /// <summary>
        /// 7 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(49));

        /// <summary>
        /// 7 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(7));

        /// <summary>
        /// 7 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(7);

        /// <summary>
        /// 7 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(7));

        /// <summary>
        /// 7 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(7));

        /// <summary>
        /// 7 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(7);

        /// <summary>
        /// 7 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(7));
    }

    /// <summary>
    /// </summary>
    public static class Eight
    {
        /// <summary>
        /// 8 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(8));

        /// <summary>
        /// 8 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(8);

        /// <summary>
        /// 8 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(8));

        /// <summary>
        /// 8 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(56));

        /// <summary>
        /// 8 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(56);

        /// <summary>
        /// 8 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(56));

        /// <summary>
        /// 8 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(8));

        /// <summary>
        /// 8 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(8);

        /// <summary>
        /// 8 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(8));

        /// <summary>
        /// 8 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(8));

        /// <summary>
        /// 8 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(8);

        /// <summary>
        /// 8 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(8));
    }

    /// <summary>
    /// </summary>
    public static class Nine
    {
        /// <summary>
        /// 9 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(9));

        /// <summary>
        /// 9 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(9);

        /// <summary>
        /// 9 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(9));

        /// <summary>
        /// 9 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(63));

        /// <summary>
        /// 9 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(63);

        /// <summary>
        /// 9 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(63));

        /// <summary>
        /// 9 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(9));

        /// <summary>
        /// 9 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(9);

        /// <summary>
        /// 9 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(9));

        /// <summary>
        /// 9 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(9));

        /// <summary>
        /// 9 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(9);

        /// <summary>
        /// 9 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(9));
    }

    /// <summary>
    /// </summary>
    public static class Ten
    {
        /// <summary>
        /// 10 days from now
        /// </summary>
        public static DateOnly Days
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(10));

        /// <summary>
        /// 10 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateOnly date)
            => date.AddDays(10);

        /// <summary>
        /// 10 days from the provided date
        /// </summary>
        public static DateOnly DaysFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(10));

        /// <summary>
        /// 10 weeks from now
        /// </summary>
        public static DateOnly Weeks
            => DateOnly.FromDateTime(DateTime.UtcNow.AddDays(70));

        /// <summary>
        /// 10 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateOnly date)
            => date.AddDays(70);

        /// <summary>
        /// 10 weeks from the provided date
        /// </summary>
        public static DateOnly WeeksFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddDays(70));

        /// <summary>
        /// 10 months from now
        /// </summary>
        public static DateOnly Months
            => DateOnly.FromDateTime(DateTime.UtcNow.AddMonths(10));

        /// <summary>
        /// 10 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateOnly date)
            => date.AddMonths(10);

        /// <summary>
        /// 10 months from the provided date
        /// </summary>
        public static DateOnly MonthsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddMonths(10));

        /// <summary>
        /// 10 years from now
        /// </summary>
        public static DateOnly Years
            => DateOnly.FromDateTime(DateTime.UtcNow.AddYears(10));

        /// <summary>
        /// 10 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateOnly date)
            => date.AddYears(10);

        /// <summary>
        /// 10 years from the provided date
        /// </summary>
        public static DateOnly YearsFrom(DateTime date)
            => DateOnly.FromDateTime(date.AddYears(10));
    }

}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\On.Days.cs ---


using System;

namespace Humanizer;

public class On
{
    /// <summary>
    /// Provides fluent date accessors for January
    /// </summary>
    public class January
    {
        /// <summary>
        /// The nth day of January of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 1, dayNumber);


        /// <summary>
        /// The 1st day of January of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 1, 1);

        /// <summary>
        /// The 2nd day of January of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 1, 2);

        /// <summary>
        /// The 3rd day of January of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 1, 3);

        /// <summary>
        /// The 4th day of January of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 1, 4);

        /// <summary>
        /// The 5th day of January of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 1, 5);

        /// <summary>
        /// The 6th day of January of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 1, 6);

        /// <summary>
        /// The 7th day of January of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 1, 7);

        /// <summary>
        /// The 8th day of January of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 1, 8);

        /// <summary>
        /// The 9th day of January of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 1, 9);

        /// <summary>
        /// The 10th day of January of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 1, 10);

        /// <summary>
        /// The 11th day of January of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 1, 11);

        /// <summary>
        /// The 12th day of January of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 1, 12);

        /// <summary>
        /// The 13th day of January of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 1, 13);

        /// <summary>
        /// The 14th day of January of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 1, 14);

        /// <summary>
        /// The 15th day of January of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 1, 15);

        /// <summary>
        /// The 16th day of January of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 1, 16);

        /// <summary>
        /// The 17th day of January of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 1, 17);

        /// <summary>
        /// The 18th day of January of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 1, 18);

        /// <summary>
        /// The 19th day of January of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 1, 19);

        /// <summary>
        /// The 20th day of January of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 1, 20);

        /// <summary>
        /// The 21st day of January of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 1, 21);

        /// <summary>
        /// The 22nd day of January of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 1, 22);

        /// <summary>
        /// The 23rd day of January of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 1, 23);

        /// <summary>
        /// The 24th day of January of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 1, 24);

        /// <summary>
        /// The 25th day of January of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 1, 25);

        /// <summary>
        /// The 26th day of January of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 1, 26);

        /// <summary>
        /// The 27th day of January of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 1, 27);

        /// <summary>
        /// The 28th day of January of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 1, 28);

        /// <summary>
        /// The 29th day of January of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 1, 29);

        /// <summary>
        /// The 30th day of January of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 1, 30);

        /// <summary>
        /// The 31st day of January of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 1, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for February
    /// </summary>
    public class February
    {
        /// <summary>
        /// The nth day of February of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 2, dayNumber);


        /// <summary>
        /// The 1st day of February of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 2, 1);

        /// <summary>
        /// The 2nd day of February of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 2, 2);

        /// <summary>
        /// The 3rd day of February of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 2, 3);

        /// <summary>
        /// The 4th day of February of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 2, 4);

        /// <summary>
        /// The 5th day of February of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 2, 5);

        /// <summary>
        /// The 6th day of February of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 2, 6);

        /// <summary>
        /// The 7th day of February of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 2, 7);

        /// <summary>
        /// The 8th day of February of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 2, 8);

        /// <summary>
        /// The 9th day of February of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 2, 9);

        /// <summary>
        /// The 10th day of February of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 2, 10);

        /// <summary>
        /// The 11th day of February of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 2, 11);

        /// <summary>
        /// The 12th day of February of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 2, 12);

        /// <summary>
        /// The 13th day of February of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 2, 13);

        /// <summary>
        /// The 14th day of February of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 2, 14);

        /// <summary>
        /// The 15th day of February of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 2, 15);

        /// <summary>
        /// The 16th day of February of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 2, 16);

        /// <summary>
        /// The 17th day of February of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 2, 17);

        /// <summary>
        /// The 18th day of February of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 2, 18);

        /// <summary>
        /// The 19th day of February of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 2, 19);

        /// <summary>
        /// The 20th day of February of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 2, 20);

        /// <summary>
        /// The 21st day of February of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 2, 21);

        /// <summary>
        /// The 22nd day of February of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 2, 22);

        /// <summary>
        /// The 23rd day of February of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 2, 23);

        /// <summary>
        /// The 24th day of February of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 2, 24);

        /// <summary>
        /// The 25th day of February of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 2, 25);

        /// <summary>
        /// The 26th day of February of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 2, 26);

        /// <summary>
        /// The 27th day of February of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 2, 27);

        /// <summary>
        /// The 28th day of February of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 2, 28);

        /// <summary>
        /// The 29th day of February of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 2, 29);
    }
    /// <summary>
    /// Provides fluent date accessors for March
    /// </summary>
    public class March
    {
        /// <summary>
        /// The nth day of March of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 3, dayNumber);


        /// <summary>
        /// The 1st day of March of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 3, 1);

        /// <summary>
        /// The 2nd day of March of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 3, 2);

        /// <summary>
        /// The 3rd day of March of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 3, 3);

        /// <summary>
        /// The 4th day of March of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 3, 4);

        /// <summary>
        /// The 5th day of March of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 3, 5);

        /// <summary>
        /// The 6th day of March of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 3, 6);

        /// <summary>
        /// The 7th day of March of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 3, 7);

        /// <summary>
        /// The 8th day of March of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 3, 8);

        /// <summary>
        /// The 9th day of March of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 3, 9);

        /// <summary>
        /// The 10th day of March of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 3, 10);

        /// <summary>
        /// The 11th day of March of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 3, 11);

        /// <summary>
        /// The 12th day of March of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 3, 12);

        /// <summary>
        /// The 13th day of March of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 3, 13);

        /// <summary>
        /// The 14th day of March of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 3, 14);

        /// <summary>
        /// The 15th day of March of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 3, 15);

        /// <summary>
        /// The 16th day of March of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 3, 16);

        /// <summary>
        /// The 17th day of March of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 3, 17);

        /// <summary>
        /// The 18th day of March of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 3, 18);

        /// <summary>
        /// The 19th day of March of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 3, 19);

        /// <summary>
        /// The 20th day of March of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 3, 20);

        /// <summary>
        /// The 21st day of March of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 3, 21);

        /// <summary>
        /// The 22nd day of March of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 3, 22);

        /// <summary>
        /// The 23rd day of March of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 3, 23);

        /// <summary>
        /// The 24th day of March of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 3, 24);

        /// <summary>
        /// The 25th day of March of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 3, 25);

        /// <summary>
        /// The 26th day of March of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 3, 26);

        /// <summary>
        /// The 27th day of March of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 3, 27);

        /// <summary>
        /// The 28th day of March of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 3, 28);

        /// <summary>
        /// The 29th day of March of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 3, 29);

        /// <summary>
        /// The 30th day of March of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 3, 30);

        /// <summary>
        /// The 31st day of March of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 3, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for April
    /// </summary>
    public class April
    {
        /// <summary>
        /// The nth day of April of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 4, dayNumber);


        /// <summary>
        /// The 1st day of April of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 4, 1);

        /// <summary>
        /// The 2nd day of April of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 4, 2);

        /// <summary>
        /// The 3rd day of April of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 4, 3);

        /// <summary>
        /// The 4th day of April of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 4, 4);

        /// <summary>
        /// The 5th day of April of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 4, 5);

        /// <summary>
        /// The 6th day of April of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 4, 6);

        /// <summary>
        /// The 7th day of April of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 4, 7);

        /// <summary>
        /// The 8th day of April of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 4, 8);

        /// <summary>
        /// The 9th day of April of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 4, 9);

        /// <summary>
        /// The 10th day of April of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 4, 10);

        /// <summary>
        /// The 11th day of April of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 4, 11);

        /// <summary>
        /// The 12th day of April of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 4, 12);

        /// <summary>
        /// The 13th day of April of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 4, 13);

        /// <summary>
        /// The 14th day of April of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 4, 14);

        /// <summary>
        /// The 15th day of April of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 4, 15);

        /// <summary>
        /// The 16th day of April of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 4, 16);

        /// <summary>
        /// The 17th day of April of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 4, 17);

        /// <summary>
        /// The 18th day of April of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 4, 18);

        /// <summary>
        /// The 19th day of April of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 4, 19);

        /// <summary>
        /// The 20th day of April of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 4, 20);

        /// <summary>
        /// The 21st day of April of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 4, 21);

        /// <summary>
        /// The 22nd day of April of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 4, 22);

        /// <summary>
        /// The 23rd day of April of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 4, 23);

        /// <summary>
        /// The 24th day of April of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 4, 24);

        /// <summary>
        /// The 25th day of April of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 4, 25);

        /// <summary>
        /// The 26th day of April of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 4, 26);

        /// <summary>
        /// The 27th day of April of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 4, 27);

        /// <summary>
        /// The 28th day of April of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 4, 28);

        /// <summary>
        /// The 29th day of April of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 4, 29);

        /// <summary>
        /// The 30th day of April of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 4, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for May
    /// </summary>
    public class May
    {
        /// <summary>
        /// The nth day of May of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 5, dayNumber);


        /// <summary>
        /// The 1st day of May of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 5, 1);

        /// <summary>
        /// The 2nd day of May of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 5, 2);

        /// <summary>
        /// The 3rd day of May of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 5, 3);

        /// <summary>
        /// The 4th day of May of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 5, 4);

        /// <summary>
        /// The 5th day of May of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 5, 5);

        /// <summary>
        /// The 6th day of May of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 5, 6);

        /// <summary>
        /// The 7th day of May of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 5, 7);

        /// <summary>
        /// The 8th day of May of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 5, 8);

        /// <summary>
        /// The 9th day of May of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 5, 9);

        /// <summary>
        /// The 10th day of May of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 5, 10);

        /// <summary>
        /// The 11th day of May of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 5, 11);

        /// <summary>
        /// The 12th day of May of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 5, 12);

        /// <summary>
        /// The 13th day of May of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 5, 13);

        /// <summary>
        /// The 14th day of May of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 5, 14);

        /// <summary>
        /// The 15th day of May of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 5, 15);

        /// <summary>
        /// The 16th day of May of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 5, 16);

        /// <summary>
        /// The 17th day of May of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 5, 17);

        /// <summary>
        /// The 18th day of May of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 5, 18);

        /// <summary>
        /// The 19th day of May of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 5, 19);

        /// <summary>
        /// The 20th day of May of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 5, 20);

        /// <summary>
        /// The 21st day of May of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 5, 21);

        /// <summary>
        /// The 22nd day of May of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 5, 22);

        /// <summary>
        /// The 23rd day of May of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 5, 23);

        /// <summary>
        /// The 24th day of May of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 5, 24);

        /// <summary>
        /// The 25th day of May of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 5, 25);

        /// <summary>
        /// The 26th day of May of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 5, 26);

        /// <summary>
        /// The 27th day of May of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 5, 27);

        /// <summary>
        /// The 28th day of May of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 5, 28);

        /// <summary>
        /// The 29th day of May of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 5, 29);

        /// <summary>
        /// The 30th day of May of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 5, 30);

        /// <summary>
        /// The 31st day of May of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 5, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for June
    /// </summary>
    public class June
    {
        /// <summary>
        /// The nth day of June of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 6, dayNumber);


        /// <summary>
        /// The 1st day of June of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 6, 1);

        /// <summary>
        /// The 2nd day of June of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 6, 2);

        /// <summary>
        /// The 3rd day of June of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 6, 3);

        /// <summary>
        /// The 4th day of June of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 6, 4);

        /// <summary>
        /// The 5th day of June of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 6, 5);

        /// <summary>
        /// The 6th day of June of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 6, 6);

        /// <summary>
        /// The 7th day of June of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 6, 7);

        /// <summary>
        /// The 8th day of June of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 6, 8);

        /// <summary>
        /// The 9th day of June of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 6, 9);

        /// <summary>
        /// The 10th day of June of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 6, 10);

        /// <summary>
        /// The 11th day of June of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 6, 11);

        /// <summary>
        /// The 12th day of June of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 6, 12);

        /// <summary>
        /// The 13th day of June of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 6, 13);

        /// <summary>
        /// The 14th day of June of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 6, 14);

        /// <summary>
        /// The 15th day of June of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 6, 15);

        /// <summary>
        /// The 16th day of June of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 6, 16);

        /// <summary>
        /// The 17th day of June of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 6, 17);

        /// <summary>
        /// The 18th day of June of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 6, 18);

        /// <summary>
        /// The 19th day of June of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 6, 19);

        /// <summary>
        /// The 20th day of June of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 6, 20);

        /// <summary>
        /// The 21st day of June of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 6, 21);

        /// <summary>
        /// The 22nd day of June of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 6, 22);

        /// <summary>
        /// The 23rd day of June of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 6, 23);

        /// <summary>
        /// The 24th day of June of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 6, 24);

        /// <summary>
        /// The 25th day of June of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 6, 25);

        /// <summary>
        /// The 26th day of June of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 6, 26);

        /// <summary>
        /// The 27th day of June of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 6, 27);

        /// <summary>
        /// The 28th day of June of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 6, 28);

        /// <summary>
        /// The 29th day of June of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 6, 29);

        /// <summary>
        /// The 30th day of June of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 6, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for July
    /// </summary>
    public class July
    {
        /// <summary>
        /// The nth day of July of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 7, dayNumber);


        /// <summary>
        /// The 1st day of July of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 7, 1);

        /// <summary>
        /// The 2nd day of July of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 7, 2);

        /// <summary>
        /// The 3rd day of July of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 7, 3);

        /// <summary>
        /// The 4th day of July of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 7, 4);

        /// <summary>
        /// The 5th day of July of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 7, 5);

        /// <summary>
        /// The 6th day of July of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 7, 6);

        /// <summary>
        /// The 7th day of July of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 7, 7);

        /// <summary>
        /// The 8th day of July of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 7, 8);

        /// <summary>
        /// The 9th day of July of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 7, 9);

        /// <summary>
        /// The 10th day of July of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 7, 10);

        /// <summary>
        /// The 11th day of July of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 7, 11);

        /// <summary>
        /// The 12th day of July of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 7, 12);

        /// <summary>
        /// The 13th day of July of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 7, 13);

        /// <summary>
        /// The 14th day of July of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 7, 14);

        /// <summary>
        /// The 15th day of July of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 7, 15);

        /// <summary>
        /// The 16th day of July of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 7, 16);

        /// <summary>
        /// The 17th day of July of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 7, 17);

        /// <summary>
        /// The 18th day of July of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 7, 18);

        /// <summary>
        /// The 19th day of July of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 7, 19);

        /// <summary>
        /// The 20th day of July of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 7, 20);

        /// <summary>
        /// The 21st day of July of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 7, 21);

        /// <summary>
        /// The 22nd day of July of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 7, 22);

        /// <summary>
        /// The 23rd day of July of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 7, 23);

        /// <summary>
        /// The 24th day of July of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 7, 24);

        /// <summary>
        /// The 25th day of July of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 7, 25);

        /// <summary>
        /// The 26th day of July of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 7, 26);

        /// <summary>
        /// The 27th day of July of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 7, 27);

        /// <summary>
        /// The 28th day of July of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 7, 28);

        /// <summary>
        /// The 29th day of July of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 7, 29);

        /// <summary>
        /// The 30th day of July of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 7, 30);

        /// <summary>
        /// The 31st day of July of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 7, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for August
    /// </summary>
    public class August
    {
        /// <summary>
        /// The nth day of August of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 8, dayNumber);


        /// <summary>
        /// The 1st day of August of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 8, 1);

        /// <summary>
        /// The 2nd day of August of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 8, 2);

        /// <summary>
        /// The 3rd day of August of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 8, 3);

        /// <summary>
        /// The 4th day of August of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 8, 4);

        /// <summary>
        /// The 5th day of August of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 8, 5);

        /// <summary>
        /// The 6th day of August of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 8, 6);

        /// <summary>
        /// The 7th day of August of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 8, 7);

        /// <summary>
        /// The 8th day of August of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 8, 8);

        /// <summary>
        /// The 9th day of August of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 8, 9);

        /// <summary>
        /// The 10th day of August of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 8, 10);

        /// <summary>
        /// The 11th day of August of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 8, 11);

        /// <summary>
        /// The 12th day of August of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 8, 12);

        /// <summary>
        /// The 13th day of August of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 8, 13);

        /// <summary>
        /// The 14th day of August of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 8, 14);

        /// <summary>
        /// The 15th day of August of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 8, 15);

        /// <summary>
        /// The 16th day of August of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 8, 16);

        /// <summary>
        /// The 17th day of August of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 8, 17);

        /// <summary>
        /// The 18th day of August of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 8, 18);

        /// <summary>
        /// The 19th day of August of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 8, 19);

        /// <summary>
        /// The 20th day of August of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 8, 20);

        /// <summary>
        /// The 21st day of August of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 8, 21);

        /// <summary>
        /// The 22nd day of August of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 8, 22);

        /// <summary>
        /// The 23rd day of August of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 8, 23);

        /// <summary>
        /// The 24th day of August of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 8, 24);

        /// <summary>
        /// The 25th day of August of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 8, 25);

        /// <summary>
        /// The 26th day of August of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 8, 26);

        /// <summary>
        /// The 27th day of August of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 8, 27);

        /// <summary>
        /// The 28th day of August of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 8, 28);

        /// <summary>
        /// The 29th day of August of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 8, 29);

        /// <summary>
        /// The 30th day of August of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 8, 30);

        /// <summary>
        /// The 31st day of August of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 8, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for September
    /// </summary>
    public class September
    {
        /// <summary>
        /// The nth day of September of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 9, dayNumber);


        /// <summary>
        /// The 1st day of September of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 9, 1);

        /// <summary>
        /// The 2nd day of September of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 9, 2);

        /// <summary>
        /// The 3rd day of September of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 9, 3);

        /// <summary>
        /// The 4th day of September of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 9, 4);

        /// <summary>
        /// The 5th day of September of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 9, 5);

        /// <summary>
        /// The 6th day of September of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 9, 6);

        /// <summary>
        /// The 7th day of September of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 9, 7);

        /// <summary>
        /// The 8th day of September of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 9, 8);

        /// <summary>
        /// The 9th day of September of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 9, 9);

        /// <summary>
        /// The 10th day of September of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 9, 10);

        /// <summary>
        /// The 11th day of September of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 9, 11);

        /// <summary>
        /// The 12th day of September of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 9, 12);

        /// <summary>
        /// The 13th day of September of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 9, 13);

        /// <summary>
        /// The 14th day of September of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 9, 14);

        /// <summary>
        /// The 15th day of September of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 9, 15);

        /// <summary>
        /// The 16th day of September of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 9, 16);

        /// <summary>
        /// The 17th day of September of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 9, 17);

        /// <summary>
        /// The 18th day of September of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 9, 18);

        /// <summary>
        /// The 19th day of September of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 9, 19);

        /// <summary>
        /// The 20th day of September of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 9, 20);

        /// <summary>
        /// The 21st day of September of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 9, 21);

        /// <summary>
        /// The 22nd day of September of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 9, 22);

        /// <summary>
        /// The 23rd day of September of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 9, 23);

        /// <summary>
        /// The 24th day of September of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 9, 24);

        /// <summary>
        /// The 25th day of September of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 9, 25);

        /// <summary>
        /// The 26th day of September of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 9, 26);

        /// <summary>
        /// The 27th day of September of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 9, 27);

        /// <summary>
        /// The 28th day of September of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 9, 28);

        /// <summary>
        /// The 29th day of September of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 9, 29);

        /// <summary>
        /// The 30th day of September of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 9, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for October
    /// </summary>
    public class October
    {
        /// <summary>
        /// The nth day of October of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 10, dayNumber);


        /// <summary>
        /// The 1st day of October of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 10, 1);

        /// <summary>
        /// The 2nd day of October of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 10, 2);

        /// <summary>
        /// The 3rd day of October of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 10, 3);

        /// <summary>
        /// The 4th day of October of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 10, 4);

        /// <summary>
        /// The 5th day of October of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 10, 5);

        /// <summary>
        /// The 6th day of October of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 10, 6);

        /// <summary>
        /// The 7th day of October of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 10, 7);

        /// <summary>
        /// The 8th day of October of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 10, 8);

        /// <summary>
        /// The 9th day of October of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 10, 9);

        /// <summary>
        /// The 10th day of October of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 10, 10);

        /// <summary>
        /// The 11th day of October of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 10, 11);

        /// <summary>
        /// The 12th day of October of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 10, 12);

        /// <summary>
        /// The 13th day of October of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 10, 13);

        /// <summary>
        /// The 14th day of October of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 10, 14);

        /// <summary>
        /// The 15th day of October of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 10, 15);

        /// <summary>
        /// The 16th day of October of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 10, 16);

        /// <summary>
        /// The 17th day of October of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 10, 17);

        /// <summary>
        /// The 18th day of October of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 10, 18);

        /// <summary>
        /// The 19th day of October of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 10, 19);

        /// <summary>
        /// The 20th day of October of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 10, 20);

        /// <summary>
        /// The 21st day of October of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 10, 21);

        /// <summary>
        /// The 22nd day of October of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 10, 22);

        /// <summary>
        /// The 23rd day of October of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 10, 23);

        /// <summary>
        /// The 24th day of October of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 10, 24);

        /// <summary>
        /// The 25th day of October of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 10, 25);

        /// <summary>
        /// The 26th day of October of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 10, 26);

        /// <summary>
        /// The 27th day of October of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 10, 27);

        /// <summary>
        /// The 28th day of October of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 10, 28);

        /// <summary>
        /// The 29th day of October of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 10, 29);

        /// <summary>
        /// The 30th day of October of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 10, 30);

        /// <summary>
        /// The 31st day of October of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 10, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for November
    /// </summary>
    public class November
    {
        /// <summary>
        /// The nth day of November of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 11, dayNumber);


        /// <summary>
        /// The 1st day of November of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 11, 1);

        /// <summary>
        /// The 2nd day of November of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 11, 2);

        /// <summary>
        /// The 3rd day of November of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 11, 3);

        /// <summary>
        /// The 4th day of November of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 11, 4);

        /// <summary>
        /// The 5th day of November of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 11, 5);

        /// <summary>
        /// The 6th day of November of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 11, 6);

        /// <summary>
        /// The 7th day of November of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 11, 7);

        /// <summary>
        /// The 8th day of November of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 11, 8);

        /// <summary>
        /// The 9th day of November of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 11, 9);

        /// <summary>
        /// The 10th day of November of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 11, 10);

        /// <summary>
        /// The 11th day of November of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 11, 11);

        /// <summary>
        /// The 12th day of November of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 11, 12);

        /// <summary>
        /// The 13th day of November of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 11, 13);

        /// <summary>
        /// The 14th day of November of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 11, 14);

        /// <summary>
        /// The 15th day of November of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 11, 15);

        /// <summary>
        /// The 16th day of November of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 11, 16);

        /// <summary>
        /// The 17th day of November of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 11, 17);

        /// <summary>
        /// The 18th day of November of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 11, 18);

        /// <summary>
        /// The 19th day of November of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 11, 19);

        /// <summary>
        /// The 20th day of November of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 11, 20);

        /// <summary>
        /// The 21st day of November of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 11, 21);

        /// <summary>
        /// The 22nd day of November of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 11, 22);

        /// <summary>
        /// The 23rd day of November of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 11, 23);

        /// <summary>
        /// The 24th day of November of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 11, 24);

        /// <summary>
        /// The 25th day of November of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 11, 25);

        /// <summary>
        /// The 26th day of November of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 11, 26);

        /// <summary>
        /// The 27th day of November of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 11, 27);

        /// <summary>
        /// The 28th day of November of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 11, 28);

        /// <summary>
        /// The 29th day of November of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 11, 29);

        /// <summary>
        /// The 30th day of November of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 11, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for December
    /// </summary>
    public class December
    {
        /// <summary>
        /// The nth day of December of the current year
        /// </summary>
        public static DateTime The(int dayNumber)
            => new(DateTime.Now.Year, 12, dayNumber);


        /// <summary>
        /// The 1st day of December of the current year
        /// </summary>
        public static DateTime The1st
            => new(DateTime.Now.Year, 12, 1);

        /// <summary>
        /// The 2nd day of December of the current year
        /// </summary>
        public static DateTime The2nd
            => new(DateTime.Now.Year, 12, 2);

        /// <summary>
        /// The 3rd day of December of the current year
        /// </summary>
        public static DateTime The3rd
            => new(DateTime.Now.Year, 12, 3);

        /// <summary>
        /// The 4th day of December of the current year
        /// </summary>
        public static DateTime The4th
            => new(DateTime.Now.Year, 12, 4);

        /// <summary>
        /// The 5th day of December of the current year
        /// </summary>
        public static DateTime The5th
            => new(DateTime.Now.Year, 12, 5);

        /// <summary>
        /// The 6th day of December of the current year
        /// </summary>
        public static DateTime The6th
            => new(DateTime.Now.Year, 12, 6);

        /// <summary>
        /// The 7th day of December of the current year
        /// </summary>
        public static DateTime The7th
            => new(DateTime.Now.Year, 12, 7);

        /// <summary>
        /// The 8th day of December of the current year
        /// </summary>
        public static DateTime The8th
            => new(DateTime.Now.Year, 12, 8);

        /// <summary>
        /// The 9th day of December of the current year
        /// </summary>
        public static DateTime The9th
            => new(DateTime.Now.Year, 12, 9);

        /// <summary>
        /// The 10th day of December of the current year
        /// </summary>
        public static DateTime The10th
            => new(DateTime.Now.Year, 12, 10);

        /// <summary>
        /// The 11th day of December of the current year
        /// </summary>
        public static DateTime The11th
            => new(DateTime.Now.Year, 12, 11);

        /// <summary>
        /// The 12th day of December of the current year
        /// </summary>
        public static DateTime The12th
            => new(DateTime.Now.Year, 12, 12);

        /// <summary>
        /// The 13th day of December of the current year
        /// </summary>
        public static DateTime The13th
            => new(DateTime.Now.Year, 12, 13);

        /// <summary>
        /// The 14th day of December of the current year
        /// </summary>
        public static DateTime The14th
            => new(DateTime.Now.Year, 12, 14);

        /// <summary>
        /// The 15th day of December of the current year
        /// </summary>
        public static DateTime The15th
            => new(DateTime.Now.Year, 12, 15);

        /// <summary>
        /// The 16th day of December of the current year
        /// </summary>
        public static DateTime The16th
            => new(DateTime.Now.Year, 12, 16);

        /// <summary>
        /// The 17th day of December of the current year
        /// </summary>
        public static DateTime The17th
            => new(DateTime.Now.Year, 12, 17);

        /// <summary>
        /// The 18th day of December of the current year
        /// </summary>
        public static DateTime The18th
            => new(DateTime.Now.Year, 12, 18);

        /// <summary>
        /// The 19th day of December of the current year
        /// </summary>
        public static DateTime The19th
            => new(DateTime.Now.Year, 12, 19);

        /// <summary>
        /// The 20th day of December of the current year
        /// </summary>
        public static DateTime The20th
            => new(DateTime.Now.Year, 12, 20);

        /// <summary>
        /// The 21st day of December of the current year
        /// </summary>
        public static DateTime The21st
            => new(DateTime.Now.Year, 12, 21);

        /// <summary>
        /// The 22nd day of December of the current year
        /// </summary>
        public static DateTime The22nd
            => new(DateTime.Now.Year, 12, 22);

        /// <summary>
        /// The 23rd day of December of the current year
        /// </summary>
        public static DateTime The23rd
            => new(DateTime.Now.Year, 12, 23);

        /// <summary>
        /// The 24th day of December of the current year
        /// </summary>
        public static DateTime The24th
            => new(DateTime.Now.Year, 12, 24);

        /// <summary>
        /// The 25th day of December of the current year
        /// </summary>
        public static DateTime The25th
            => new(DateTime.Now.Year, 12, 25);

        /// <summary>
        /// The 26th day of December of the current year
        /// </summary>
        public static DateTime The26th
            => new(DateTime.Now.Year, 12, 26);

        /// <summary>
        /// The 27th day of December of the current year
        /// </summary>
        public static DateTime The27th
            => new(DateTime.Now.Year, 12, 27);

        /// <summary>
        /// The 28th day of December of the current year
        /// </summary>
        public static DateTime The28th
            => new(DateTime.Now.Year, 12, 28);

        /// <summary>
        /// The 29th day of December of the current year
        /// </summary>
        public static DateTime The29th
            => new(DateTime.Now.Year, 12, 29);

        /// <summary>
        /// The 30th day of December of the current year
        /// </summary>
        public static DateTime The30th
            => new(DateTime.Now.Year, 12, 30);

        /// <summary>
        /// The 31st day of December of the current year
        /// </summary>
        public static DateTime The31st
            => new(DateTime.Now.Year, 12, 31);
    }
}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\OnDate.Days.cs ---


#if NET6_0_OR_GREATER
namespace Humanizer;

public class OnDate
{
    /// <summary>
    /// Provides fluent date accessors for January
    /// </summary>
    public class January
    {
        /// <summary>
        /// The nth day of January of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 1, dayNumber);

        /// <summary>
        /// The 1st day of January of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 1, 1);

        /// <summary>
        /// The 2nd day of January of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 1, 2);

        /// <summary>
        /// The 3rd day of January of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 1, 3);

        /// <summary>
        /// The 4th day of January of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 1, 4);

        /// <summary>
        /// The 5th day of January of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 1, 5);

        /// <summary>
        /// The 6th day of January of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 1, 6);

        /// <summary>
        /// The 7th day of January of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 1, 7);

        /// <summary>
        /// The 8th day of January of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 1, 8);

        /// <summary>
        /// The 9th day of January of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 1, 9);

        /// <summary>
        /// The 10th day of January of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 1, 10);

        /// <summary>
        /// The 11th day of January of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 1, 11);

        /// <summary>
        /// The 12th day of January of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 1, 12);

        /// <summary>
        /// The 13th day of January of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 1, 13);

        /// <summary>
        /// The 14th day of January of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 1, 14);

        /// <summary>
        /// The 15th day of January of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 1, 15);

        /// <summary>
        /// The 16th day of January of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 1, 16);

        /// <summary>
        /// The 17th day of January of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 1, 17);

        /// <summary>
        /// The 18th day of January of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 1, 18);

        /// <summary>
        /// The 19th day of January of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 1, 19);

        /// <summary>
        /// The 20th day of January of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 1, 20);

        /// <summary>
        /// The 21st day of January of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 1, 21);

        /// <summary>
        /// The 22nd day of January of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 1, 22);

        /// <summary>
        /// The 23rd day of January of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 1, 23);

        /// <summary>
        /// The 24th day of January of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 1, 24);

        /// <summary>
        /// The 25th day of January of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 1, 25);

        /// <summary>
        /// The 26th day of January of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 1, 26);

        /// <summary>
        /// The 27th day of January of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 1, 27);

        /// <summary>
        /// The 28th day of January of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 1, 28);

        /// <summary>
        /// The 29th day of January of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 1, 29);

        /// <summary>
        /// The 30th day of January of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 1, 30);

        /// <summary>
        /// The 31st day of January of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 1, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for February
    /// </summary>
    public class February
    {
        /// <summary>
        /// The nth day of February of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 2, dayNumber);

        /// <summary>
        /// The 1st day of February of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 2, 1);

        /// <summary>
        /// The 2nd day of February of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 2, 2);

        /// <summary>
        /// The 3rd day of February of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 2, 3);

        /// <summary>
        /// The 4th day of February of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 2, 4);

        /// <summary>
        /// The 5th day of February of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 2, 5);

        /// <summary>
        /// The 6th day of February of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 2, 6);

        /// <summary>
        /// The 7th day of February of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 2, 7);

        /// <summary>
        /// The 8th day of February of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 2, 8);

        /// <summary>
        /// The 9th day of February of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 2, 9);

        /// <summary>
        /// The 10th day of February of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 2, 10);

        /// <summary>
        /// The 11th day of February of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 2, 11);

        /// <summary>
        /// The 12th day of February of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 2, 12);

        /// <summary>
        /// The 13th day of February of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 2, 13);

        /// <summary>
        /// The 14th day of February of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 2, 14);

        /// <summary>
        /// The 15th day of February of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 2, 15);

        /// <summary>
        /// The 16th day of February of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 2, 16);

        /// <summary>
        /// The 17th day of February of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 2, 17);

        /// <summary>
        /// The 18th day of February of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 2, 18);

        /// <summary>
        /// The 19th day of February of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 2, 19);

        /// <summary>
        /// The 20th day of February of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 2, 20);

        /// <summary>
        /// The 21st day of February of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 2, 21);

        /// <summary>
        /// The 22nd day of February of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 2, 22);

        /// <summary>
        /// The 23rd day of February of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 2, 23);

        /// <summary>
        /// The 24th day of February of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 2, 24);

        /// <summary>
        /// The 25th day of February of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 2, 25);

        /// <summary>
        /// The 26th day of February of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 2, 26);

        /// <summary>
        /// The 27th day of February of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 2, 27);

        /// <summary>
        /// The 28th day of February of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 2, 28);

        /// <summary>
        /// The 29th day of February of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 2, 29);
    }
    /// <summary>
    /// Provides fluent date accessors for March
    /// </summary>
    public class March
    {
        /// <summary>
        /// The nth day of March of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 3, dayNumber);

        /// <summary>
        /// The 1st day of March of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 3, 1);

        /// <summary>
        /// The 2nd day of March of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 3, 2);

        /// <summary>
        /// The 3rd day of March of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 3, 3);

        /// <summary>
        /// The 4th day of March of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 3, 4);

        /// <summary>
        /// The 5th day of March of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 3, 5);

        /// <summary>
        /// The 6th day of March of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 3, 6);

        /// <summary>
        /// The 7th day of March of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 3, 7);

        /// <summary>
        /// The 8th day of March of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 3, 8);

        /// <summary>
        /// The 9th day of March of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 3, 9);

        /// <summary>
        /// The 10th day of March of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 3, 10);

        /// <summary>
        /// The 11th day of March of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 3, 11);

        /// <summary>
        /// The 12th day of March of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 3, 12);

        /// <summary>
        /// The 13th day of March of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 3, 13);

        /// <summary>
        /// The 14th day of March of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 3, 14);

        /// <summary>
        /// The 15th day of March of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 3, 15);

        /// <summary>
        /// The 16th day of March of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 3, 16);

        /// <summary>
        /// The 17th day of March of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 3, 17);

        /// <summary>
        /// The 18th day of March of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 3, 18);

        /// <summary>
        /// The 19th day of March of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 3, 19);

        /// <summary>
        /// The 20th day of March of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 3, 20);

        /// <summary>
        /// The 21st day of March of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 3, 21);

        /// <summary>
        /// The 22nd day of March of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 3, 22);

        /// <summary>
        /// The 23rd day of March of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 3, 23);

        /// <summary>
        /// The 24th day of March of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 3, 24);

        /// <summary>
        /// The 25th day of March of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 3, 25);

        /// <summary>
        /// The 26th day of March of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 3, 26);

        /// <summary>
        /// The 27th day of March of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 3, 27);

        /// <summary>
        /// The 28th day of March of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 3, 28);

        /// <summary>
        /// The 29th day of March of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 3, 29);

        /// <summary>
        /// The 30th day of March of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 3, 30);

        /// <summary>
        /// The 31st day of March of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 3, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for April
    /// </summary>
    public class April
    {
        /// <summary>
        /// The nth day of April of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 4, dayNumber);

        /// <summary>
        /// The 1st day of April of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 4, 1);

        /// <summary>
        /// The 2nd day of April of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 4, 2);

        /// <summary>
        /// The 3rd day of April of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 4, 3);

        /// <summary>
        /// The 4th day of April of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 4, 4);

        /// <summary>
        /// The 5th day of April of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 4, 5);

        /// <summary>
        /// The 6th day of April of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 4, 6);

        /// <summary>
        /// The 7th day of April of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 4, 7);

        /// <summary>
        /// The 8th day of April of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 4, 8);

        /// <summary>
        /// The 9th day of April of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 4, 9);

        /// <summary>
        /// The 10th day of April of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 4, 10);

        /// <summary>
        /// The 11th day of April of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 4, 11);

        /// <summary>
        /// The 12th day of April of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 4, 12);

        /// <summary>
        /// The 13th day of April of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 4, 13);

        /// <summary>
        /// The 14th day of April of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 4, 14);

        /// <summary>
        /// The 15th day of April of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 4, 15);

        /// <summary>
        /// The 16th day of April of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 4, 16);

        /// <summary>
        /// The 17th day of April of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 4, 17);

        /// <summary>
        /// The 18th day of April of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 4, 18);

        /// <summary>
        /// The 19th day of April of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 4, 19);

        /// <summary>
        /// The 20th day of April of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 4, 20);

        /// <summary>
        /// The 21st day of April of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 4, 21);

        /// <summary>
        /// The 22nd day of April of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 4, 22);

        /// <summary>
        /// The 23rd day of April of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 4, 23);

        /// <summary>
        /// The 24th day of April of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 4, 24);

        /// <summary>
        /// The 25th day of April of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 4, 25);

        /// <summary>
        /// The 26th day of April of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 4, 26);

        /// <summary>
        /// The 27th day of April of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 4, 27);

        /// <summary>
        /// The 28th day of April of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 4, 28);

        /// <summary>
        /// The 29th day of April of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 4, 29);

        /// <summary>
        /// The 30th day of April of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 4, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for May
    /// </summary>
    public class May
    {
        /// <summary>
        /// The nth day of May of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 5, dayNumber);

        /// <summary>
        /// The 1st day of May of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 5, 1);

        /// <summary>
        /// The 2nd day of May of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 5, 2);

        /// <summary>
        /// The 3rd day of May of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 5, 3);

        /// <summary>
        /// The 4th day of May of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 5, 4);

        /// <summary>
        /// The 5th day of May of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 5, 5);

        /// <summary>
        /// The 6th day of May of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 5, 6);

        /// <summary>
        /// The 7th day of May of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 5, 7);

        /// <summary>
        /// The 8th day of May of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 5, 8);

        /// <summary>
        /// The 9th day of May of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 5, 9);

        /// <summary>
        /// The 10th day of May of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 5, 10);

        /// <summary>
        /// The 11th day of May of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 5, 11);

        /// <summary>
        /// The 12th day of May of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 5, 12);

        /// <summary>
        /// The 13th day of May of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 5, 13);

        /// <summary>
        /// The 14th day of May of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 5, 14);

        /// <summary>
        /// The 15th day of May of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 5, 15);

        /// <summary>
        /// The 16th day of May of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 5, 16);

        /// <summary>
        /// The 17th day of May of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 5, 17);

        /// <summary>
        /// The 18th day of May of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 5, 18);

        /// <summary>
        /// The 19th day of May of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 5, 19);

        /// <summary>
        /// The 20th day of May of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 5, 20);

        /// <summary>
        /// The 21st day of May of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 5, 21);

        /// <summary>
        /// The 22nd day of May of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 5, 22);

        /// <summary>
        /// The 23rd day of May of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 5, 23);

        /// <summary>
        /// The 24th day of May of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 5, 24);

        /// <summary>
        /// The 25th day of May of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 5, 25);

        /// <summary>
        /// The 26th day of May of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 5, 26);

        /// <summary>
        /// The 27th day of May of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 5, 27);

        /// <summary>
        /// The 28th day of May of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 5, 28);

        /// <summary>
        /// The 29th day of May of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 5, 29);

        /// <summary>
        /// The 30th day of May of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 5, 30);

        /// <summary>
        /// The 31st day of May of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 5, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for June
    /// </summary>
    public class June
    {
        /// <summary>
        /// The nth day of June of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 6, dayNumber);

        /// <summary>
        /// The 1st day of June of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 6, 1);

        /// <summary>
        /// The 2nd day of June of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 6, 2);

        /// <summary>
        /// The 3rd day of June of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 6, 3);

        /// <summary>
        /// The 4th day of June of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 6, 4);

        /// <summary>
        /// The 5th day of June of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 6, 5);

        /// <summary>
        /// The 6th day of June of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 6, 6);

        /// <summary>
        /// The 7th day of June of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 6, 7);

        /// <summary>
        /// The 8th day of June of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 6, 8);

        /// <summary>
        /// The 9th day of June of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 6, 9);

        /// <summary>
        /// The 10th day of June of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 6, 10);

        /// <summary>
        /// The 11th day of June of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 6, 11);

        /// <summary>
        /// The 12th day of June of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 6, 12);

        /// <summary>
        /// The 13th day of June of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 6, 13);

        /// <summary>
        /// The 14th day of June of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 6, 14);

        /// <summary>
        /// The 15th day of June of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 6, 15);

        /// <summary>
        /// The 16th day of June of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 6, 16);

        /// <summary>
        /// The 17th day of June of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 6, 17);

        /// <summary>
        /// The 18th day of June of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 6, 18);

        /// <summary>
        /// The 19th day of June of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 6, 19);

        /// <summary>
        /// The 20th day of June of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 6, 20);

        /// <summary>
        /// The 21st day of June of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 6, 21);

        /// <summary>
        /// The 22nd day of June of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 6, 22);

        /// <summary>
        /// The 23rd day of June of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 6, 23);

        /// <summary>
        /// The 24th day of June of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 6, 24);

        /// <summary>
        /// The 25th day of June of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 6, 25);

        /// <summary>
        /// The 26th day of June of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 6, 26);

        /// <summary>
        /// The 27th day of June of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 6, 27);

        /// <summary>
        /// The 28th day of June of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 6, 28);

        /// <summary>
        /// The 29th day of June of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 6, 29);

        /// <summary>
        /// The 30th day of June of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 6, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for July
    /// </summary>
    public class July
    {
        /// <summary>
        /// The nth day of July of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 7, dayNumber);

        /// <summary>
        /// The 1st day of July of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 7, 1);

        /// <summary>
        /// The 2nd day of July of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 7, 2);

        /// <summary>
        /// The 3rd day of July of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 7, 3);

        /// <summary>
        /// The 4th day of July of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 7, 4);

        /// <summary>
        /// The 5th day of July of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 7, 5);

        /// <summary>
        /// The 6th day of July of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 7, 6);

        /// <summary>
        /// The 7th day of July of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 7, 7);

        /// <summary>
        /// The 8th day of July of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 7, 8);

        /// <summary>
        /// The 9th day of July of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 7, 9);

        /// <summary>
        /// The 10th day of July of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 7, 10);

        /// <summary>
        /// The 11th day of July of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 7, 11);

        /// <summary>
        /// The 12th day of July of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 7, 12);

        /// <summary>
        /// The 13th day of July of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 7, 13);

        /// <summary>
        /// The 14th day of July of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 7, 14);

        /// <summary>
        /// The 15th day of July of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 7, 15);

        /// <summary>
        /// The 16th day of July of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 7, 16);

        /// <summary>
        /// The 17th day of July of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 7, 17);

        /// <summary>
        /// The 18th day of July of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 7, 18);

        /// <summary>
        /// The 19th day of July of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 7, 19);

        /// <summary>
        /// The 20th day of July of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 7, 20);

        /// <summary>
        /// The 21st day of July of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 7, 21);

        /// <summary>
        /// The 22nd day of July of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 7, 22);

        /// <summary>
        /// The 23rd day of July of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 7, 23);

        /// <summary>
        /// The 24th day of July of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 7, 24);

        /// <summary>
        /// The 25th day of July of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 7, 25);

        /// <summary>
        /// The 26th day of July of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 7, 26);

        /// <summary>
        /// The 27th day of July of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 7, 27);

        /// <summary>
        /// The 28th day of July of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 7, 28);

        /// <summary>
        /// The 29th day of July of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 7, 29);

        /// <summary>
        /// The 30th day of July of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 7, 30);

        /// <summary>
        /// The 31st day of July of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 7, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for August
    /// </summary>
    public class August
    {
        /// <summary>
        /// The nth day of August of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 8, dayNumber);

        /// <summary>
        /// The 1st day of August of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 8, 1);

        /// <summary>
        /// The 2nd day of August of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 8, 2);

        /// <summary>
        /// The 3rd day of August of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 8, 3);

        /// <summary>
        /// The 4th day of August of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 8, 4);

        /// <summary>
        /// The 5th day of August of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 8, 5);

        /// <summary>
        /// The 6th day of August of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 8, 6);

        /// <summary>
        /// The 7th day of August of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 8, 7);

        /// <summary>
        /// The 8th day of August of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 8, 8);

        /// <summary>
        /// The 9th day of August of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 8, 9);

        /// <summary>
        /// The 10th day of August of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 8, 10);

        /// <summary>
        /// The 11th day of August of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 8, 11);

        /// <summary>
        /// The 12th day of August of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 8, 12);

        /// <summary>
        /// The 13th day of August of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 8, 13);

        /// <summary>
        /// The 14th day of August of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 8, 14);

        /// <summary>
        /// The 15th day of August of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 8, 15);

        /// <summary>
        /// The 16th day of August of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 8, 16);

        /// <summary>
        /// The 17th day of August of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 8, 17);

        /// <summary>
        /// The 18th day of August of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 8, 18);

        /// <summary>
        /// The 19th day of August of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 8, 19);

        /// <summary>
        /// The 20th day of August of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 8, 20);

        /// <summary>
        /// The 21st day of August of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 8, 21);

        /// <summary>
        /// The 22nd day of August of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 8, 22);

        /// <summary>
        /// The 23rd day of August of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 8, 23);

        /// <summary>
        /// The 24th day of August of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 8, 24);

        /// <summary>
        /// The 25th day of August of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 8, 25);

        /// <summary>
        /// The 26th day of August of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 8, 26);

        /// <summary>
        /// The 27th day of August of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 8, 27);

        /// <summary>
        /// The 28th day of August of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 8, 28);

        /// <summary>
        /// The 29th day of August of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 8, 29);

        /// <summary>
        /// The 30th day of August of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 8, 30);

        /// <summary>
        /// The 31st day of August of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 8, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for September
    /// </summary>
    public class September
    {
        /// <summary>
        /// The nth day of September of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 9, dayNumber);

        /// <summary>
        /// The 1st day of September of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 9, 1);

        /// <summary>
        /// The 2nd day of September of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 9, 2);

        /// <summary>
        /// The 3rd day of September of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 9, 3);

        /// <summary>
        /// The 4th day of September of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 9, 4);

        /// <summary>
        /// The 5th day of September of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 9, 5);

        /// <summary>
        /// The 6th day of September of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 9, 6);

        /// <summary>
        /// The 7th day of September of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 9, 7);

        /// <summary>
        /// The 8th day of September of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 9, 8);

        /// <summary>
        /// The 9th day of September of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 9, 9);

        /// <summary>
        /// The 10th day of September of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 9, 10);

        /// <summary>
        /// The 11th day of September of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 9, 11);

        /// <summary>
        /// The 12th day of September of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 9, 12);

        /// <summary>
        /// The 13th day of September of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 9, 13);

        /// <summary>
        /// The 14th day of September of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 9, 14);

        /// <summary>
        /// The 15th day of September of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 9, 15);

        /// <summary>
        /// The 16th day of September of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 9, 16);

        /// <summary>
        /// The 17th day of September of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 9, 17);

        /// <summary>
        /// The 18th day of September of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 9, 18);

        /// <summary>
        /// The 19th day of September of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 9, 19);

        /// <summary>
        /// The 20th day of September of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 9, 20);

        /// <summary>
        /// The 21st day of September of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 9, 21);

        /// <summary>
        /// The 22nd day of September of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 9, 22);

        /// <summary>
        /// The 23rd day of September of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 9, 23);

        /// <summary>
        /// The 24th day of September of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 9, 24);

        /// <summary>
        /// The 25th day of September of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 9, 25);

        /// <summary>
        /// The 26th day of September of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 9, 26);

        /// <summary>
        /// The 27th day of September of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 9, 27);

        /// <summary>
        /// The 28th day of September of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 9, 28);

        /// <summary>
        /// The 29th day of September of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 9, 29);

        /// <summary>
        /// The 30th day of September of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 9, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for October
    /// </summary>
    public class October
    {
        /// <summary>
        /// The nth day of October of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 10, dayNumber);

        /// <summary>
        /// The 1st day of October of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 10, 1);

        /// <summary>
        /// The 2nd day of October of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 10, 2);

        /// <summary>
        /// The 3rd day of October of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 10, 3);

        /// <summary>
        /// The 4th day of October of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 10, 4);

        /// <summary>
        /// The 5th day of October of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 10, 5);

        /// <summary>
        /// The 6th day of October of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 10, 6);

        /// <summary>
        /// The 7th day of October of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 10, 7);

        /// <summary>
        /// The 8th day of October of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 10, 8);

        /// <summary>
        /// The 9th day of October of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 10, 9);

        /// <summary>
        /// The 10th day of October of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 10, 10);

        /// <summary>
        /// The 11th day of October of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 10, 11);

        /// <summary>
        /// The 12th day of October of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 10, 12);

        /// <summary>
        /// The 13th day of October of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 10, 13);

        /// <summary>
        /// The 14th day of October of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 10, 14);

        /// <summary>
        /// The 15th day of October of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 10, 15);

        /// <summary>
        /// The 16th day of October of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 10, 16);

        /// <summary>
        /// The 17th day of October of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 10, 17);

        /// <summary>
        /// The 18th day of October of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 10, 18);

        /// <summary>
        /// The 19th day of October of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 10, 19);

        /// <summary>
        /// The 20th day of October of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 10, 20);

        /// <summary>
        /// The 21st day of October of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 10, 21);

        /// <summary>
        /// The 22nd day of October of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 10, 22);

        /// <summary>
        /// The 23rd day of October of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 10, 23);

        /// <summary>
        /// The 24th day of October of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 10, 24);

        /// <summary>
        /// The 25th day of October of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 10, 25);

        /// <summary>
        /// The 26th day of October of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 10, 26);

        /// <summary>
        /// The 27th day of October of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 10, 27);

        /// <summary>
        /// The 28th day of October of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 10, 28);

        /// <summary>
        /// The 29th day of October of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 10, 29);

        /// <summary>
        /// The 30th day of October of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 10, 30);

        /// <summary>
        /// The 31st day of October of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 10, 31);
    }
    /// <summary>
    /// Provides fluent date accessors for November
    /// </summary>
    public class November
    {
        /// <summary>
        /// The nth day of November of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 11, dayNumber);

        /// <summary>
        /// The 1st day of November of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 11, 1);

        /// <summary>
        /// The 2nd day of November of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 11, 2);

        /// <summary>
        /// The 3rd day of November of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 11, 3);

        /// <summary>
        /// The 4th day of November of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 11, 4);

        /// <summary>
        /// The 5th day of November of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 11, 5);

        /// <summary>
        /// The 6th day of November of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 11, 6);

        /// <summary>
        /// The 7th day of November of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 11, 7);

        /// <summary>
        /// The 8th day of November of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 11, 8);

        /// <summary>
        /// The 9th day of November of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 11, 9);

        /// <summary>
        /// The 10th day of November of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 11, 10);

        /// <summary>
        /// The 11th day of November of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 11, 11);

        /// <summary>
        /// The 12th day of November of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 11, 12);

        /// <summary>
        /// The 13th day of November of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 11, 13);

        /// <summary>
        /// The 14th day of November of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 11, 14);

        /// <summary>
        /// The 15th day of November of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 11, 15);

        /// <summary>
        /// The 16th day of November of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 11, 16);

        /// <summary>
        /// The 17th day of November of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 11, 17);

        /// <summary>
        /// The 18th day of November of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 11, 18);

        /// <summary>
        /// The 19th day of November of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 11, 19);

        /// <summary>
        /// The 20th day of November of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 11, 20);

        /// <summary>
        /// The 21st day of November of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 11, 21);

        /// <summary>
        /// The 22nd day of November of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 11, 22);

        /// <summary>
        /// The 23rd day of November of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 11, 23);

        /// <summary>
        /// The 24th day of November of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 11, 24);

        /// <summary>
        /// The 25th day of November of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 11, 25);

        /// <summary>
        /// The 26th day of November of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 11, 26);

        /// <summary>
        /// The 27th day of November of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 11, 27);

        /// <summary>
        /// The 28th day of November of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 11, 28);

        /// <summary>
        /// The 29th day of November of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 11, 29);

        /// <summary>
        /// The 30th day of November of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 11, 30);
    }
    /// <summary>
    /// Provides fluent date accessors for December
    /// </summary>
    public class December
    {
        /// <summary>
        /// The nth day of December of the current year
        /// </summary>
        public static DateOnly The(int dayNumber)
            => new(DateTime.Now.Year, 12, dayNumber);

        /// <summary>
        /// The 1st day of December of the current year
        /// </summary>
        public static DateOnly The1st
            => new(DateTime.Now.Year, 12, 1);

        /// <summary>
        /// The 2nd day of December of the current year
        /// </summary>
        public static DateOnly The2nd
            => new(DateTime.Now.Year, 12, 2);

        /// <summary>
        /// The 3rd day of December of the current year
        /// </summary>
        public static DateOnly The3rd
            => new(DateTime.Now.Year, 12, 3);

        /// <summary>
        /// The 4th day of December of the current year
        /// </summary>
        public static DateOnly The4th
            => new(DateTime.Now.Year, 12, 4);

        /// <summary>
        /// The 5th day of December of the current year
        /// </summary>
        public static DateOnly The5th
            => new(DateTime.Now.Year, 12, 5);

        /// <summary>
        /// The 6th day of December of the current year
        /// </summary>
        public static DateOnly The6th
            => new(DateTime.Now.Year, 12, 6);

        /// <summary>
        /// The 7th day of December of the current year
        /// </summary>
        public static DateOnly The7th
            => new(DateTime.Now.Year, 12, 7);

        /// <summary>
        /// The 8th day of December of the current year
        /// </summary>
        public static DateOnly The8th
            => new(DateTime.Now.Year, 12, 8);

        /// <summary>
        /// The 9th day of December of the current year
        /// </summary>
        public static DateOnly The9th
            => new(DateTime.Now.Year, 12, 9);

        /// <summary>
        /// The 10th day of December of the current year
        /// </summary>
        public static DateOnly The10th
            => new(DateTime.Now.Year, 12, 10);

        /// <summary>
        /// The 11th day of December of the current year
        /// </summary>
        public static DateOnly The11th
            => new(DateTime.Now.Year, 12, 11);

        /// <summary>
        /// The 12th day of December of the current year
        /// </summary>
        public static DateOnly The12th
            => new(DateTime.Now.Year, 12, 12);

        /// <summary>
        /// The 13th day of December of the current year
        /// </summary>
        public static DateOnly The13th
            => new(DateTime.Now.Year, 12, 13);

        /// <summary>
        /// The 14th day of December of the current year
        /// </summary>
        public static DateOnly The14th
            => new(DateTime.Now.Year, 12, 14);

        /// <summary>
        /// The 15th day of December of the current year
        /// </summary>
        public static DateOnly The15th
            => new(DateTime.Now.Year, 12, 15);

        /// <summary>
        /// The 16th day of December of the current year
        /// </summary>
        public static DateOnly The16th
            => new(DateTime.Now.Year, 12, 16);

        /// <summary>
        /// The 17th day of December of the current year
        /// </summary>
        public static DateOnly The17th
            => new(DateTime.Now.Year, 12, 17);

        /// <summary>
        /// The 18th day of December of the current year
        /// </summary>
        public static DateOnly The18th
            => new(DateTime.Now.Year, 12, 18);

        /// <summary>
        /// The 19th day of December of the current year
        /// </summary>
        public static DateOnly The19th
            => new(DateTime.Now.Year, 12, 19);

        /// <summary>
        /// The 20th day of December of the current year
        /// </summary>
        public static DateOnly The20th
            => new(DateTime.Now.Year, 12, 20);

        /// <summary>
        /// The 21st day of December of the current year
        /// </summary>
        public static DateOnly The21st
            => new(DateTime.Now.Year, 12, 21);

        /// <summary>
        /// The 22nd day of December of the current year
        /// </summary>
        public static DateOnly The22nd
            => new(DateTime.Now.Year, 12, 22);

        /// <summary>
        /// The 23rd day of December of the current year
        /// </summary>
        public static DateOnly The23rd
            => new(DateTime.Now.Year, 12, 23);

        /// <summary>
        /// The 24th day of December of the current year
        /// </summary>
        public static DateOnly The24th
            => new(DateTime.Now.Year, 12, 24);

        /// <summary>
        /// The 25th day of December of the current year
        /// </summary>
        public static DateOnly The25th
            => new(DateTime.Now.Year, 12, 25);

        /// <summary>
        /// The 26th day of December of the current year
        /// </summary>
        public static DateOnly The26th
            => new(DateTime.Now.Year, 12, 26);

        /// <summary>
        /// The 27th day of December of the current year
        /// </summary>
        public static DateOnly The27th
            => new(DateTime.Now.Year, 12, 27);

        /// <summary>
        /// The 28th day of December of the current year
        /// </summary>
        public static DateOnly The28th
            => new(DateTime.Now.Year, 12, 28);

        /// <summary>
        /// The 29th day of December of the current year
        /// </summary>
        public static DateOnly The29th
            => new(DateTime.Now.Year, 12, 29);

        /// <summary>
        /// The 30th day of December of the current year
        /// </summary>
        public static DateOnly The30th
            => new(DateTime.Now.Year, 12, 30);

        /// <summary>
        /// The 31st day of December of the current year
        /// </summary>
        public static DateOnly The31st
            => new(DateTime.Now.Year, 12, 31);
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\FluentDate\PrepositionsExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// <see cref="DateTime"/> extensions related to spatial or temporal relations
/// </summary>
public static class PrepositionsExtensions
{
    /// <summary>
    /// Returns a new <see cref="DateTime"/> with the specified hour and, optionally
    /// provided minutes, seconds, and milliseconds.
    /// </summary>
    public static DateTime At(this DateTime date, int hour, int min = 0, int second = 0, int millisecond = 0) =>
        new(date.Year, date.Month, date.Day, hour, min, second, millisecond);

    /// <summary>
    /// Returns a new instance of DateTime based on the provided date where the time is set to midnight
    /// </summary>
    public static DateTime AtMidnight(this DateTime date) =>
        date.At(0);

    /// <summary>
    /// Returns a new instance of DateTime based on the provided date where the time is set to noon
    /// </summary>
    public static DateTime AtNoon(this DateTime date) =>
        date.At(12);

    /// <summary>
    /// Returns a new instance of DateTime based on the provided date where the year is set to the provided year
    /// </summary>
    public static DateTime In(this DateTime date, int year) =>
        new(year, date.Month, date.Day, date.Hour, date.Minute, date.Second, date.Millisecond);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Inflections\Vocabularies.cs ---


using System;
using System.Threading;

namespace Humanizer;

/// <summary>
/// Container for registered Vocabularies.  At present, only a single vocabulary is supported: Default.
/// </summary>
public static class Vocabularies
{
    static readonly Lazy<Vocabulary> Instance;

    static Vocabularies() =>
        Instance = new(BuildDefault, LazyThreadSafetyMode.PublicationOnly);

    /// <summary>
    /// The default vocabulary used for singular/plural irregularities.
    /// Rules can be added to this vocabulary and will be picked up by called to Singularize() and Pluralize().
    /// At this time, multiple vocabularies and removing existing rules are not supported.
    /// </summary>
    public static Vocabulary Default => Instance.Value;

    static Vocabulary BuildDefault()
    {
        var _default = new Vocabulary();

        _default.AddPlural("$", "s");
        _default.AddPlural("s$", "s");
        _default.AddPlural("(ax|test)is$", "$1es");
        _default.AddPlural("(octop|vir|alumn|fung|cact|foc|hippopotam|radi|stimul|syllab|nucle)us$", "$1i");
        _default.AddPlural("(alias|bias|iris|status|campus|apparatus|virus|walrus|trellis)$", "$1es");
        _default.AddPlural("(buffal|tomat|volcan|ech|embarg|her|mosquit|potat|torped|vet)o$", "$1oes");
        _default.AddPlural("([dti])um$", "$1a");
        _default.AddPlural("sis$", "ses");
        _default.AddPlural("(?:([^f])fe|([lr])f)$", "$1$2ves");
        _default.AddPlural("(hive)$", "$1s");
        _default.AddPlural("([^aeiouy]|qu)y$", "$1ies");
        _default.AddPlural("(x|ch|ss|sh)$", "$1es");
        _default.AddPlural("(matr|vert|ind|d)(ix|ex)$", "$1ices");
        _default.AddPlural("(^[m|l])ouse$", "$1ice");
        _default.AddPlural("^(ox)$", "$1en");
        _default.AddPlural("(quiz)$", "$1zes");
        _default.AddPlural("(buz|blit|walt)z$", "$1zes");
        _default.AddPlural("(hoo|lea|loa|thie)f$", "$1ves");
        _default.AddPlural("(alumn|alg|larv|vertebr)a$", "$1ae");
        _default.AddPlural("(criteri|phenomen)on$", "$1a");

        _default.AddSingular("s$", "");
        _default.AddSingular("(n)ews$", "$1ews");
        _default.AddSingular("([dti])a$", "$1um");
        _default.AddSingular("(analy|ba|diagno|parenthe|progno|synop|the|ellip|empha|neuro|oa|paraly)ses$", "$1sis");
        _default.AddSingular("([^f])ves$", "$1fe");
        _default.AddSingular("(hive)s$", "$1");
        _default.AddSingular("(tive)s$", "$1");
        _default.AddSingular("([lr]|hoo|lea|loa|thie)ves$", "$1f");
        _default.AddSingular("(^zomb)?([^aeiouy]|qu)ies$", "$2y");
        _default.AddSingular("(s)eries$", "$1eries");
        _default.AddSingular("(m)ovies$", "$1ovie");
        _default.AddSingular("(x|ch|ss|sh)es$", "$1");
        _default.AddSingular("(^[m|l])ice$", "$1ouse");
        _default.AddSingular("(?<!^[a-z])(o)es$", "$1");
        _default.AddSingular("(shoe)s$", "$1");
        _default.AddSingular("(cris|ax|test)es$", "$1is");
        _default.AddSingular("(octop|vir|alumn|fung|cact|foc|hippopotam|radi|stimul|syllab|nucle)i$", "$1us");
        _default.AddSingular("(alias|bias|iris|status|campus|apparatus|virus|walrus|trellis)es$", "$1");
        _default.AddSingular("^(ox)en", "$1");
        _default.AddSingular("(matr|d)ices$", "$1ix");
        _default.AddSingular("(vert|ind)ices$", "$1ex");
        _default.AddSingular("(quiz)zes$", "$1");
        _default.AddSingular("(buz|blit|walt)zes$", "$1z");
        _default.AddSingular("(alumn|alg|larv|vertebr)ae$", "$1a");
        _default.AddSingular("(criteri|phenomen)a$", "$1on");
        _default.AddSingular("([b|r|c]ook|room|smooth)ies$", "$1ie");

        _default.AddIrregular("person", "people");
        _default.AddIrregular("man", "men");
        _default.AddIrregular("human", "humans");
        _default.AddIrregular("child", "children");
        _default.AddIrregular("sex", "sexes");
        _default.AddIrregular("glove", "gloves");
        _default.AddIrregular("move", "moves");
        _default.AddIrregular("goose", "geese");
        _default.AddIrregular("wave", "waves");
        _default.AddIrregular("foot", "feet");
        _default.AddIrregular("tooth", "teeth");
        _default.AddIrregular("curriculum", "curricula");
        _default.AddIrregular("database", "databases");
        _default.AddIrregular("zombie", "zombies");
        _default.AddIrregular("personnel", "personnel");
        _default.AddIrregular("cache", "caches");
        _default.AddIrregular("ex", "exes", matchEnding: false);
        _default.AddIrregular("is", "are", matchEnding: false);
        _default.AddIrregular("was", "were", matchEnding: false);
        _default.AddIrregular("that", "those", matchEnding: false);
        _default.AddIrregular("this", "these", matchEnding: false);
        _default.AddIrregular("bus", "buses", matchEnding: false);
        _default.AddIrregular("die", "dice", matchEnding: false);
        _default.AddIrregular("tie", "ties", matchEnding: false);
        _default.AddIrregular("lens", "lenses");
        _default.AddIrregular("clove", "cloves");
        _default.AddIrregular("valve", "valves");
        _default.AddIrregular("explosive", "explosives");

        _default.AddUncountable("staff");
        _default.AddUncountable("training");
        _default.AddUncountable("equipment");
        _default.AddUncountable("information");
        _default.AddUncountable("corn");
        _default.AddUncountable("milk");
        _default.AddUncountable("rice");
        _default.AddUncountable("money");
        _default.AddUncountable("species");
        _default.AddUncountable("series");
        _default.AddUncountable("fish");
        _default.AddUncountable("sheep");
        _default.AddUncountable("deer");
        _default.AddUncountable("aircraft");
        _default.AddUncountable("oz");
        _default.AddUncountable("tsp");
        _default.AddUncountable("tbsp");
        _default.AddUncountable("ml");
        _default.AddUncountable("l");
        _default.AddUncountable("water");
        _default.AddUncountable("waters");
        _default.AddUncountable("semen");
        _default.AddUncountable("sperm");
        _default.AddUncountable("bison");
        _default.AddUncountable("grass");
        _default.AddUncountable("hair");
        _default.AddUncountable("mud");
        _default.AddUncountable("elk");
        _default.AddUncountable("luggage");
        _default.AddUncountable("moose");
        _default.AddUncountable("offspring");
        _default.AddUncountable("salmon");
        _default.AddUncountable("shrimp");
        _default.AddUncountable("someone");
        _default.AddUncountable("swine");
        _default.AddUncountable("trout");
        _default.AddUncountable("tuna");
        _default.AddUncountable("corps");
        _default.AddUncountable("scissors");
        _default.AddUncountable("means");
        _default.AddUncountable("mail");
        _default.AddUncountable("pliers");
        _default.AddUncountable("sheers");
        _default.AddUncountable("clothes");
        _default.AddUncountable("apparatus");
        _default.AddUncountable("chassis");
        _default.AddUncountable("debris");

        //Fix 1132
        _default.AddUncountable("metadata");

        return _default;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Inflections\Vocabulary.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

/// <summary>
/// A container for exceptions to simple pluralization/singularization rules.
/// Vocabularies.Default contains an extensive list of rules for US English.
/// At this time, multiple vocabularies and removing existing rules are not supported.
/// </summary>
public class Vocabulary
{
    internal Vocabulary()
    {
    }

    readonly List<Rule> plurals = [];
    readonly List<Rule> singulars = [];
    readonly HashSet<string> uncountables = new(StringComparer.CurrentCultureIgnoreCase);
    readonly Regex letterS = new("^([sS])[sS]*$");

    /// <summary>
    /// Adds a word to the vocabulary which cannot easily be pluralized/singularized by RegEx, e.g. "person" and "people".
    /// </summary>
    /// <param name="singular">The singular form of the irregular word, e.g. "person".</param>
    /// <param name="plural">The plural form of the irregular word, e.g. "people".</param>
    /// <param name="matchEnding">True to match these words on their own as well as at the end of longer words. False, otherwise.</param>
    public void AddIrregular(string singular, string plural, bool matchEnding = true)
    {
        if (matchEnding)
        {
            var singularSubstring = singular.Substring(1);
            var pluralSubString = plural.Substring(1);
            AddPlural($"({singular[0]}){singularSubstring}$", $"$1{pluralSubString}");
            AddSingular($"({plural[0]}){pluralSubString}$", $"$1{singularSubstring}");
        }
        else
        {
            AddPlural($"^{singular}$", plural);
            AddSingular($"^{plural}$", singular);
        }
    }

    /// <summary>
    /// Adds an uncountable word to the vocabulary, e.g. "fish".  Will be ignored when plurality is changed.
    /// </summary>
    /// <param name="word">Word to be added to the list of uncountables.</param>
    public void AddUncountable(string word) =>
        uncountables.Add(word);

    /// <summary>
    /// Adds a rule to the vocabulary that does not follow trivial rules for pluralization, e.g. "bus" -> "buses"
    /// </summary>
    /// <param name="rule">RegEx to be matched, case insensitive, e.g. "(bus)es$"</param>
    /// <param name="replacement">RegEx replacement  e.g. "$1"</param>
    public void AddPlural(string rule, string replacement) =>
        plurals.Add(new(rule, replacement));

    /// <summary>
    /// Adds a rule to the vocabulary that does not follow trivial rules for singularization, e.g. "vertices/indices -> "vertex/index"
    /// </summary>
    /// <param name="rule">RegEx to be matched, case insensitive, e.g. ""(vert|ind)ices$""</param>
    /// <param name="replacement">RegEx replacement  e.g. "$1ex"</param>
    public void AddSingular(string rule, string replacement) =>
        singulars.Add(new(rule, replacement));

    /// <summary>
    /// Pluralizes the provided input considering irregular words
    /// </summary>
    /// <param name="word">Word to be pluralized</param>
    /// <param name="inputIsKnownToBeSingular">Normally you call Pluralize on singular words; but if you're unsure call it with false</param>
    [return: NotNullIfNotNull(nameof(word))]
    public string? Pluralize(string? word, bool inputIsKnownToBeSingular = true)
    {
        if (word == null)
        {
            return null;
        }

        var s = LetterS(word);
        if (s != null)
        {
            return s + "s";
        }

        var result = ApplyRules(plurals, word, false);

        if (inputIsKnownToBeSingular)
        {
            return result ?? word;
        }

        var asSingular = ApplyRules(singulars, word, false);
        var asSingularAsPlural = ApplyRules(plurals, asSingular, false);
        if (asSingular != null &&
            asSingular != word &&
            asSingular + "s" != word &&
            asSingularAsPlural == word &&
            result != word)
        {
            return word;
        }

        return result!;
    }

    /// <summary>
    /// Singularizes the provided input considering irregular words
    /// </summary>
    /// <param name="word">Word to be singularized</param>
    /// <param name="inputIsKnownToBePlural">Normally you call Singularize on plural words; but if you're unsure call it with false</param>
    /// <param name="skipSimpleWords">Skip singularizing single words that have an 's' on the end</param>
    [return: NotNullIfNotNull(nameof(word))]
    public string? Singularize(string? word, bool inputIsKnownToBePlural = true, bool skipSimpleWords = false)
    {
        if (word == null)
        {
            return null;
        }
        var s = LetterS(word);
        if (s != null)
        {
            return s;
        }

        var result = ApplyRules(singulars, word, skipSimpleWords);

        if (inputIsKnownToBePlural)
        {
            return result ?? word;
        }

        // the Plurality is unknown so we should check all possibilities
        var asPlural = ApplyRules(plurals, word, false);
        if (asPlural == word ||
            word + "s" == asPlural)
        {
            return result ?? word;
        }

        var asPluralAsSingular = ApplyRules(singulars, asPlural, false);
        if (asPluralAsSingular != word ||
            result == word)
        {
            return result ?? word;
        }

        return word;
    }

    string? ApplyRules(IList<Rule> rules, string? word, bool skipFirstRule)
    {
        if (word == null)
        {
            return null;
        }

        if (word.Length < 1)
        {
            return word;
        }

        if (IsUncountable(word))
        {
            return word;
        }

        var result = word;
        var end = skipFirstRule ? 1 : 0;
        for (var i = rules.Count - 1; i >= end; i--)
        {
            if ((result = rules[i].Apply(word)) != null)
            {
                break;
            }
        }

        if (result == null)
        {
            return null;
        }

        return MatchUpperCase(word, result);
    }

    bool IsUncountable(string word) =>
        uncountables.Contains(word);

    static string MatchUpperCase(string word, string replacement) =>
        char.IsUpper(word[0]) &&
        char.IsLower(replacement[0]) ? char.ToUpper(replacement[0]) + replacement.Substring(1) : replacement;

    /// <summary>
    /// If the word is the letter s, singular or plural, return the letter s singular
    /// </summary>
    string? LetterS(string word)
    {
        var s = letterS.Match(word);
        return s.Groups.Count > 1 ? s.Groups[1].Value : null;
    }

    class Rule(string pattern, string replacement)
    {
        readonly Regex regex = new(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);

        public string? Apply(string word)
        {
            if (!regex.IsMatch(word))
            {
                return null;
            }

            return regex.Replace(word, replacement);
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\CollectionFormatters\DefaultCollectionFormatter.cs ---


using System;
using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

class DefaultCollectionFormatter : ICollectionFormatter
{
    protected string DefaultSeparator = "";

    public DefaultCollectionFormatter(string defaultSeparator) =>
        DefaultSeparator = defaultSeparator;

    public virtual string Humanize<T>(IEnumerable<T> collection) =>
        Humanize(collection, o => o?.ToString(), DefaultSeparator);

    public virtual string Humanize<T>(IEnumerable<T> collection, Func<T, string> objectFormatter) =>
        Humanize(collection, objectFormatter, DefaultSeparator);

    public string Humanize<T>(IEnumerable<T> collection, Func<T, object?> objectFormatter) =>
        Humanize(collection, objectFormatter, DefaultSeparator);

    public virtual string Humanize<T>(IEnumerable<T> collection, string separator) =>
        Humanize(collection, o => o?.ToString(), separator);

    public virtual string Humanize<T>(IEnumerable<T> collection, Func<T, string?> objectFormatter, string separator)
    {
        if (collection == null)
        {
            throw new ArgumentNullException(nameof(collection));
        }

        if (objectFormatter == null)
        {
            throw new ArgumentNullException(nameof(objectFormatter));
        }

        return HumanizeDisplayStrings(
            collection.Select(objectFormatter),
            separator);
    }

    public string Humanize<T>(IEnumerable<T> collection, Func<T, object?> objectFormatter, string separator)
    {
        if (collection == null)
        {
            throw new ArgumentNullException(nameof(collection));
        }

        if (objectFormatter == null)
        {
            throw new ArgumentNullException(nameof(objectFormatter));
        }

        return HumanizeDisplayStrings(
            collection
                .Select(objectFormatter)
                .Select(o => o?.ToString()),
            separator);
    }

    string HumanizeDisplayStrings(IEnumerable<string?> strings, string separator)
    {
        var itemsArray = strings
            .Select(item => item == null ? string.Empty : item.Trim())
            .Where(item => !string.IsNullOrWhiteSpace(item))
            .ToArray();

        var count = itemsArray.Length;

        if (count == 0)
        {
            return "";
        }

        if (count == 1)
        {
            return itemsArray[0];
        }

        return string.Format(GetConjunctionFormatString(count),
            string.Join(", ", itemsArray, 0, itemsArray.Length - 1),
            separator,
            itemsArray[^1]);
    }

    protected virtual string GetConjunctionFormatString(int itemCount) => "{0} {1} {2}";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\CollectionFormatters\ICollectionFormatter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

/// <summary>
/// An interface you should implement to localize Humanize for collections
/// </summary>
public interface ICollectionFormatter
{
    /// <summary>
    /// Formats the collection for display, calling ToString() on each object.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection, Func<T, string> objectFormatter);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection, Func<T, object?> objectFormatter);

    /// <summary>
    /// Formats the collection for display, calling ToString() on each object
    /// and using <paramref name="separator"/> before the final item.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection, string separator);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
    /// and using <paramref name="separator"/> before the final item.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection, Func<T, string?> objectFormatter, string separator);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="objectFormatter"/> on each element.
    /// and using <paramref name="separator"/> before the final item.
    /// </summary>
    string Humanize<T>(IEnumerable<T> collection, Func<T, object?> objectFormatter, string separator);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\CollectionFormatters\OxfordStyleCollectionFormatter.cs ---


namespace Humanizer;

class OxfordStyleCollectionFormatter() :
    DefaultCollectionFormatter("and")
{
    protected override string GetConjunctionFormatString(int itemCount) => itemCount > 2 ? "{0}, {1} {2}" : "{0} {1} {2}";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\DefaultDateOnlyToOrdinalWordConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class DefaultDateOnlyToOrdinalWordConverter : IDateOnlyToOrdinalWordConverter
{
    public virtual string Convert(DateOnly date) =>
        date.Day.Ordinalize() + date.ToString(" MMMM yyyy");

    public virtual string Convert(DateOnly date, GrammaticalCase grammaticalCase) =>
        Convert(date);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\DefaultDateToOrdinalWordConverter.cs ---


using System;

namespace Humanizer;

class DefaultDateToOrdinalWordConverter : IDateToOrdinalWordConverter
{
    public virtual string Convert(DateTime date) =>
        date.Day.Ordinalize() + date.ToString(" MMMM yyyy");

    public virtual string Convert(DateTime date, GrammaticalCase grammaticalCase) =>
        Convert(date);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\EsDateOnlyToOrdinalWordsConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class EsDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter
{
    public override string Convert(DateOnly date)
    {
        var equivalentDateTime = date.ToDateTime(TimeOnly.MinValue);
        return Configurator.DateToOrdinalWordsConverter.Convert(equivalentDateTime);
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\EsDateToOrdinalWordsConverter.cs ---


using System;

namespace Humanizer;

class EsDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter
{
    public override string Convert(DateTime date) =>
        date.ToString("d 'de' MMMM 'de' yyyy");
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\FrDateOnlyToOrdinalWordsConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class FrDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter
{
    public override string Convert(DateOnly date)
    {
        var day = date.Day > 1 ? date.Day.ToString() : date.Day.Ordinalize();
        return day + date.ToString(" MMMM yyyy");
    }
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\FrDateToOrdinalWordsConverter.cs ---


using System;

namespace Humanizer;

class FrDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter
{
    public override string Convert(DateTime date)
    {
        var day = date.Day > 1 ? date.Day.ToString() : date.Day.Ordinalize();
        return day + date.ToString(" MMMM yyyy");
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\IDateOnlyToOrdinalWordConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// The interface used to localise the ToOrdinalWords method.
/// </summary>
public interface IDateOnlyToOrdinalWordConverter
{
    /// <summary>
    /// Converts the date to Ordinal Words
    /// </summary>
    string Convert(DateOnly date);

    /// <summary>
    /// Converts the date to Ordinal Words using the provided grammatical case
    /// </summary>
    string Convert(DateOnly date, GrammaticalCase grammaticalCase);
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\IDateToOrdinalWordConverter.cs ---


using System;

namespace Humanizer;

/// <summary>
/// The interface used to localise the ToOrdinalWords method.
/// </summary>
public interface IDateToOrdinalWordConverter
{
    /// <summary>
    /// Converts the date to Ordinal Words
    /// </summary>
    string Convert(DateTime date);

    /// <summary>
    /// Converts the date to Ordinal Words using the provided grammatical case
    /// </summary>
    string Convert(DateTime date, GrammaticalCase grammaticalCase);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\LtDateOnlyToOrdinalWordsConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class LtDateOnlyToOrdinalWordsConverter : IDateOnlyToOrdinalWordConverter
{
    public string Convert(DateOnly date) =>
        date.ToString("yyyy 'm.' MMMM d 'd.'");

    public string Convert(DateOnly date, GrammaticalCase grammaticalCase) =>
        Convert(date);
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\LtDateToOrdinalWordsConverter.cs ---


using System;

namespace Humanizer;

class LtDateToOrdinalWordsConverter : IDateToOrdinalWordConverter
{
    public string Convert(DateTime date) =>
        date.ToString("yyyy 'm.' MMMM d 'd.'");

    public string Convert(DateTime date, GrammaticalCase grammaticalCase) =>
        Convert(date);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\UsDateOnlyToOrdinalWordsConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class UsDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter
{
    public override string Convert(DateOnly date) =>
        date.ToString("MMMM ") + date.Day.Ordinalize() + date.ToString(", yyyy");
}
#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DateToOrdinalWords\UsDateToOrdinalWordsConverter.cs ---


using System;

namespace Humanizer;

class UsDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter
{
    public override string Convert(DateTime date) =>
        date.ToString("MMMM ") + date.Day.Ordinalize() + date.ToString(", yyyy");
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\ArabicFormatter.cs ---


namespace Humanizer;

class ArabicFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string DualPostfix = "_Dual";
    const string PluralPostfix = "_Plural";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        //In Arabic pluralization 2 entities gets a different word.
        if (number == 2)
        {
            return resourceKey + DualPostfix;
        }

        //In Arabic pluralization entities where the count is between 3 and 10 gets a different word.
        if (number is >= 3 and <= 10)
        {
            return resourceKey + PluralPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\BulgarianFormatter.cs ---


namespace Humanizer;

class BulgarianFormatter(CultureInfo culture)
    : DefaultFormatter(culture)
{
    protected override string NumberToWords(TimeUnit unit, int number, CultureInfo culture) =>
        number.ToWords(GetUnitGender(unit), culture);

    static GrammaticalGender GetUnitGender(TimeUnit unit) =>
        unit switch
        {
            TimeUnit.Hour or TimeUnit.Day or TimeUnit.Month => GrammaticalGender.Masculine,
            _ => GrammaticalGender.Feminine
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\CroatianFormatter.cs ---


namespace Humanizer;

class CroatianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string PaucalPostfix = "_Paucal";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        var mod10 = number % 10;
        if (mod10 is > 1 and < 5 && number != 12 && number != 13 && number != 14)
        {
            return resourceKey + PaucalPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\CzechSlovakPolishFormatter.cs ---


namespace Humanizer;

class CzechSlovakPolishFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string PaucalPostfix = "_Paucal";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (number is > 1 and < 5)
        {
            return resourceKey + PaucalPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\DefaultFormatter.cs ---


namespace Humanizer;

/// <summary>
/// Default implementation of IFormatter interface.
/// </summary>
public class DefaultFormatter(CultureInfo culture) : IFormatter
{
    protected CultureInfo Culture { get; } = culture;

    public DefaultFormatter(string localeCode)
        : this(new CultureInfo(localeCode))
    {
    }

    public virtual string DateHumanize_Now() =>
        GetResourceForDate(TimeUnit.Millisecond, Tense.Past, 0);

    public virtual string DateHumanize_Never() =>
        Format(ResourceKeys.DateHumanize.Never);

    /// <summary>
    /// Returns the string representation of the provided DateTime
    /// </summary>
    public virtual string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit) =>
        GetResourceForDate(timeUnit, timeUnitTense, unit);

    /// <summary>
    /// 0 seconds
    /// </summary>
    /// <returns>Returns 0 seconds as the string representation of Zero TimeSpan</returns>
    public virtual string TimeSpanHumanize_Zero() =>
        GetResourceForTimeSpan(TimeUnit.Millisecond, 0, true);

    /// <summary>
    /// Returns the string representation of the provided TimeSpan
    /// </summary>
    /// <param name="timeUnit">A time unit to represent.</param>
    /// <exception cref="System.ArgumentOutOfRangeException">Is thrown when timeUnit is larger than TimeUnit.Week</exception>
    public virtual string TimeSpanHumanize(TimeUnit timeUnit, int unit, bool toWords = false) =>
        GetResourceForTimeSpan(timeUnit, unit, toWords);

    /// <inheritdoc/>
    public virtual string TimeSpanHumanize_Age()
    {
        if (Resources.TryGetResource("TimeSpanHumanize_Age", Culture, out var ageFormat))
            return ageFormat;
        return "{0}";
    }

    /// <inheritdoc cref="IFormatter.DataUnitHumanize(DataUnit, double, bool)"/>
    public virtual string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol = true)
    {
        var resourceKey = toSymbol ? $"DataUnit_{dataUnit}Symbol" : $"DataUnit_{dataUnit}";
        var resourceValue = Format(resourceKey);

        if (!toSymbol && count > 1)
            resourceValue += 's';

        return resourceValue;
    }

    /// <inheritdoc />
    public virtual string TimeUnitHumanize(TimeUnit timeUnit)
    {
        var resourceKey = ResourceKeys.TimeUnitSymbol.GetResourceKey(timeUnit);
        return Format(resourceKey);
    }

    string GetResourceForDate(TimeUnit unit, Tense timeUnitTense, int count)
    {
        var resourceKey = ResourceKeys.DateHumanize.GetResourceKey(unit, timeUnitTense: timeUnitTense, count: count);
        return count == 1 ? Format(resourceKey) : Format(unit, resourceKey, count);
    }

    string GetResourceForTimeSpan(TimeUnit unit, int count, bool toWords = false)
    {
        var resourceKey = ResourceKeys.TimeSpanHumanize.GetResourceKey(unit, count, toWords);
        return count == 1 ? Format(resourceKey + (toWords ? "_Words" : "")) : Format(unit, resourceKey, count, toWords);
    }

    /// <summary>
    /// Formats the specified resource key.
    /// </summary>
    /// <param name="resourceKey">The resource key.</param>
    /// <exception cref="ArgumentException">If the resource not exists on the specified culture.</exception>
    protected virtual string Format(string resourceKey)
    {
        var resolvedKey = GetResourceKey(resourceKey);
        return Resources.GetResource(resolvedKey, Culture);
    }

    /// <summary>
    /// Formats the specified resource key.
    /// </summary>
    /// <param name="unit"></param>
    /// <param name="resourceKey">The resource key.</param>
    /// <param name="number">The number.</param>
    /// <param name="toWords"></param>
    /// <exception cref="ArgumentException">If the resource not exists on the specified culture.</exception>
    protected virtual string Format(TimeUnit unit, string resourceKey, int number, bool toWords = false)
    {
        var resolvedKey = GetResourceKey(resourceKey, number);
        var resourceString = Resources.GetResource(resolvedKey, Culture);

        return string.Format(resourceString, toWords ? NumberToWords(unit, number, Culture) : number);
    }

    protected virtual string NumberToWords(TimeUnit unit, int number, CultureInfo culture) =>
        number.ToWords(culture);

    /// <summary>
    /// Override this method if your locale has complex rules around multiple units; e.g. Arabic, Russian
    /// </summary>
    /// <param name="resourceKey">The resource key that's being in formatting</param>
    /// <param name="number">The number of the units being used in formatting</param>
    protected virtual string GetResourceKey(string resourceKey, int number) =>
        resourceKey;

    protected virtual string GetResourceKey(string resourceKey) =>
        resourceKey;
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\FrenchFormatter.cs ---


namespace Humanizer;

class FrenchFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string DualPostfix = "_Dual";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (number == 2 && resourceKey is "DateHumanize_MultipleDaysAgo" or "DateHumanize_MultipleDaysFromNow")
        {
            return resourceKey + DualPostfix;
        }

        if (number == 0 && resourceKey.StartsWith("TimeSpanHumanize_Multiple"))
        {
            return resourceKey + "_Singular";
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\GermanFormatter.cs ---


namespace Humanizer;

class GermanFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    /// <inheritdoc />
    public override string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol = true) =>
        base.DataUnitHumanize(dataUnit, count, toSymbol).TrimEnd('s');
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\HebrewFormatter.cs ---


namespace Humanizer;

class HebrewFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string DualPostfix = "_Dual";
    const string PluralPostfix = "_Plural";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        //In Hebrew pluralization 2 entities gets a different word.
        if (number == 2)
        {
            return resourceKey + DualPostfix;
        }

        //In Hebrew pluralization entities where the count is between 3 and 10 gets a different word.
        //See http://lib.cet.ac.il/pages/item.asp?item=21585 for explanation
        if (number is >= 3 and <= 10)
        {
            return resourceKey + PluralPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\IcelandicFormatter.cs ---


namespace Humanizer;

class IcelandicFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    public override string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol = true) =>
        base.DataUnitHumanize(dataUnit, count, toSymbol).TrimEnd('s');

    protected override string NumberToWords(TimeUnit unit, int number, CultureInfo culture) =>
        number.ToWords(GetUnitGender(unit), culture);

    static GrammaticalGender GetUnitGender(TimeUnit unit) =>
        unit switch
        {
            TimeUnit.Day or TimeUnit.Month => GrammaticalGender.Masculine,
            TimeUnit.Year => GrammaticalGender.Neuter,
            _ => GrammaticalGender.Feminine
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\IFormatter.cs ---


namespace Humanizer;

/// <summary>
/// Implement this interface if your language has complex rules around dealing with numbers.
/// For example in Romanian "5 days" is "5 zile", while "24 days" is "24 de zile" and
/// in Arabic 2 days is  not 2 
/// </summary>
public interface IFormatter
{
    string DateHumanize_Now();

    string DateHumanize_Never();

    /// <summary>
    /// Returns the string representation of the provided DateTime
    /// </summary>
    string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit);

    /// <summary>
    /// 0 seconds
    /// </summary>
    /// <returns>Returns 0 seconds as the string representation of Zero TimeSpan</returns>
    string TimeSpanHumanize_Zero();

    /// <summary>
    /// Returns the string representation of the provided TimeSpan
    /// </summary>
    string TimeSpanHumanize(TimeUnit timeUnit, int unit, bool toWords = false);

    /// <summary>
    /// Returns the age format that converts a humanized TimeSpan string to an age expression.
    /// For instance, in English that format adds the " old" suffix, so that "40 years" becomes "40 years old".
    /// </summary>
    /// <returns>Age format</returns>
    string TimeSpanHumanize_Age();

    /// <summary>
    /// Returns the string representation of the provided DataUnit, either as a symbol or full word
    /// </summary>
    /// <param name="dataUnit">Data unit</param>
    /// <param name="count">Number of said units, to adjust for singular/plural forms</param>
    /// <param name="toSymbol">Indicates whether the data unit should be expressed as symbol or full word</param>
    /// <returns>String representation of the provided DataUnit</returns>
    string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol = true);

    /// <summary>
    /// Returns the symbol for the given TimeUnit
    /// </summary>
    /// <param name="timeUnit">Time unit</param>
    /// <returns>String representation of the provided TimeUnit</returns>
    string TimeUnitHumanize(TimeUnit timeUnit);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\LithuanianFormatter.cs ---


namespace Humanizer;

class LithuanianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (resourceKey == "TimeSpanHumanize_Zero")
        {
            return resourceKey;
        }

        var grammaticalNumber = LithuanianNumberFormDetector.Detect(number);
        var suffix = GetSuffix(grammaticalNumber);
        return resourceKey + suffix;
    }

    static string GetSuffix(LithuanianNumberForm form)
    {
        if (form == LithuanianNumberForm.Singular)
        {
            return "_Singular";
        }

        if (form == LithuanianNumberForm.GenitivePlural)
        {
            return "_Plural";
        }

        return "";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\LuxembourgishFormatter.cs ---


namespace Humanizer;

class LuxembourgishFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string DualPostfix = "_Dual";

    // https://lb.wikipedia.org/wiki/Eifeler_Reegel
    const char EifelerRuleSuffix = 'n';
    const string EifelerRuleCharacters = "unitedzohay";

    public override string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol = true) =>
        base
            .DataUnitHumanize(dataUnit, count, toSymbol)
            .TrimEnd('s');

    public static string ApplyEifelerRule(string word)
        => word.TrimEnd(EifelerRuleSuffix);

    public static string CheckForAndApplyEifelerRule(string word, string nextWord)
        => DoesEifelerRuleApply(nextWord)
            ? word.TrimEnd(EifelerRuleSuffix)
            : word;

    public static bool DoesEifelerRuleApply(string nextWord)
        => !string.IsNullOrWhiteSpace(nextWord)
           && !EifelerRuleCharacters.Contains(nextWord[0]);

    protected override string Format(TimeUnit unit, string resourceKey, int number, bool toWords = false)
    {
        var resourceString = Resources.GetResource(GetResourceKey(resourceKey, number), Culture);
        var numberAsWord = number.ToWords(GetUnitGender(unit), Culture);

        return string.Format(resourceString,
            toWords ? numberAsWord : number,
            DoesEifelerRuleApply(numberAsWord) ? "" : EifelerRuleSuffix);
    }

    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (number == 2 &&
            resourceKey is "DateHumanize_MultipleDaysAgo" or "DateHumanize_MultipleDaysFromNow")
        {
            return resourceKey + DualPostfix;
        }

        return resourceKey;
    }

    static GrammaticalGender GetUnitGender(TimeUnit unit) =>
        unit switch
        {
            TimeUnit.Day or TimeUnit.Month or TimeUnit.Year => GrammaticalGender.Masculine,
            _ => GrammaticalGender.Feminine
        };
}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\MalteseFormatter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class MalteseFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (number != 2)
        {
            return resourceKey;
        }

        if (DualResourceKeys.TryGetValue(resourceKey, out var result))
        {
            return result;
        }

        return resourceKey;
    }

    static readonly FrozenDictionary<string, string> DualResourceKeys =
        new Dictionary<string, string>
            {
                {
                    "DateHumanize_MultipleDaysAgo", "DateHumanize_MultipleDaysAgo_Dual"
                },
                {
                    "DateHumanize_MultipleDaysFromNow", "DateHumanize_MultipleDaysFromNow_Dual"
                },
                {
                    "DateHumanize_MultipleHoursAgo", "DateHumanize_MultipleHoursAgo_Dual"
                },
                {
                    "DateHumanize_MultipleHoursFromNow", "DateHumanize_MultipleHoursFromNow_Dual"
                },
                {
                    "DateHumanize_MultipleMonthsAgo", "DateHumanize_MultipleMonthsAgo_Dual"
                },
                {
                    "DateHumanize_MultipleMonthsFromNow", "DateHumanize_MultipleMonthsFromNow_Dual"
                },
                {
                    "DateHumanize_MultipleYearsAgo", "DateHumanize_MultipleYearsAgo_Dual"
                },
                {
                    "DateHumanize_MultipleYearsFromNow", "DateHumanize_MultipleYearsFromNow_Dual"
                },
                {
                    "TimeSpanHumanize_MultipleDays", "TimeSpanHumanize_MultipleDays_Dual"
                },
                {
                    "TimeSpanHumanize_MultipleYears", "TimeSpanHumanize_MultipleYears_Dual"
                },
                {
                    "TimeSpanHumanize_MultipleMonths", "TimeSpanHumanize_MultipleMonths_Dual"
                },
                {
                    "TimeSpanHumanize_MultipleHours", "TimeSpanHumanize_MultipleHours_Dual"
                },
                {
                    "TimeSpanHumanize_MultipleWeeks", "TimeSpanHumanize_MultipleWeeks_Dual"
                },
            }
            .ToFrozenDictionary();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\RomanianFormatter.cs ---


using System;

namespace Humanizer;

class RomanianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const int PrepositionIndicatingDecimals = 2;
    const int MaxNumeralWithNoPreposition = 19;
    const int MinNumeralWithNoPreposition = 1;
    const string UnitPreposition = " de";

    static readonly double Divider = Math.Pow(10, PrepositionIndicatingDecimals);

    protected override string Format(TimeUnit unit, string resourceKey, int number, bool toWords = false)
    {
        var format = Resources.GetResource(GetResourceKey(resourceKey, number), Culture);
        var preposition = ShouldUsePreposition(number)
            ? UnitPreposition
            : string.Empty;

        return string.Format(format, number, preposition);
    }

    static bool ShouldUsePreposition(int number)
    {
        var prepositionIndicatingNumeral = Math.Abs(number % Divider);
        return prepositionIndicatingNumeral is < MinNumeralWithNoPreposition or > MaxNumeralWithNoPreposition;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\RussianFormatter.cs ---


namespace Humanizer;

class RussianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    protected override string GetResourceKey(string resourceKey, int number)
    {
        var grammaticalNumber = RussianGrammaticalNumberDetector.Detect(number);
        return grammaticalNumber switch
        {
            RussianGrammaticalNumber.Singular => resourceKey + "_Singular",
            RussianGrammaticalNumber.Paucal => resourceKey + "_Paucal",
            _ => resourceKey
        };
    }

    protected override string NumberToWords(TimeUnit unit, int number, CultureInfo culture) =>
        number.ToWords(GetUnitGender(unit), culture);


    static GrammaticalGender GetUnitGender(TimeUnit unit) =>
        unit switch
        {
            TimeUnit.Hour or TimeUnit.Day or TimeUnit.Month or TimeUnit.Year => GrammaticalGender.Masculine,
            _ => GrammaticalGender.Feminine
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\SerbianFormatter.cs ---


namespace Humanizer;

class SerbianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string PaucalPostfix = "_Paucal";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        var mod10 = number % 10;
        if (mod10 is > 1 and < 5)
        {
            return resourceKey + PaucalPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\SlovenianFormatter.cs ---


namespace Humanizer;

class SlovenianFormatter(CultureInfo culture) :
    DefaultFormatter(culture)
{
    const string DualPostfix = "_Dual";
    const string TrialQuadralPostfix = "_Paucal";

    protected override string GetResourceKey(string resourceKey, int number)
    {
        if (number == 2)
        {
            return resourceKey + DualPostfix;
        }

        // When the count is three or four some words have a different form when counting in Slovenian language
        if (number is 3 or 4)
        {
            return resourceKey + TrialQuadralPostfix;
        }

        return resourceKey;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Formatters\UkrainianFormatter.cs ---


namespace Humanizer;

class UkrainianFormatter(CultureInfo culture)
    : DefaultFormatter(culture)
{
    protected override string GetResourceKey(string resourceKey, int number)
    {
        var grammaticalNumber = RussianGrammaticalNumberDetector.Detect(number);
        return grammaticalNumber switch
        {
            RussianGrammaticalNumber.Singular => resourceKey + "_Singular",
            RussianGrammaticalNumber.Paucal => resourceKey + "_Paucal",
            _ => resourceKey
        };
    }

    protected override string NumberToWords(TimeUnit unit, int number, CultureInfo culture) =>
        number.ToWords(GetUnitGender(unit), culture);

    static GrammaticalGender GetUnitGender(TimeUnit unit) =>
        unit switch
        {
            TimeUnit.Day or TimeUnit.Week or TimeUnit.Month or TimeUnit.Year => GrammaticalGender.Masculine,
            _ => GrammaticalGender.Feminine
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\GrammaticalNumber\LithuanianNumberForm.cs ---


namespace Humanizer;

enum LithuanianNumberForm
{
    Singular,
    Plural,
    GenitivePlural
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\GrammaticalNumber\LithuanianNumberFormDetector.cs ---


namespace Humanizer;

static class LithuanianNumberFormDetector
{
    public static LithuanianNumberForm Detect(long number)
    {
        var tens = number % 100 / 10;
        var units = number % 10;

        if (tens == 1 || units == 0) // 10-19, 20, 30, 40 ... 100, 110 ..
        {
            return LithuanianNumberForm.GenitivePlural;
        }

        if (units == 1) // 1, 21, 31, 41 ... 91, 101, 121 ...
        {
            return LithuanianNumberForm.Singular;
        }

        // 2-9, 22-29, 32 ...
        return LithuanianNumberForm.Plural;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\GrammaticalNumber\RussianGrammaticalNumber.cs ---


namespace Humanizer;

enum RussianGrammaticalNumber
{
    Singular,
    Paucal,
    Plural
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\GrammaticalNumber\RussianGrammaticalNumberDetector.cs ---


namespace Humanizer;

static class RussianGrammaticalNumberDetector
{
    public static RussianGrammaticalNumber Detect(long number)
    {
        var tens = number % 100 / 10;
        if (tens != 1)
        {
            var unity = number % 10;

            if (unity == 1) // 1, 21, 31, 41 ... 91, 101, 121 ...
            {
                return RussianGrammaticalNumber.Singular;
            }

            if (unity is > 1 and < 5) // 2, 3, 4, 22, 23, 24 ...
            {
                return RussianGrammaticalNumber.Paucal;
            }
        }

        return RussianGrammaticalNumber.Plural;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\Italian\ItalianCardinalNumberCruncher.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class ItalianCardinalNumberCruncher(int number, GrammaticalGender gender)
{
    public string Convert()
    {
        // it's easier to treat zero as a completely distinct case
        if (_fullNumber == 0)
        {
            return "zero";
        }

        var words = string.Empty;

        foreach (var part in _threeDigitParts)
        {
            var partToString = GetNextPartConverter();

            if (partToString != null)
            {
                words = partToString(part) + words;
            }
        }

        // remove trailing spaces if there are only millions or billions
        return words.TrimEnd();
    }

    readonly int _fullNumber = number;
    readonly List<int> _threeDigitParts = SplitEveryThreeDigits(number);
    readonly GrammaticalGender _gender = gender;

    protected ThreeDigitSets _nextSet = ThreeDigitSets.Units;

    /// <summary>
    /// Splits a number into a sequence of three-digits numbers, starting
    /// from units, then thousands, millions, and so on.
    /// </summary>
    /// <param name="number">The number to split.</param>
    /// <returns>The sequence of three-digit numbers.</returns>
    static List<int> SplitEveryThreeDigits(int number)
    {
        var parts = new List<int>();
        var rest = number;

        while (rest > 0)
        {
            var threeDigit = rest % 1000;

            parts.Add(threeDigit);

            rest /= 1000;
        }

        return parts;
    }

    /// <summary>
    /// During number conversion to text, finds out the converter to use
    /// for the next three-digit set.
    /// </summary>
    /// <returns>The next conversion function to use.</returns>
    Func<int, string>? GetNextPartConverter()
    {
        Func<int, string>? converter;

        switch (_nextSet)
        {
            case ThreeDigitSets.Units:
                converter = UnitsConverter;
                _nextSet = ThreeDigitSets.Thousands;
                break;

            case ThreeDigitSets.Thousands:
                converter = ThousandsConverter;
                _nextSet = ThreeDigitSets.Millions;
                break;

            case ThreeDigitSets.Millions:
                converter = MillionsConverter;
                _nextSet = ThreeDigitSets.Billions;
                break;

            case ThreeDigitSets.Billions:
                converter = BillionsConverter;
                _nextSet = ThreeDigitSets.More;
                break;

            case ThreeDigitSets.More:
                converter = null;
                break;

            default:
                throw new ArgumentOutOfRangeException("Unknow ThreeDigitSet: " + _nextSet);
        }

        return converter;
    }

    /// <summary>
    /// Converts a three-digit set to text.
    /// </summary>
    /// <param name="number">The three-digit set to convert.</param>
    /// <param name="thisIsLastSet">True if the current three-digit set is the last in the word.</param>
    /// <returns>The same three-digit set expressed as text.</returns>
    static string ThreeDigitSetConverter(int number, bool thisIsLastSet = false)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        // grab lowest two digits
        var tensAndUnits = number % 100;
        // grab third digit
        var hundreds = number / 100;

        // grab also first and second digits separately
        var units = tensAndUnits % 10;
        var tens = tensAndUnits / 10;

        var words = string.Empty;

        // append text for hundreds
        words += _hundredNumberToText[hundreds];

        // append text for tens, only those from twenty upward
        words += _tensOver20NumberToText[tens];

        if (tensAndUnits <= 9)
        {
            // simple case for units, under 10
            words += _unitsNumberToText[tensAndUnits];
        }
        else if (tensAndUnits <= 19)
        {
            // special case for 'teens', from 10 to 19
            words += _teensUnder20NumberToText[tensAndUnits - 10];
        }
        else
        {
            // just append units text, with some corner cases

            // truncate tens last vowel before 'uno' (1) and 'otto' (8)
            if (units is 1 or 8)
            {
                words = words.Remove(words.Length - 1);
            }

            // if this is the last set, an accent could be due
            var unitsText = thisIsLastSet && units == 3 ? "tr" : _unitsNumberToText[units];

            words += unitsText;
        }

        return words;
    }

    /// <summary>
    /// Converts a three-digit number, as units, to text.
    /// </summary>
    /// <param name="number">The three-digit number, as units, to convert.</param>
    /// <returns>The same three-digit number, as units, expressed as text.</returns>
    string UnitsConverter(int number)
    {
        // being a unique case, it's easier to treat unity feminine gender as a completely distinct case
        if (_gender == GrammaticalGender.Feminine && _fullNumber == 1)
        {
            return "una";
        }

        return ThreeDigitSetConverter(number, true);
    }

    /// <summary>
    /// Converts a thousands three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as thousands, to convert.</param>
    /// <returns>The same three-digit number of thousands expressed as text.</returns>
    static string ThousandsConverter(int number)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        if (number == 1)
        {
            return "mille";
        }

        return ThreeDigitSetConverter(number) + "mila";
    }

    /// <summary>
    /// Converts a millions three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as millions, to convert.</param>
    /// <returns>The same three-digit number of millions expressed as text.</returns>
    static string MillionsConverter(int number)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        if (number == 1)
        {
            return "un milione ";
        }

        return ThreeDigitSetConverter(number, true) + " milioni ";
    }

    /// <summary>
    /// Converts a billions three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as billions, to convert.</param>
    /// <returns>The same three-digit number of billions expressed as text.</returns>
    static string BillionsConverter(int number)
    {
        if (number == 1)
        {
            return "un miliardo ";
        }

        return ThreeDigitSetConverter(number) + " miliardi ";
    }

    /// <summary>
    /// Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
    /// </summary>
    static string[] _unitsNumberToText =
    [
        string.Empty,
        "uno",
        "due",
        "tre",
        "quattro",
        "cinque",
        "sei",
        "sette",
        "otto",
        "nove"
    ];

    /// <summary>
    /// Lookup table converting tens number to text. Index 2 for 20, index 3 for 30, up to index 9 for 90.
    /// </summary>
    static string[] _tensOver20NumberToText =
    [
        string.Empty,
        string.Empty,
        "venti",
        "trenta",
        "quaranta",
        "cinquanta",
        "sessanta",
        "settanta",
        "ottanta",
        "novanta"
    ];

    /// <summary>
    /// Lookup table converting teens number to text. Index 0 for 10, index 1 for 11, up to index 9 for 19.
    /// </summary>
    static string[] _teensUnder20NumberToText =
    [
        "dieci",
        "undici",
        "dodici",
        "tredici",
        "quattordici",
        "quindici",
        "sedici",
        "diciassette",
        "diciotto",
        "diciannove"
    ];

    /// <summary>
    /// Lookup table converting hundreds number to text. Index 0 for no hundreds, index 1 for 100, up to index 9.
    /// </summary>
    static string[] _hundredNumberToText =
    [
        string.Empty,
        "cento",
        "duecento",
        "trecento",
        "quattrocento",
        "cinquecento",
        "seicento",
        "settecento",
        "ottocento",
        "novecento"
    ];

    /// <summary>
    /// Enumerates sets of three-digits having distinct conversion to text.
    /// </summary>
    protected enum ThreeDigitSets
    {
        /// <summary>
        /// Lowest three-digits set, from 1 to 999.
        /// </summary>
        Units,

        /// <summary>
        /// Three-digits set counting the thousands, from 1'000 to 999'000.
        /// </summary>
        Thousands,

        /// <summary>
        /// Three-digits set counting millions, from 1'000'000 to 999'000'000.
        /// </summary>
        Millions,

        /// <summary>
        /// Three-digits set counting billions, from 1'000'000'000 to 999'000'000'000.
        /// </summary>
        Billions,

        /// <summary>
        /// Three-digits set beyond 999 billions, from 1'000'000'000'000 onward.
        /// </summary>
        More
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\Italian\ItalianOrdinalNumberCruncher.cs ---


namespace Humanizer;

class ItalianOrdinalNumberCruncher(int number, GrammaticalGender gender)
{
    public string Convert()
    {
        // it's easier to treat zero as a completely distinct case
        if (_fullNumber == 0)
        {
            return "zero";
        }

        if (_fullNumber <= 9)
        {
            // units ordinals, 1 to 9, are totally different than the rest: treat them as a distinct case
            return _unitsUnder10NumberToText[_fullNumber] + _genderSuffix;
        }

        var cardinalCruncher = new ItalianCardinalNumberCruncher(_fullNumber, _gender);

        var words = cardinalCruncher.Convert();

        var tensAndUnits = _fullNumber % 100;

        if (tensAndUnits == 10)
        {
            // for numbers ending in 10, cardinal and ordinal endings are different, suffix doesn't work
            words = words.Remove(words.Length - _lengthOf10AsCardinal) + "decim" + _genderSuffix;
        }
        else
        {
            // truncate last vowel
            words = words.Remove(words.Length - 1);

            var units = _fullNumber % 10;

            // reintroduce *unaccented* last vowel in some corner cases
            if (units == 3)
            {
                words += 'e';
            }
            else if (units == 6)
            {
                words += 'i';
            }

            var lowestThreeDigits = _fullNumber % 1000;
            var lowestSixDigits = _fullNumber % 1000000;
            var lowestNineDigits = _fullNumber % 1000000000;

            if (lowestNineDigits == 0)
            {
                // if exact billions, cardinal number words are joined
                words = words.Replace(" miliard", "miliard");

                // if 1 billion, numeral prefix is removed completely
                if (_fullNumber == 1000000000)
                {
                    words = words.Replace("un", string.Empty);
                }
            }
            else if (lowestSixDigits == 0)
            {
                // if exact millions, cardinal number words are joined
                words = words.Replace(" milion", "milion");

                // if 1 million, numeral prefix is removed completely
                if (_fullNumber == 1000000)
                {
                    words = words.Replace("un", string.Empty);
                }
            }
            else if (lowestThreeDigits == 0 && _fullNumber > 1000)
            {
                // if exact thousands, double the final 'l', apart from 1000 already having that
                words += 'l';
            }

            // append common ordinal suffix
            words += "esim" + _genderSuffix;
        }

        return words;
    }

    readonly int _fullNumber = number;
    readonly GrammaticalGender _gender = gender;
    readonly string _genderSuffix = gender == GrammaticalGender.Feminine ? "a" : "o";

    /// <summary>
    /// Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
    /// </summary>
    static string[] _unitsUnder10NumberToText =
    [
        string.Empty,
        "prim",
        "second",
        "terz",
        "quart",
        "quint",
        "sest",
        "settim",
        "ottav",
        "non"
    ];

    static int _lengthOf10AsCardinal = "dieci".Length;
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\Romanian\RomanianCardinalNumberConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class RomanianCardinalNumberConverter
{
    /// <summary>
    /// Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9 for 9.
    /// </summary>
    readonly string[] _units =
    [
        string.Empty,
        "unu|una|unu",
        "doi|dou|dou",
        "trei",
        "patru",
        "cinci",
        "ase",
        "apte",
        "opt",
        "nou"
    ];

    /// <summary>
    /// Lookup table converting teens number to text. Index 0 for 10, index 1 for 11, up to index 9 for 19.
    /// </summary>
    readonly string[] _teensUnder20NumberToText =
    [
        "zece",
        "unsprezece",
        "doisprezece|dousprezece|dousprezece",
        "treisprezece",
        "paisprezece",
        "cincisprezece",
        "aisprezece",
        "aptesprezece",
        "optsprezece",
        "nousprezece"
    ];

    /// <summary>
    /// Lookup table converting tens number to text. Index 2 for 20, index 3 for 30, up to index 9 for 90.
    /// </summary>
    readonly string[] _tensOver20NumberToText =
    [
        string.Empty,
        string.Empty,
        "douzeci",
        "treizeci",
        "patruzeci",
        "cincizeci",
        "aizeci",
        "aptezeci",
        "optzeci",
        "nouzeci"
    ];

    readonly string _feminineSingular = "o";
    readonly string _masculineSingular = "un";

    readonly string _joinGroups = "i";
    readonly string _joinAbove20 = "de";
    readonly string _minusSign = "minus";

    /// <summary>
    /// Enumerates sets of three-digits having distinct conversion to text.
    /// </summary>
    enum ThreeDigitSets
    {
        /// <summary>
        /// Lowest three-digits set, from 1 to 999.
        /// </summary>
        Units = 0,

        /// <summary>
        /// Three-digits set counting the thousands, from 1'000 to 999'000.
        /// </summary>
        Thousands = 1,

        /// <summary>
        /// Three-digits set counting millions, from 1'000'000 to 999'000'000.
        /// </summary>
        Millions = 2,

        /// <summary>
        /// Three-digits set counting billions, from 1'000'000'000 to 999'000'000'000.
        /// </summary>
        Billions = 3,

        /// <summary>
        /// Three-digits set beyond 999 billions, from 1'000'000'000'000 onward.
        /// </summary>
        More = 4
    }

    public string Convert(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return "zero";
        }

        var words = string.Empty;

        var prefixMinusSign = false;

        if (number < 0)
        {
            prefixMinusSign = true;
            number = -number;
        }

        var _threeDigitParts = SplitEveryThreeDigits(number);

        for (var i = 0; i < _threeDigitParts.Count; i++)
        {
            var currentSet = (ThreeDigitSets) Enum.ToObject(typeof(ThreeDigitSets), i);

            var partToString = GetNextPartConverter(currentSet);

            if (partToString != null)
            {
                words = partToString(_threeDigitParts[i], gender)
                    .Trim() + " " + words.Trim();
            }
        }

        if (prefixMinusSign)
        {
            words = _minusSign + " " + words;
        }

        // remove extra spaces
        return words
            .TrimEnd()
            .Replace("  ", " ");
    }

    /// <summary>
    /// Splits a number into a sequence of three-digits numbers,
    /// starting from units, then thousands, millions, and so on.
    /// </summary>
    /// <param name="number">The number to split.</param>
    /// <returns>The sequence of three-digit numbers.</returns>
    static List<int> SplitEveryThreeDigits(int number)
    {
        var parts = new List<int>();
        var rest = number;

        while (rest > 0)
        {
            var threeDigit = rest % 1000;

            parts.Add(threeDigit);

            rest /= 1000;
        }

        return parts;
    }

    /// <summary>
    /// During number conversion to text, finds out the converter
    /// to use for the next three-digit set.
    /// </summary>
    /// <returns>The next conversion function to use.</returns>
    Func<int, GrammaticalGender, string>? GetNextPartConverter(ThreeDigitSets currentSet) =>
        currentSet switch
        {
            ThreeDigitSets.Units => UnitsConverter,
            ThreeDigitSets.Thousands => ThousandsConverter,
            ThreeDigitSets.Millions => MillionsConverter,
            ThreeDigitSets.Billions => BillionsConverter,
            ThreeDigitSets.More => null,
            _ => throw new ArgumentOutOfRangeException("Unknow ThreeDigitSet: " + currentSet)
        };

    /// <summary>
    /// Converts a three-digit set to text.
    /// </summary>
    /// <param name="number">The three-digit set to convert.</param>
    /// <param name="gender">The grammatical gender to convert to.</param>
    /// <returns>The same three-digit set expressed as text.</returns>
    string ThreeDigitSetConverter(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        // grab lowest two digits
        var tensAndUnits = number % 100;
        // grab third digit
        var hundreds = number / 100;

        // grab also first and second digits separately
        var units = tensAndUnits % 10;
        var tens = tensAndUnits / 10;

        var words = string.Empty;

        // append text for hundreds
        words += HundredsToText(hundreds);

        // append text for tens, only those from twenty upward
        words += (tens >= 2 ? " " : string.Empty) + _tensOver20NumberToText[tens];

        if (tensAndUnits <= 9)
        {
            // simple case for units, under 10
            words += " " + GetPartByGender(_units[tensAndUnits], gender);
        }
        else if (tensAndUnits <= 19)
        {
            // special case for 'teens', from 10 to 19
            words += " " + GetPartByGender(_teensUnder20NumberToText[tensAndUnits - 10], gender);
        }
        else
        {
            // exception for zero
            var unitsText = units == 0 ? string.Empty : " " + _joinGroups + " " + GetPartByGender(_units[units], gender);

            words += unitsText;
        }

        return words;
    }

    static string GetPartByGender(string multiGenderPart, GrammaticalGender gender)
    {
        if (multiGenderPart.Contains("|"))
        {
            var parts = multiGenderPart.Split('|');
            if (gender == GrammaticalGender.Feminine)
            {
                return parts[1];
            }

            if (gender == GrammaticalGender.Neuter)
            {
                return parts[2];
            }

            return parts[0];
        }

        return multiGenderPart;
    }

    static bool IsAbove20(int number) =>
        number >= 20;

    string HundredsToText(int hundreds)
    {
        if (hundreds == 0)
        {
            return string.Empty;
        }

        if (hundreds == 1)
        {
            return _feminineSingular + " sut";
        }

        return GetPartByGender(_units[hundreds], GrammaticalGender.Feminine) + " sute";
    }

    /// <summary>
    /// Converts a three-digit number, as units, to text.
    /// </summary>
    /// <param name="number">The three-digit number, as units, to convert.</param>
    /// <param name="gender">The grammatical gender to convert to.</param>
    /// <returns>The same three-digit number, as units, expressed as text.</returns>
    string UnitsConverter(int number, GrammaticalGender gender) =>
        ThreeDigitSetConverter(number, gender);

    /// <summary>
    /// Converts a thousands three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as thousands, to convert.</param>
    /// <param name="gender">The grammatical gender to convert to.</param>
    /// <returns>The same three-digit number of thousands expressed as text.</returns>
    string ThousandsConverter(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        if (number == 1)
        {
            return _feminineSingular + " mie";
        }

        return ThreeDigitSetConverter(number, GrammaticalGender.Feminine) + (IsAbove20(number) ? " " + _joinAbove20 : string.Empty) + " mii";
    }

    // Large numbers (above 10^6) use a combined form of the long and short scales.
    /*
            Singular    Plural            Order     Scale
            -----------------------------------------------
            zece        zeci              10^1      -
            sut        sute              10^2      -
            mie         mii               10^3      -
            milion      milioane          10^6      short/long
            miliard     miliarde          10^9      long
            trilion     trilioane         10^12     short
    */

    /// <summary>
    /// Converts a millions three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as millions, to convert.</param>
    /// <param name="gender">The grammatical gender to convert to.</param>
    /// <returns>The same three-digit number of millions expressed as text.</returns>
    string MillionsConverter(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return string.Empty;
        }

        if (number == 1)
        {
            return _masculineSingular + " milion";
        }

        return ThreeDigitSetConverter(number, GrammaticalGender.Feminine) + (IsAbove20(number) ? " " + _joinAbove20 : string.Empty) + " milioane";
    }

    /// <summary>
    /// Converts a billions three-digit number to text.
    /// </summary>
    /// <param name="number">The three-digit number, as billions, to convert.</param>
    /// <param name="gender">The grammatical gender to convert to.</param>
    /// <returns>The same three-digit number of billions expressed as text.</returns>
    string BillionsConverter(int number, GrammaticalGender gender)
    {
        if (number == 1)
        {
            return _masculineSingular + " miliard";
        }

        return ThreeDigitSetConverter(number, GrammaticalGender.Feminine) + (IsAbove20(number) ? " " + _joinAbove20 : string.Empty) + " miliarde";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\Romanian\RomanianOrdinalNumberConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class RomanianOrdinalNumberConverter
{
    /// <summary>
    /// Lookup table converting units number to text. Index 1 for 1, index 2 for 2, up to index 9.
    /// </summary>
    readonly Dictionary<int, string> _ordinalsUnder10 = new()
    {
        {
            1, "primul|prima"
        },
        {
            2, "doilea|doua"
        },
        {
            3, "treilea|treia"
        },
        {
            4, "patrulea|patra"
        },
        {
            5, "cincilea|cincea"
        },
        {
            6, "aselea|asea"
        },
        {
            7, "aptelea|aptea"
        },
        {
            8, "optulea|opta"
        },
        {
            9, "noulea|noua"
        },
    };

    readonly string _femininePrefix = "a";
    readonly string _masculinePrefix = "al";
    readonly string _feminineSuffix = "a";
    readonly string _masculineSuffix = "lea";

    public string Convert(int number, GrammaticalGender gender)
    {
        // it's easier to treat zero as a completely distinct case
        if (number == 0)
        {
            return "zero";
        }

        if (number == 1)
        {
            // no prefixes for primul/prima
            return GetPartByGender(_ordinalsUnder10[number], gender);
        }

        if (number <= 9)
        {
            // units ordinals, 2 to 9, are totally different than the rest: treat them as a distinct case
            return string.Format("{0} {1}",
                gender == GrammaticalGender.Feminine ? _femininePrefix : _masculinePrefix,
                GetPartByGender(_ordinalsUnder10[number], gender)
            );
        }

        var coverter = new RomanianCardinalNumberConverter();
        var words = coverter.Convert(number, gender);

        // remove 'de' preposition
        words = words.Replace(" de ", " ");

        if (gender == GrammaticalGender.Feminine && words.EndsWith("zeci"))
        {
            words = words.Substring(0, words.Length - 4) + "zece";
        }
        else if (gender == GrammaticalGender.Feminine && words.Contains("zeci") && (words.Contains("milioane") || words.Contains("miliarde")))
        {
            words = words.Replace("zeci", "zecea");
        }

        if (gender == GrammaticalGender.Feminine && words.StartsWith("un "))
        {
            words = words
                .Substring(2)
                .TrimStart();
        }

        if (words.EndsWith("milioane"))
        {
            if (gender == GrammaticalGender.Feminine)
            {
                words = words.Substring(0, words.Length - 8) + "milioana";
            }
        }

        var customMasculineSuffix = _masculineSuffix;
        if (words.EndsWith("milion"))
        {
            if (gender == GrammaticalGender.Feminine)
            {
                words = words.Substring(0, words.Length - 6) + "milioana";
            }
            else
            {
                customMasculineSuffix = "u" + _masculineSuffix;
            }
        }
        else if (words.EndsWith("miliard"))
        {
            if (gender == GrammaticalGender.Masculine)
            {
                customMasculineSuffix = "u" + _masculineSuffix;
            }
        }

        // trim last letter
        if (gender == GrammaticalGender.Feminine && !words.EndsWith("zece") &&
            (words.EndsWith("a") ||
             words.EndsWith("") ||
             words.EndsWith("e") ||
             words.EndsWith("i")))
        {
            words = words.Substring(0, words.Length - 1);
        }

        return string.Format("{0} {1}{2}",
            gender == GrammaticalGender.Feminine ? _femininePrefix : _masculinePrefix,
            words,
            gender == GrammaticalGender.Feminine ? _feminineSuffix : customMasculineSuffix
        );
    }

    static string GetPartByGender(string multiGenderPart, GrammaticalGender gender)
    {
        if (multiGenderPart.Contains("|"))
        {
            var parts = multiGenderPart.Split('|');
            if (gender == GrammaticalGender.Feminine)
            {
                return parts[1];
            }

            return parts[0];
        }

        return multiGenderPart;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\AfrikaansNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class AfrikaansNumberToWordsConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nul", "een", "twee", "drie", "vier", "vyf", "ses", "sewe", "agt", "nege", "tien", "elf", "twaalf", "dertien", "veertien", "vyftien", "sestien", "sewentien", "agtien", "negentien"];
    static readonly string[] TensMap = ["nul", "tien", "twintig", "dertig", "veertig", "vyftig", "sestig", "sewentig", "tagtig", "negentig"];

    static readonly Dictionary<int, string> OrdinalExceptions = new()
    {
        {
            0, "nulste"
        },
        {
            1, "eerste"
        },
        {
            3, "derde"
        },
        {
            7, "sewende"
        },
        {
            8, "agste"
        },
        {
            9, "negende"
        },
        {
            10, "tiende"
        },
        {
            14, "veertiende"
        },
        {
            17, "sewentiende"
        },
        {
            19, "negentiende"
        }
    };

    public override string Convert(long number)
    {
        if (number is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        return Convert((int) number, false);
    }

    public override string ConvertToOrdinal(int number) =>
        Convert(number, true);

    string Convert(int number, bool isOrdinal)
    {
        if (number == 0)
        {
            return GetUnitValue(0, isOrdinal);
        }

        if (number < 0)
        {
            return $"minus {Convert(-number)}";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000)} miljard");
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000)} miljoen");
            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            parts.Add($"{Convert(number / 1000)} duisend");
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add($"{Convert(number / 100)} honderd");
            number %= 100;
        }

        if (number > 0)
        {
            //if (parts.Count != 0)
            //    parts.Add("en");

            if (number < 20)
            {
                if (parts.Count > 0)
                {
                    parts.Add("en");
                }

                parts.Add(GetUnitValue(number, isOrdinal));
            }
            else
            {
                var lastPartValue = number / 10 * 10;
                var lastPart = TensMap[number / 10];
                if (number % 10 > 0)
                {
                    lastPart = $"{GetUnitValue(number % 10, false)} en {(isOrdinal ? GetUnitValue(lastPartValue, true) : lastPart)}";
                }
                else if (number % 10 == 0)
                {
                    lastPart = $"{(parts.Count > 0 ? "en " : "")}{lastPart}{(isOrdinal ? "ste" : "")}";
                }
                else if (isOrdinal)
                {
                    lastPart = lastPart.TrimEnd('~') + "ste";
                }

                parts.Add(lastPart);
            }
        }
        else if (isOrdinal)
        {
            parts[^1] += "ste";
        }

        var toWords = string.Join(" ", parts);

        if (isOrdinal)
        {
            toWords = RemoveOnePrefix(toWords);
        }

        return toWords;
    }

    static string GetUnitValue(int number, bool isOrdinal)
    {
        if (isOrdinal)
        {
            if (ExceptionNumbersToWords(number, out var exceptionString))
            {
                return exceptionString;
            }

            if (number > 19)
            {
                return TensMap[number / 10] + "ste";
            }

            return UnitsMap[number] + "de";
        }

        return UnitsMap[number];
    }

    static string RemoveOnePrefix(string toWords)
    {
        // one hundred => hundredth
        if (toWords.StartsWith("een", StringComparison.Ordinal))
        {
            if (toWords.IndexOf("een en", StringComparison.Ordinal) != 0)
            {
                toWords = toWords.Remove(0, 4);
            }
        }

        return toWords;
    }

    static bool ExceptionNumbersToWords(int number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\ArabicNumberToWordsConverter.cs ---


using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

class ArabicNumberToWordsConverter :
    GenderedNumberToWordsConverter
{
    static readonly string[] Groups = ["", "", "", "", "", "", "", ""];
    static readonly string[] AppendedGroups = ["", "", "", "", "", "", "", ""];
    static readonly string[] PluralGroups = ["", "", "", "", "", "", "", ""];
    static readonly string[] OnesGroup = ["", "", "", "", "", "", "", "", "", "", "", " ", " ", " ", " ", " ", " ", " ", " ", " "];
    static readonly string[] TensGroup = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] HundredsGroup = ["", "", "", " ", " ", " ", " ", " ", " ", " "];
    static readonly string[] AppendedTwos = ["", "", "", "", "", "", "", ""];
    static readonly string[] Twos = ["", "", "", "", "", "", "", ""];

    static readonly string[] FeminineOnesGroup = ["", "", "", "", "", "", "", "", "", "", "", " ", " ", " ", " ", " ", " ", " ", " ", " "];

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return "";
        }

        if (number < 0)
        {
            return $" {Convert(-number, gender)}";
        }

        var result = string.Empty;
        var groupLevel = 0;

        while (number >= 1)
        {
            var groupNumber = number % 1000;
            number /= 1000;

            var tens = groupNumber % 100;
            var hundreds = groupNumber / 100;
            var process = string.Empty;

            if (hundreds > 0)
            {
                if (tens == 0 && hundreds == 2)
                {
                    process = AppendedTwos[0];
                }
                else
                {
                    process = HundredsGroup[hundreds];
                }
            }

            if (tens > 0)
            {
                if (tens < 20)
                {
                    if (tens == 2 && hundreds == 0 && groupLevel > 0)
                    {
                        if (number is 2000 or 2000000 or 2000000000)
                        {
                            process = AppendedTwos[groupLevel];
                        }
                        else
                        {
                            process = Twos[groupLevel];
                        }
                    }
                    else
                    {
                        if (process != string.Empty)
                        {
                            process += "  ";
                        }

                        if (tens == 1 && groupLevel > 0 && hundreds == 0)
                        {
                            process += " ";
                        }
                        else
                        {
                            process += gender == GrammaticalGender.Feminine && groupLevel == 0 ? FeminineOnesGroup[tens] : OnesGroup[tens];
                        }
                    }
                }
                else
                {
                    var ones = tens % 10;
                    tens /= 10;

                    if (ones > 0)
                    {
                        if (process != string.Empty)
                        {
                            process += "  ";
                        }

                        process += gender == GrammaticalGender.Feminine ? FeminineOnesGroup[ones] : OnesGroup[ones];
                    }

                    if (process != string.Empty)
                    {
                        process += "  ";
                    }

                    process += TensGroup[tens];
                }
            }

            if (process != string.Empty)
            {
                if (groupLevel > 0)
                {
                    if (result != string.Empty)
                    {
                        result = $" {result}";
                    }

                    if (groupNumber != 2)
                    {
                        if (groupNumber % 100 != 1)
                        {
                            if (groupNumber is >= 3 and <= 10)
                            {
                                result = $"{PluralGroups[groupLevel]} {result}";
                            }
                            else
                            {
                                result = $"{(result != string.Empty ? AppendedGroups[groupLevel] : Groups[groupLevel])} {result}";
                            }
                        }
                        else
                        {
                            result = $"{Groups[groupLevel]} {result}";
                        }
                    }
                }

                result = $"{process} {result}";
            }

            groupLevel++;
        }

        return result.Trim();
    }

    static readonly Dictionary<string, string> OrdinalExceptions = new()
    {
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
    };

    static readonly Dictionary<string, string> FeminineOrdinalExceptions = new()
    {
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
        {
            "", ""
        },
    };

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return "";
        }

        var beforeOneHundredNumber = number % 100;
        var overTensPart = number / 100 * 100;
        var beforeOneHundredWord = string.Empty;
        var overTensWord = string.Empty;

        if (beforeOneHundredNumber > 0)
        {
            beforeOneHundredWord = Convert(beforeOneHundredNumber, gender);
            beforeOneHundredWord = ParseNumber(beforeOneHundredWord, beforeOneHundredNumber, gender);
        }

        if (overTensPart > 0)
        {
            overTensWord = Convert(overTensPart);
            overTensWord = ParseNumber(overTensWord, overTensPart, gender);
        }

        var word = beforeOneHundredWord +
                   (overTensPart > 0
                       ? (string.IsNullOrWhiteSpace(beforeOneHundredWord) ? string.Empty : "  ") + overTensWord
                       : string.Empty);
        return word.Trim();
    }

    static string ParseNumber(string word, int number, GrammaticalGender gender)
    {
        if (number == 1)
        {
            return gender == GrammaticalGender.Feminine ? "" : "";
        }

        if (number <= 10)
        {
            var ordinals = gender == GrammaticalGender.Feminine ? FeminineOrdinalExceptions : OrdinalExceptions;
            foreach (var kv in ordinals.Where(kv => word.EndsWith(kv.Key)))
            {
                // replace word with exception
                return word.Substring(0, word.Length - kv.Key.Length) + kv.Value;
            }
        }
        else if (number is > 10 and < 100)
        {
            var parts = word.Split(' ');
            var newParts = new string[parts.Length];
            var count = 0;

            foreach (var part in parts)
            {
                var newPart = part;
                var oldPart = part;

                var ordinals = gender == GrammaticalGender.Feminine ? FeminineOrdinalExceptions : OrdinalExceptions;
                foreach (var kv in ordinals.Where(kv => oldPart.EndsWith(kv.Key)))
                {
                    // replace word with exception
                    newPart = oldPart.Substring(0, oldPart.Length - kv.Key.Length) + kv.Value;
                }

                if (number > 19 && newPart == oldPart && oldPart.Length > 1)
                {
                    newPart = "" + oldPart;
                }

                newParts[count++] = newPart;
            }

            word = string.Join(" ", newParts);
        }
        else
        {
            word = "" + word;
        }

        return word;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\ArmenianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class ArmenianNumberToWordsConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];

    static readonly Dictionary<long, string> OrdinalExceptions = new()
    {
        {
            0, ""
        },
        {
            1, ""
        },
        {
            2, ""
        },
        {
            3, ""
        },
        {
            4, ""
        }
    };

    public override string Convert(long number) =>
        ConvertImpl(number, false);

    public override string ConvertToOrdinal(int number)
    {
        if (ExceptionNumbersToWords(number, out var exceptionString))
        {
            return exceptionString;
        }

        return ConvertImpl(number, true);
    }

    string ConvertImpl(long number, bool isOrdinal)
    {
        if (number == 0)
        {
            return GetUnitValue(0, isOrdinal);
        }

        if (number == long.MinValue)
        {
            return "   " +
                   "    " +
                   "    " +
                   "  " +
                   "    " +
                   "    " +
                   "  ";
        }

        if (number < 0)
        {
            return $" {ConvertImpl(-number, isOrdinal)}";
        }

        var parts = new List<string>();

        if (number / 1000000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000000)} ");
            number %= 1000000000000000000;
        }

        if (number / 1000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000)} ");
            number %= 1000000000000000;
        }

        if (number / 1000000000000 > 0)

        {
            parts.Add($"{Convert(number / 1000000000000)} ");
            number %= 1000000000000;
        }

        if (number / 1000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000)} ");
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000)} ");
            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            if (number / 1000 == 1)
            {
                parts.Add("");
            }
            else
            {
                parts.Add($"{Convert(number / 1000)} ");
            }

            number %= 1000;
        }

        if (number / 100 > 0)
        {
            if (number / 100 == 1)
            {
                parts.Add("");
            }
            else
            {
                parts.Add($"{Convert(number / 100)} ");
            }

            number %= 100;
        }

        if (number > 0)
        {
            if (number < 20)
            {
                parts.Add(GetUnitValue(number, isOrdinal));
            }
            else
            {
                var lastPart = TensMap[number / 10];
                if (number % 10 > 0)
                {
                    lastPart += $"{GetUnitValue(number % 10, isOrdinal)}";
                }
                else if (isOrdinal)
                {
                    lastPart += "";
                }

                parts.Add(lastPart);
            }
        }
        else if (isOrdinal)
        {
            parts[^1] += "";
        }

        var toWords = string.Join(" ", parts);

        //if (isOrdinal)
        //{
        //    toWords = RemoveOnePrefix(toWords);
        //}

        return toWords;
    }

    static string GetUnitValue(long number, bool isOrdinal)
    {
        if (isOrdinal)
        {
            return UnitsMap[number] + "";
        }

        return UnitsMap[number];
    }

    static string RemoveOnePrefix(string toWords)
    {
        // one hundred => hundredth
        if (toWords.StartsWith("", StringComparison.Ordinal))
        {
            toWords = toWords.Remove(0, 4);
        }

        return toWords;
    }

    static bool ExceptionNumbersToWords(long number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\AzerbaijaniNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class AzerbaijaniNumberToWordsConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["sfr", "bir", "iki", "", "drd", "be", "alt", "yeddi", "skkiz", "doqquz"];
    static readonly string[] TensMap = ["sfr", "on", "iyirmi", "otuz", "qrx", "lli", "altm", "yetmi", "sksn", "doxsan"];

    static readonly Dictionary<char, string> OrdinalSuffix = new()
    {
        {
            '', "nc"
        },
        {
            'i', "inci"
        },
        {
            'u', "uncu"
        },
        {
            '', "nc"
        },
        {
            'o', "uncu"
        },
        {
            '', "nc"
        },
        {
            'e', "inci"
        },
        {
            'a', "nc"
        },
        {
            '', "inci"
        },
    };

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;
        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $"mnfi {Convert(-number)}";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000)} milyard");
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000)} milyon");
            number %= 1000000;
        }

        var thousand = number / 1000;
        if (thousand > 0)
        {
            parts.Add($"{(thousand > 1 ? Convert(thousand) : "")} min".Trim());
            number %= 1000;
        }

        var hundred = number / 100;
        if (hundred > 0)
        {
            parts.Add($"{(hundred > 1 ? Convert(hundred) : "")} yz".Trim());
            number %= 100;
        }

        if (number / 10 > 0)
        {
            parts.Add(TensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(UnitsMap[number]);
        }

        var toWords = string.Join(" ", parts);

        return toWords;
    }

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);
        var wordSuffix = string.Empty;
        var suffixFoundOnLastVowel = false;

        for (var i = word.Length - 1; i >= 0; i--)
        {
            if (OrdinalSuffix.TryGetValue(word[i], out wordSuffix))
            {
                suffixFoundOnLastVowel = i == word.Length - 1;
                break;
            }
        }

        if (word[^1] == 't')
        {
            word = word.Substring(0, word.Length - 1) + 'd';
        }

        if (suffixFoundOnLastVowel)
        {
            word = word.Substring(0, word.Length - 1);
        }

        return $"{word}{wordSuffix}";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\BanglaNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class BanglaNumberToWordsConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap =
    [
        "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", ""
    ];

    static readonly string[] HundredsMap =
    [
        "", "", "", "", "", "", "", "", "", ""
    ];

    static readonly Dictionary<int, string> OrdinalExceptions = new()
    {
        {
            1, ""
        },
        {
            2, ""
        },
        {
            3, ""
        },
        {
            4, ""
        },
        {
            5, ""
        },
        {
            6, ""
        },
        {
            7, ""
        },
        {
            8, ""
        },
        {
            9, ""
        },
        {
            10, ""
        },
        {
            11, ""
        },
        {
            12, ""
        },
        {
            13, ""
        },
        {
            14, ""
        },
        {
            15, ""
        },
        {
            16, ""
        },
        {
            17, ""
        },
        {
            18, ""
        },
        {
            100, " "
        },
        {
            1000, " "
        },
        {
            100000, " "
        },
        {
            10000000, " "
        },
    };

    public override string ConvertToOrdinal(int number)
    {
        if (ExceptionNumbersToWords(number, out var exceptionString))
        {
            return exceptionString;
        }

        return Convert(number) + " ";
    }

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;

        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $" {Convert(-number)}";
        }

        var parts = new List<string>();

        if (number / 10000000 > 0)
        {
            parts.Add($"{Convert(number / 10000000)} ");
            number %= 10000000;
        }

        if (number / 100000 > 0)
        {
            parts.Add($"{Convert(number / 100000)} ");
            number %= 100000;
        }

        if (number / 1000 > 0)
        {
            parts.Add($"{Convert(number / 1000)} ");
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add($"{HundredsMap[number / 100]}");
            number %= 100;
        }

        if (number > 0)
        {
            parts.Add(UnitsMap[number]);
        }

        return string.Join(" ", parts);
    }

    static bool ExceptionNumbersToWords(int number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\BrazilianPortugueseNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class BrazilianPortugueseNumberToWordsConverter :
    GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["zero", "um", "dois", "trs", "quatro", "cinco", "seis", "sete", "oito", "nove", "dez", "onze", "doze", "treze", "quatorze", "quinze", "dezesseis", "dezessete", "dezoito", "dezenove"];
    static readonly string[] TensMap = ["zero", "dez", "vinte", "trinta", "quarenta", "cinquenta", "sessenta", "setenta", "oitenta", "noventa"];
    static readonly string[] HundredsMap = ["zero", "cento", "duzentos", "trezentos", "quatrocentos", "quinhentos", "seiscentos", "setecentos", "oitocentos", "novecentos"];

    static readonly string[] OrdinalUnitsMap = ["zero", "primeiro", "segundo", "terceiro", "quarto", "quinto", "sexto", "stimo", "oitavo", "nono"];
    static readonly string[] OrdinalTensMap = ["zero", "dcimo", "vigsimo", "trigsimo", "quadragsimo", "quinquagsimo", "sexagsimo", "septuagsimo", "octogsimo", "nonagsimo"];
    static readonly string[] OrdinalHundredsMap = ["zero", "centsimo", "ducentsimo", "trecentsimo", "quadringentsimo", "quingentsimo", "sexcentsimo", "septingentsimo", "octingentsimo", "noningentsimo"];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > 999999999999 or < -999999999999)
        {
            throw new NotImplementedException();
        }

        var number = input;

        if (number == 0)
        {
            return "zero";
        }

        if (number < 0)
        {
            return $"menos {Convert(Math.Abs(number), gender)}";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            // gender is not applied for billions
            parts.Add(number / 1000000000 >= 2
                ? $"{Convert(number / 1000000000, GrammaticalGender.Masculine)} bilhes"
                : $"{Convert(number / 1000000000, GrammaticalGender.Masculine)} bilho");

            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            // gender is not applied for millions
            parts.Add(number / 1000000 >= 2
                ? $"{Convert(number / 1000000, GrammaticalGender.Masculine)} milhes"
                : $"{Convert(number / 1000000, GrammaticalGender.Masculine)} milho");

            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            // gender is not applied for thousands
            parts.Add(number / 1000 == 1 ? "mil" : $"{Convert(number / 1000, GrammaticalGender.Masculine)} mil");
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            if (number == 100)
            {
                parts.Add(parts.Count > 0 ? "e cem" : "cem");
            }
            else
            {
                // Gender is applied to hundreds starting from 200
                parts.Add(ApplyGender(HundredsMap[number / 100], gender));
            }

            number %= 100;
        }

        if (number > 0)
        {
            if (parts.Count != 0)
            {
                parts.Add("e");
            }

            if (number < 20)
            {
                parts.Add(ApplyGender(UnitsMap[number], gender));
            }
            else
            {
                var lastPart = TensMap[number / 10];
                if (number % 10 > 0)
                {
                    lastPart += $" e {ApplyGender(UnitsMap[number % 10], gender)}";
                }

                parts.Add(lastPart);
            }
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        // N/A in Portuguese ordinal
        if (number == 0)
        {
            return "zero";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add(number / 1000000000 == 1
                ? ApplyOrdinalGender("bilionsimo", gender)
                : string.Format("{0} " + ApplyOrdinalGender("bilionsimo", gender), ConvertToOrdinal(number / 1000000000, gender)));

            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add(number / 1000000 == 1
                ? ApplyOrdinalGender("milionsimo", gender)
                : string.Format("{0}" + ApplyOrdinalGender("milionsimo", gender), ConvertToOrdinal(number / 1000000000, gender)));

            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            parts.Add(number / 1000 == 1
                ? ApplyOrdinalGender("milsimo", gender)
                : string.Format("{0} " + ApplyOrdinalGender("milsimo", gender), ConvertToOrdinal(number / 1000, gender)));

            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add(ApplyOrdinalGender(OrdinalHundredsMap[number / 100], gender));
            number %= 100;
        }

        if (number / 10 > 0)
        {
            parts.Add(ApplyOrdinalGender(OrdinalTensMap[number / 10], gender));
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(ApplyOrdinalGender(OrdinalUnitsMap[number], gender));
        }

        return string.Join(" ", parts);
    }

    static string ApplyGender(string toWords, GrammaticalGender gender)
    {
        if (gender != GrammaticalGender.Feminine)
        {
            return toWords;
        }

        if (toWords.EndsWith("os"))
        {
            return toWords.Substring(0, toWords.Length - 2) + "as";
        }

        if (toWords.EndsWith("um"))
        {
            return toWords.Substring(0, toWords.Length - 2) + "uma";
        }

        if (toWords.EndsWith("dois"))
        {
            return toWords.Substring(0, toWords.Length - 4) + "duas";
        }

        return toWords;
    }

    static string ApplyOrdinalGender(string toWords, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Feminine)
        {
            return toWords.TrimEnd('o') + 'a';
        }

        return toWords;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\BulgarianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class BulgarianNumberToWordsConverter() :
    GenderedNumberToWordsConverter(GrammaticalGender.Neuter)
{
    static readonly string[] UnitsMap =
    [
        "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "",
        ""
    ];

    static readonly string[] TensMap =
    [
        "", "", "", "", "", "", "", "",
        "", ""
    ];

    static readonly string[] HundredsMap =
    [
        "", "", "", "", "", "", "", "",
        "", ""
    ];

    static readonly string[] HundredsOrdinalMap =
    [
        string.Empty, "", "", "", "", "", "", "", "",
        ""
    ];

    static readonly string[] UnitsOrdinal =
    [
        string.Empty, "", "", "", "", "", "", "", "", "e", "e",
        "", "", "", "", "", "", "",
        "", ""
    ];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true) =>
        InnerConvert(input, gender, false);

    public override string ConvertToOrdinal(int input, GrammaticalGender gender) =>
        InnerConvert(input, gender, true);

    static string InnerConvert(long input, GrammaticalGender gender, bool isOrdinal)
    {
        if (input == 0)
        {
            return isOrdinal ? OrdinalZero(gender) : "";
        }

        var parts = new List<string>();
        if (input < 0)
        {
            parts.Add("");
            input = -input;
        }

        CollectParts(parts, ref input, isOrdinal, 1_000_000_000_000_000_000, GrammaticalGender.Masculine, "", "", ToOrdinalOverAHundred("", gender));
        CollectParts(parts, ref input, isOrdinal, 1_000_000_000_000_000, GrammaticalGender.Masculine, "", "", ToOrdinalOverAHundred("", gender));
        CollectParts(parts, ref input, isOrdinal, 1_000_000_000_000, GrammaticalGender.Masculine, "", "", ToOrdinalOverAHundred("", gender));
        CollectParts(parts, ref input, isOrdinal, 1_000_000_000, GrammaticalGender.Masculine, "", "", ToOrdinalOverAHundred("", gender));
        CollectParts(parts, ref input, isOrdinal, 1_000_000, GrammaticalGender.Masculine, "", "", ToOrdinalOverAHundred("", gender));
        CollectParts(parts, ref input, isOrdinal, 1_000, GrammaticalGender.Feminine, "", "", ToOrdinalOverAHundred("", gender));
        CollectPartsUnderOneThousand(parts, ref input, isOrdinal, gender);

        return string.Join(" ", parts);
    }

    static void CollectParts(IList<string> parts, ref long number, bool isOrdinal, long divisor, GrammaticalGender gender, string singular, string plural, string ordinal)
    {
        if (number < divisor)
        {
            return;
        }

        var result = number / divisor;

        if (parts.Count > 0)
        {
            parts.Add("");
        }

        CollectPartsUnderOneThousand(parts, ref result, false, gender);

        number %= divisor;
        if (number == 0 && isOrdinal)
        {
            parts.Add(ordinal);
        }
        else
        {
            parts.Add(result == 1 ? singular : plural);
        }
    }

    static void CollectPartsUnderOneThousand(IList<string> parts, ref long number, bool isOrdinal, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return;
        }

        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            if (number == 0 && isOrdinal)
            {
                parts.Add(ToOrdinalOverAHundred(HundredsOrdinalMap[hundreds], gender));
            }
            else
            {
                parts.Add(HundredsMap[hundreds]);
            }
        }

        if (number >= 20)
        {
            var tens = number / 10;
            number %= 10;
            if (number == 0 && isOrdinal)
            {
                parts.Add(ToOrdinalUnitsAndTens(TensMap[tens], gender));
            }
            else
            {
                parts.Add(TensMap[tens]);
            }
        }

        if (number > 0)
        {
            if (isOrdinal)
            {
                parts.Add(ToOrdinalUnitsAndTens(UnitsOrdinal[number], gender));
            }
            else
            {
                parts.Add(GetUnit(number, gender));
            }
        }

        if (parts.Count > 1)
        {
            parts.Insert(parts.Count - 1, "");
        }
    }

    static string GetUnit(long number, GrammaticalGender gender) =>
        (number, gender) switch
        {
            (1, GrammaticalGender.Masculine) => "",
            (1, GrammaticalGender.Feminine) => "",
            (2, GrammaticalGender.Masculine) => "",
            _ => UnitsMap[number],
        };

    static string OrdinalZero(GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => "",
            GrammaticalGender.Feminine => "",
            GrammaticalGender.Neuter => "",
            _ => throw new ArgumentOutOfRangeException(nameof(gender), gender, null)
        };

    static string ToOrdinalOverAHundred(string word, GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => $"{word}",
            GrammaticalGender.Feminine => $"{word}",
            GrammaticalGender.Neuter => $"{word}",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };

    static string ToOrdinalUnitsAndTens(string word, GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => $"{word}",
            GrammaticalGender.Feminine => $"{word}",
            GrammaticalGender.Neuter => $"{word}",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\CentralKurdishNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class CentralKurdishNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] KurdishHundredsMap = ["", "", " ", " ", " ", " ", " ", " ", " ", " "];
    static readonly string[] KurdishTensMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] KurdishUnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

    public override string Convert(long number)
    {
        var largestNumber = Math.Pow(10, 15) * 1000 - 1;
        if (number > largestNumber || number < -largestNumber)
        {
            throw new NotImplementedException();
        }

        if (number < 0)
        {
            return $" {Convert(-number)}";
        }

        if (number == 0)
        {
            return "";
        }

        var kurdishGroupsMap = new Dictionary<long, Func<long, string>>
        {
            {
                (long) Math.Pow(10, 15), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 12), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 9), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 6), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 3), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 2), n => KurdishHundredsMap[n]
            }
        };

        var parts = new List<string>();
        foreach (var group in kurdishGroupsMap.Keys)
        {
            if (number / group > 0)
            {
                parts.Add(kurdishGroupsMap[group](number / group));
                number %= group;
            }
        }

        if (number >= 20)
        {
            parts.Add(KurdishTensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(KurdishUnitsMap[number]);
        }

        var sentence = string.Join("  ", parts);
        if (sentence.StartsWith(" "))
        {
            return sentence.Substring(" ".Length);
        }

        return sentence;
    }

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);
        return $"{word}{(IsVowel(word[^1]) ? "" : "")}";
    }

    static bool IsVowel(char c) =>
        c is '' or '' or '' or '' or '';
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\ChineseNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class ChineseNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", ""];

    public override string Convert(long number) =>
        Convert(number, false, IsSpecial(number));

    public override string ConvertToOrdinal(int number) =>
        Convert(number, true, IsSpecial(number));

    static bool IsSpecial(long number) => number is > 10 and < 20;

    static string Convert(long number, bool isOrdinal, bool isSpecial)
    {
        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $" {Convert(-number, false, false)}";
        }

        var parts = new List<string>();

        if (number / 1000000000000 > 0)
        {
            var format = "{0}";
            if (number % 1000000000000 < 100000000000 && number % 1000000000000 > 0)
            {
                format = "{0}";
            }

            parts.Add(string.Format(format, Convert(number / 1000000000000, false, false)));
            number %= 1000000000000;
        }

        if (number / 100000000 > 0)
        {
            var format = "{0}";
            if (number % 100000000 < 10000000 && number % 100000000 > 0)
            {
                format = "{0}";
            }

            parts.Add(string.Format(format, Convert(number / 100000000, false, false)));
            number %= 100000000;
        }

        if (number / 10000 > 0)
        {
            var format = "{0}";
            if (number % 10000 < 1000 && number % 10000 > 0)
            {
                format = "{0}";
            }

            parts.Add(string.Format(format, Convert(number / 10000, false, false)));
            number %= 10000;
        }

        if (number / 1000 > 0)
        {
            var format = "{0}";
            if (number % 1000 < 100 && number % 1000 > 0)
            {
                format = "{0}";
            }

            parts.Add(string.Format(format, Convert(number / 1000, false, false)));
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            var format = "{0}";
            if (number % 100 < 10 && number % 100 > 0)
            {
                format = "{0}";
            }

            parts.Add(string.Format(format, Convert(number / 100, false, false)));
            number %= 100;
        }

        if (number > 0)
        {
            if (number <= 10)
            {
                parts.Add(UnitsMap[number]);
            }
            else
            {
                var lastPart = $"{UnitsMap[number / 10]}";
                if (number % 10 > 0)
                {
                    lastPart += $"{UnitsMap[number % 10]}";
                }

                parts.Add(lastPart);
            }
        }

        var toWords = string.Concat(parts);

        if (isSpecial)
        {
            toWords = toWords.Substring(1);
        }

        if (isOrdinal)
        {
            toWords = $" {toWords}";
        }

        return toWords;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\CroatianNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class CroatianNumberToWordsConverter(CultureInfo culture)
    : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap =
    [
        "nula",
        "jedan",
        "dva",
        "tri",
        "etiri",
        "pet",
        "est",
        "sedam",
        "osam",
        "devet",
        "deset",
        "jedanaest",
        "dvanaest",
        "trinaest",
        "etrnaest",
        "petnaest",
        "esnaest",
        "sedamnaest",
        "osamnaest",
        "devetnaest"
    ];

    static readonly string[] TensMap =
    [
        "nula",
        "deset",
        "dvadeset",
        "trideset",
        "etrdeset",
        "pedeset",
        "ezdeset",
        "sedamdeset",
        "osamdeset",
        "devedeset"
    ];

    public override string Convert(long number)
    {
        switch (number)
        {
            case 0: return "nula";
            case < 0:
                return number != long.MinValue
                    ? $"minus {Convert(-number)}"
                    : "minus devet trilijuna dvjesto dvadeset tri bilijarde tristo sedamdeset dva bilijuna trideset est milijardi osamsto pedeset etiri milijuna sedamsto sedamdeset pet tisua osamsto osam";
        }

        var parts = new List<string>();

        var quintillions = number / 1000000000000000000;
        if (quintillions > 0)
        {
            var part = quintillions switch
            {
                1 => "trilijun",
                _ => $"{Convert(quintillions)} trilijuna"
            };

            parts.Add(part);
            number %= 1000000000000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var quadrillions = number / 1000000000000000;
        if (quadrillions > 0)
        {
            string part;
            switch (quadrillions)
            {
                case 1:
                    part = "bilijarda";
                    break;
                case 2:
                    part = "dvije bilijarde";
                    break;
                case 3:
                case 4:
                    part = $"{Convert(quadrillions)} bilijarde";
                    break;
                default:
                {
                    if (quadrillions % 100 > 4 && quadrillions % 100 < 21)
                    {
                        part = $"{Convert(quadrillions)} bilijardi";
                        break;
                    }

                    switch (quadrillions % 10)
                    {
                        case 1:
                            part = $"{Convert(quadrillions - 1)} jedna bilijarda";
                            break;
                        case 2:
                            part = $"{Convert(quadrillions - 2)} dvije bilijarde";
                            break;
                        case 3:
                        case 4:
                            part = $"{Convert(quadrillions)} bilijarde";
                            break;
                        default:
                            part = $"{Convert(quadrillions)} bilijardi";
                            break;
                    }

                    break;
                }
            }

            parts.Add(part);
            number %= 1000000000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var trillions = number / 1000000000000;
        if (trillions > 0)
        {
            string part;
            switch (trillions)
            {
                case 1:
                    part = "bilijun";
                    break;
                default:
                {
                    if (trillions % 100 == 11 || trillions % 10 != 1)
                    {
                        part = $"{Convert(trillions)} bilijuna";
                        break;
                    }

                    part = $"{Convert(trillions)} bilijun";
                    break;
                }
            }

            parts.Add(part);
            number %= 1000000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var billions = number / 1000000000;
        if (billions > 0)
        {
            string part;
            switch (billions)
            {
                case 1:
                    part = "milijarda";
                    break;
                case 2:
                    part = "dvije milijarde";
                    break;
                case 3:
                case 4:
                    part = $"{Convert(billions)} milijarde";
                    break;
                default:
                {
                    if (billions % 100 > 4 && billions % 100 < 21)
                    {
                        part = $"{Convert(billions)} milijardi";
                        break;
                    }

                    switch (billions % 10)
                    {
                        case 1:
                            part = $"{Convert(billions - 1)} jedna milijarda";
                            break;
                        case 2:
                            part = $"{Convert(billions - 2)} dvije milijarde";
                            break;
                        case 3:
                        case 4:
                            part = $"{Convert(billions)} milijarde";
                            break;
                        default:
                            part = $"{Convert(billions)} milijardi";
                            break;
                    }

                    break;
                }
            }

            parts.Add(part);
            number %= 1000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var millions = number / 1000000;
        if (millions > 0)
        {
            string part;
            switch (millions)
            {
                case 1:
                    part = "milijun";
                    break;
                default:
                {
                    if (millions % 100 == 11 || millions % 10 != 1)
                    {
                        part = $"{Convert(millions)} milijuna";
                        break;
                    }

                    part = $"{Convert(millions)} milijun";
                    break;
                }
            }

            parts.Add(part);
            number %= 1000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var thousands = number / 1000;
        if (thousands > 0)
        {
            string part;
            switch (thousands)
            {
                case 1:
                    part = "tisuu";
                    break;
                case 2:
                    part = "dvije tisue";
                    break;
                case 3:
                case 4:
                    part = $"{Convert(thousands)} tisue";
                    break;
                default:
                {
                    if (thousands % 100 > 4 && thousands % 100 < 21)
                    {
                        part = $"{Convert(thousands)} tisua";
                        break;
                    }

                    switch (thousands % 10)
                    {
                        case 1:
                            part = $"{Convert(thousands - 1)} jedna tisua";
                            break;
                        case 2:
                            part = $"{Convert(thousands - 2)} dvije tisue";
                            break;
                        case 3:
                        case 4:
                            part = $"{Convert(thousands)} tisue";
                            break;
                        default:
                            part = $"{Convert(thousands)} tisua";
                            break;
                    }

                    break;
                }
            }

            parts.Add(part);
            number %= 1000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var hundreds = number / 100;
        if (hundreds > 0)
        {
            var part = hundreds switch
            {
                1 => "sto",
                2 => "dvjesto",
                _ => $"{Convert(hundreds)}sto"
            };

            parts.Add(part);
            number %= 100;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        switch (number)
        {
            case <= 0:
                return string.Concat(parts);
            case < 20:
                parts.Add(UnitsMap[number]);
                break;
            default:
            {
                parts.Add(TensMap[number / 10]);
                var units = number % 10;

                if (units > 0)
                {
                    parts.Add($" {UnitsMap[units]}");
                }

                break;
            }
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number) =>
        //TODO: In progress
        number.ToString(culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\CzechNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class CzechNumberToWordsConverter(CultureInfo culture) :
    GenderedNumberToWordsConverter
{
    static readonly string[] BillionsMap = ["miliarda", "miliardy", "miliard"];
    static readonly string[] MillionsMap = ["milion", "miliony", "milion"];
    static readonly string[] ThousandsMap = ["tisc", "tisce", "tisc"];
    static readonly string[] HundredsMap = ["nula", "sto", "dv st", "ti sta", "tyi sta", "pt set", "est set", "sedm set", "osm set", "devt set"];
    static readonly string[] TensMap = ["nula", "deset", "dvacet", "ticet", "tyicet", "padest", "edest", "sedmdest", "osmdest", "devadest"];
    static readonly string[] UnitsMap = ["nula", "jeden", "dva", "ti", "tyi", "pt", "est", "sedm", "osm", "devt", "deset", "jedenct", "dvanct", "tinct", "trnct", "patnct", "estnct", "sedmnct", "osmnct", "devatenct"];

    static readonly string[] UnitsMasculineOverrideMap = ["jeden", "dva"];
    static readonly string[] UnitsFeminineOverrideMap = ["jedna", "dv"];
    static readonly string[] UnitsNeuterOverride = ["jedno", "dv"];
    static readonly string[] UnitsIntraOverride = ["jedna", "dva"];

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return UnitByGender(number, gender);
        }

        var parts = new List<string>();
        if (number < 0)
        {
            parts.Add("mnus");
            number = -number;
        }

        CollectThousandAndAbove(parts, ref number, 1_000_000_000, GrammaticalGender.Feminine, BillionsMap);
        CollectThousandAndAbove(parts, ref number, 1_000_000, GrammaticalGender.Masculine, MillionsMap);
        CollectThousandAndAbove(parts, ref number, 1_000, GrammaticalGender.Masculine, ThousandsMap);

        CollectLessThanThousand(parts, number, gender);

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        number.ToString(culture);

    static string UnitByGender(long number, GrammaticalGender? gender)
    {
        if (number != 1 && number != 2)
        {
            return UnitsMap[number];
        }

        return gender switch
        {
            GrammaticalGender.Masculine => UnitsMasculineOverrideMap[number - 1],
            GrammaticalGender.Feminine => UnitsFeminineOverrideMap[number - 1],
            GrammaticalGender.Neuter => UnitsNeuterOverride[number - 1],
            null => UnitsIntraOverride[number - 1],
            _ => throw new ArgumentOutOfRangeException(nameof(gender)),
        };
    }

    static void CollectLessThanThousand(List<string> parts, long number, GrammaticalGender? gender)
    {
        if (number >= 100)
        {
            parts.Add(HundredsMap[number / 100]);
            number %= 100;
        }

        if (number >= 20)
        {
            parts.Add(TensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(UnitByGender(number, gender));
        }
    }

    static void CollectThousandAndAbove(List<string> parts, ref long number, long divisor, GrammaticalGender gender, string[] map)
    {
        var n = number / divisor;

        if (n <= 0)
        {
            return;
        }

        CollectLessThanThousand(parts, n, n < 19 ? gender : null);

        var units = n % 1000;

        if (units == 1)
        {
            parts.Add(map[0]);
        }
        else if (units is > 1 and < 5)
        {
            parts.Add(map[1]);
        }
        else
        {
            parts.Add(map[2]);
        }

        number %= divisor;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\DefaultNumberToWordsConverter.cs ---


namespace Humanizer;

class DefaultNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    readonly CultureInfo? _culture;

    /// <summary>
    /// Constructor.
    /// </summary>
    /// <param name="culture">Culture to use.</param>
    public DefaultNumberToWordsConverter(CultureInfo? culture) =>
        _culture = culture;

    /// <summary>
    /// 3501.ToWords() -> "three thousand five hundred and one"
    /// </summary>
    /// <param name="number">Number to be turned to words</param>
    public override string Convert(long number) =>
        number.ToString(_culture);

    /// <summary>
    /// 1.ToOrdinalWords() -> "first"
    /// </summary>
    /// <param name="number">Number to be turned to ordinal words</param>
    public override string ConvertToOrdinal(int number) =>
        number.ToString(_culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\DutchNumberToWordsConverter.cs ---


using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

/// <summary>
/// Dutch spelling of numbers is not really officially regulated.
/// There are a few different rules that can be applied.
/// Used the rules as stated here.
/// http://www.beterspellen.nl/website/?pag=110
/// </summary>
class DutchNumberToWordsConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nul", "een", "twee", "drie", "vier", "vijf", "zes", "zeven", "acht", "negen", "tien", "elf", "twaalf", "dertien", "veertien", "vijftien", "zestien", "zeventien", "achttien", "negentien"];
    static readonly string[] TensMap = ["nul", "tien", "twintig", "dertig", "veertig", "vijftig", "zestig", "zeventig", "tachtig", "negentig"];

    class Fact
    {
        public long Value { get; set; }
        public required string Name { get; set; }
        public required string Prefix { get; set; }
        public required string Postfix { get; set; }
        public bool DisplayOneUnit { get; set; }
    }

    static readonly Fact[] Hunderds =
    [
        new()
        {
            Value = 1_000_000_000_000_000_000L,
            Name = "triljoen",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 1_000_000_000_000_000L,
            Name = "biljard",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 1_000_000_000_000L,
            Name = "biljoen",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 1000000000,
            Name = "miljard",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 1000000,
            Name = "miljoen",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 1000,
            Name = "duizend",
            Prefix = "",
            Postfix = " ",
            DisplayOneUnit = false
        },
        new()
        {
            Value = 100,
            Name = "honderd",
            Prefix = "",
            Postfix = "",
            DisplayOneUnit = false
        }
    ];

    public override string Convert(long input)
    {
        var number = input;

        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $"min {Convert(-number)}";
        }

        var word = "";

        foreach (var m in Hunderds)
        {
            var divided = number / m.Value;

            if (divided <= 0)
            {
                continue;
            }

            if (divided == 1 && !m.DisplayOneUnit)
            {
                word += m.Name;
            }
            else
            {
                word += Convert(divided) + m.Prefix + m.Name;
            }

            number %= m.Value;
            if (number > 0)
            {
                word += m.Postfix;
            }
        }

        if (number > 0)
        {
            if (number < 20)
            {
                word += UnitsMap[number];
            }
            else
            {
                var tens = TensMap[number / 10];
                var unit = number % 10;
                if (unit > 0)
                {
                    var units = UnitsMap[unit];
                    var trema = units.EndsWith("e");
                    word += units + (trema ? "n" : "en") + tens;
                }
                else
                {
                    word += tens;
                }
            }
        }

        return word;
    }

    static readonly Dictionary<string, string> OrdinalExceptions = new()
    {
        {
            "een", "eerste"
        },
        {
            "drie", "derde"
        },
        {
            "miljoen", "miljoenste"
        },
    };

    static readonly char[] EndingCharForSte = ['t', 'g', 'd'];

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);

        foreach (var kv in OrdinalExceptions.Where(kv => word.EndsWith(kv.Key)))
        {
            // replace word with exception
            return word.Substring(0, word.Length - kv.Key.Length) + kv.Value;
        }

        // achtste
        // twintigste, dertigste, veertigste, ...
        // honderdste, duizendste, ...
        if (word.LastIndexOfAny(EndingCharForSte) == word.Length - 1)
        {
            return word + "ste";
        }

        return word + "de";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\EnglishNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class EnglishNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"];
    static readonly string[] TensMap = ["zero", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"];

    static readonly Dictionary<long, string> OrdinalExceptions = new()
    {
        {
            1, "first"
        },
        {
            2, "second"
        },
        {
            3, "third"
        },
        {
            4, "fourth"
        },
        {
            5, "fifth"
        },
        {
            8, "eighth"
        },
        {
            9, "ninth"
        },
        {
            12, "twelfth"
        },
    };

    public override string Convert(long number) =>
        Convert(number, false);

    public override string Convert(long number, bool addAnd = true) =>
        Convert(number, false, addAnd);

    public override string ConvertToOrdinal(int number) =>
        Convert(number, true);

    string Convert(long number, bool isOrdinal, bool addAnd = true)
    {
        if (number == 0)
        {
            return GetUnitValue(0, isOrdinal);
        }

        if (number < 0)
        {
            return $"minus {Convert(-number)}";
        }

        var parts = new List<string>(20);

        CollectParts(parts, ref number, isOrdinal, 1_000_000_000_000_000_000, "quintillion", "quintillionth");
        CollectParts(parts, ref number, isOrdinal, 1_000_000_000_000_000, "quadrillion", "quadrillionth");
        CollectParts(parts, ref number, isOrdinal, 1_000_000_000_000, "trillion", "trillionth");
        CollectParts(parts, ref number, isOrdinal, 1_000_000_000, "billion", "billionth");
        CollectParts(parts, ref number, isOrdinal, 1_000_000, "million", "millionth");
        CollectParts(parts, ref number, isOrdinal, 1_000, "thousand", "thousandth");

        CollectPartsUnderAThousand(parts, number, isOrdinal, addAnd);

        if (isOrdinal && parts[0] == "one")
        {
            // one hundred => hundredth
            parts.RemoveAt(0);
        }

        return string.Join(" ", parts);
    }

    static void CollectParts(List<string> parts, ref long number, bool isOrdinal, long divisor, string word, string ordinal)
    {
        var result = number / divisor;
        if (result == 0)
        {
            return;
        }

        CollectPartsUnderAThousand(parts, result);

        number %= divisor;
        parts.Add(number == 0 && isOrdinal ? ordinal : word);
    }

    static void CollectPartsUnderAThousand(List<string> parts, long number, bool isOrdinal = false, bool addAnd = true)
    {
        if (number >= 100)
        {
            parts.Add(GetUnitValue(number / 100, false));
            number %= 100;
            parts.Add(number == 0 && isOrdinal ? "hundredth" : "hundred");
        }

        if (number == 0)
        {
            return;
        }

        if (parts.Count > 0 && addAnd)
        {
            parts.Add("and");
        }

        if (number >= 20)
        {
            var tens = TensMap[number / 10];
            var units = number % 10;
            if (units == 0)
            {
                parts.Add(isOrdinal ? $"{tens.TrimEnd('y')}ieth" : tens);
            }
            else
            {
                parts.Add($"{tens}-{GetUnitValue(units, isOrdinal)}");
            }
        }
        else
        {
            parts.Add(GetUnitValue(number, isOrdinal));
        }
    }

    static string GetUnitValue(long number, bool isOrdinal)
    {
        if (isOrdinal)
        {
            if (ExceptionNumbersToWords(number, out var exceptionString))
            {
                return exceptionString;
            }

            return $"{UnitsMap[number]}th";
        }

        return UnitsMap[number];
    }

    static bool ExceptionNumbersToWords(long number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);

    public override string ConvertToTuple(int number) =>
        number switch
        {
            1 => "single",
            2 => "double",
            3 => "triple",
            4 => "quadruple",
            5 => "quintuple",
            6 => "sextuple",
            7 => "septuple",
            8 => "octuple",
            9 => "nonuple",
            10 => "decuple",
            100 => "centuple",
            1000 => "milluple",
            _ => $"{number}-tuple"
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FarsiNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class FarsiNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] FarsiHundredsMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] FarsiTensMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] FarsiUnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

    public override string Convert(long number)
    {
        if (number < 0)
        {
            return $" {Convert(-number)}";
        }

        if (number == 0)
        {
            return "";
        }

        var farsiGroupsMap = new Dictionary<long, Func<long, string>>
        {
            {
                (long) Math.Pow(10, 18), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 15), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 12), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 9), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 6), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 3), n => $"{Convert(n)} "
            },
            {
                (long) Math.Pow(10, 2), n => FarsiHundredsMap[n]
            }
        };

        var parts = new List<string>();
        foreach (var group in farsiGroupsMap.Keys)
        {
            if (number / group > 0)
            {
                parts.Add(farsiGroupsMap[group](number / group));
                number %= group;
            }
        }

        if (number >= 20)
        {
            parts.Add(FarsiTensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(FarsiUnitsMap[number]);
        }

        return string.Join("  ", parts);
    }

    public override string ConvertToOrdinal(int number)
    {
        if (number == 1)
        {
            return "";
        }

        if (number == 3)
        {
            return "";
        }

        if (number % 10 == 3 && number != 13)
        {
            return Convert(number / 10 * 10) + "  ";
        }

        var word = Convert(number);
        return $"{word}{(word.EndsWith("") ? " " : "")}";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FinnishNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class FinnishNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nolla", "yksi", "kaksi", "kolme", "nelj", "viisi", "kuusi", "seitsemn", "kahdeksan", "yhdeksn", "kymmenen"];
    static readonly string[] OrdinalUnitsMap = ["nollas", "ensimminen", "toinen", "kolmas", "neljs", "viides", "kuudes", "seitsems", "kahdeksas", "yhdekss", "kymmenes"];

    static readonly Dictionary<int, string> OrdinalExceptions = new()
    {
        {1, "yhdes" },
        {2, "kahdes" }
    };

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }
        var number = (int)input;

        if (number < 0)
        {
            return $"miinus {Convert(-number)}";
        }

        if (number == 0)
        {
            return UnitsMap[0];
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add(number / 1000000000 == 1
                ? "miljardi "
                : $"{Convert(number / 1000000000)}miljardia ");

            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add(number / 1000000 == 1
                ? "miljoona "
                : $"{Convert(number / 1000000)}miljoonaa ");

            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            parts.Add(number / 1000 == 1
                ? "tuhat "
                : $"{Convert(number / 1000)}tuhatta ");

            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add(number / 100 == 1
                ? "sata"
                : $"{Convert(number / 100)}sataa");

            number %= 100;
        }

        if (number >= 20)
        {
            parts.Add($"{Convert(number / 10)}kymment");
            number %= 10;
        }
        else if (number is > 10 and < 20)
        {
            parts.Add($"{UnitsMap[number % 10]}toista");
        }

        if (number is > 0 and <= 10)
        {
            parts.Add(UnitsMap[number]);
        }

        return string.Concat( parts).Trim();
    }

    static string GetOrdinalUnit(int number, bool useExceptions)
    {
        if (useExceptions && OrdinalExceptions.TryGetValue(number, out var unit))
        {
            return unit;
        }

        return OrdinalUnitsMap[number];
    }

    static string ToOrdinal(int number, bool useExceptions)
    {
        if (number == 0)
        {
            return OrdinalUnitsMap[0];
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add($"{(number / 1000000000 == 1 ? "" : ToOrdinal(number / 1000000000, true))}miljardis");
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add($"{(number / 1000000 == 1 ? "" : ToOrdinal(number / 1000000, true))}miljoonas");
            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            parts.Add($"{(number / 1000 == 1 ? "" : ToOrdinal(number / 1000, true))}tuhannes");
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add($"{(number / 100 == 1 ? "" : ToOrdinal(number / 100, true))}sadas");
            number %= 100;
        }

        if (number >= 20)
        {
            parts.Add($"{ToOrdinal(number / 10, true)}kymmenes");
            number %= 10;
        }
        else if (number is > 10 and < 20)
        {
            parts.Add($"{GetOrdinalUnit(number % 10, true)}toista");
        }

        if (number is > 0 and <= 10)
        {
            parts.Add(GetOrdinalUnit(number, useExceptions));
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number) =>
        ToOrdinal(number, false);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FrenchBelgianNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class FrenchBelgianNumberToWordsConverter : FrenchNumberToWordsConverterBase
{
    protected override void CollectPartsUnderAHundred(ICollection<string> parts, ref long number, GrammaticalGender gender, bool pluralize)
    {
        if (number == 80)
        {
            parts.Add(pluralize ? "quatre-vingts" : "quatre-vingt");
        }
        else if (number == 81)
        {
            parts.Add(gender == GrammaticalGender.Feminine ? "quatre-vingt-une" : "quatre-vingt-un");
        }
        else
        {
            base.CollectPartsUnderAHundred(parts, ref number, gender, pluralize);
        }
    }

    protected override string GetTens(long tens)
    {
        if (tens == 8)
        {
            return "quatre-vingt";
        }

        return base.GetTens(tens);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FrenchNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class FrenchNumberToWordsConverter : FrenchNumberToWordsConverterBase
{
    protected override void CollectPartsUnderAHundred(ICollection<string> parts, ref long number, GrammaticalGender gender, bool pluralize)
    {
        if (number == 71)
        {
            parts.Add("soixante et onze");
        }
        else if (number == 80)
        {
            parts.Add(pluralize ? "quatre-vingts" : "quatre-vingt");
        }
        else if (number >= 70)
        {
            var @base = number < 80 ? 60 : 80;
            var units = number - @base;
            var tens = @base / 10;
            parts.Add($"{GetTens(tens)}-{GetUnits(units, gender)}");
        }
        else
        {
            base.CollectPartsUnderAHundred(parts, ref number, gender, pluralize);
        }
    }

    protected override string GetTens(long tens)
    {
        if (tens == 8)
        {
            return "quatre-vingt";
        }

        return base.GetTens(tens);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FrenchNumberToWordsConverterBase.cs ---


using System.Collections.Generic;

namespace Humanizer;

abstract class FrenchNumberToWordsConverterBase : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["zro", "un", "deux", "trois", "quatre", "cinq", "six", "sept", "huit", "neuf", "dix", "onze", "douze", "treize", "quatorze", "quinze", "seize", "dix-sept", "dix-huit", "dix-neuf"];
    static readonly string[] TensMap = ["zro", "dix", "vingt", "trente", "quarante", "cinquante", "soixante", "septante", "octante", "nonante"];

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return UnitsMap[0];
        }

        var parts = new List<string>();

        if (number < 0)
        {
            parts.Add("moins");
            number = -number;
        }

        CollectParts(parts, ref number, 1000000000000000000, "trillion");
        CollectParts(parts, ref number, 1000000000000000, "billiard");
        CollectParts(parts, ref number, 1000000000000, "billion");
        CollectParts(parts, ref number, 1000000000, "milliard");
        CollectParts(parts, ref number, 1000000, "million");
        CollectThousands(parts, ref number, 1000, "mille");

        CollectPartsUnderAThousand(parts, number, gender, true);

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 1)
        {
            return gender == GrammaticalGender.Feminine ? "premire" : "premier";
        }

        var convertedNumber = Convert(number);

        if (convertedNumber.EndsWith("s") && !convertedNumber.EndsWith("trois"))
        {
            convertedNumber = convertedNumber.TrimEnd('s');
        }
        else if (convertedNumber.EndsWith("cinq"))
        {
            convertedNumber += "u";
        }
        else if (convertedNumber.EndsWith("neuf"))
        {
            convertedNumber = convertedNumber.TrimEnd('f') + "v";
        }

        if (convertedNumber.StartsWith("un "))
        {
            convertedNumber = convertedNumber.Remove(0, 3);
        }

        if (number == 0)
        {
            convertedNumber += "t";
        }

        convertedNumber = convertedNumber.TrimEnd('e');
        convertedNumber += "ime";
        return convertedNumber;
    }

    protected static string GetUnits(long number, GrammaticalGender gender)
    {
        if (number == 1 && gender == GrammaticalGender.Feminine)
        {
            return "une";
        }

        return UnitsMap[number];
    }

    static void CollectHundreds(ICollection<string> parts, ref long number, long d, string form, bool pluralize)
    {
        if (number < d)
        {
            return;
        }

        var result = number / d;
        if (result == 1)
        {
            parts.Add(form);
        }
        else
        {
            parts.Add(GetUnits(result, GrammaticalGender.Masculine));
            if (number % d == 0 && pluralize)
            {
                parts.Add(form + "s");
            }
            else
            {
                parts.Add(form);
            }
        }

        number %= d;
    }

    void CollectParts(ICollection<string> parts, ref long number, long d, string form)
    {
        if (number < d)
        {
            return;
        }

        var result = number / d;

        CollectPartsUnderAThousand(parts, result, GrammaticalGender.Masculine, true);

        if (result == 1)
        {
            parts.Add(form);
        }
        else
        {
            parts.Add(form + "s");
        }

        number %= d;
    }

    void CollectPartsUnderAThousand(ICollection<string> parts, long number, GrammaticalGender gender, bool pluralize)
    {
        CollectHundreds(parts, ref number, 100, "cent", pluralize);

        if (number > 0)
        {
            CollectPartsUnderAHundred(parts, ref number, gender, pluralize);
        }
    }

    void CollectThousands(ICollection<string> parts, ref long number, int d, string form)
    {
        if (number < d)
        {
            return;
        }

        var result = number / d;
        if (result > 1)
        {
            CollectPartsUnderAThousand(parts, result, GrammaticalGender.Masculine, false);
        }

        parts.Add(form);

        number %= d;
    }

    protected virtual void CollectPartsUnderAHundred(ICollection<string> parts, ref long number, GrammaticalGender gender, bool pluralize)
    {
        if (number < 20)
        {
            parts.Add(GetUnits(number, gender));
        }
        else
        {
            var units = number % 10;
            var tens = GetTens(number / 10);
            if (units == 0)
            {
                parts.Add(tens);
            }
            else if (units == 1)
            {
                parts.Add(tens);
                parts.Add("et");
                parts.Add(GetUnits(1, gender));
            }
            else
            {
                parts.Add($"{tens}-{GetUnits(units, gender)}");
            }
        }
    }

    protected virtual string GetTens(long tens) =>
        TensMap[tens];
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\FrenchSwissNumberToWordsConverter.cs ---


namespace Humanizer;

class FrenchSwissNumberToWordsConverter : FrenchNumberToWordsConverterBase;


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GenderedNumberToWordsConverter.cs ---


namespace Humanizer;

abstract class GenderedNumberToWordsConverter : INumberToWordsConverter
{
    readonly GrammaticalGender _defaultGender;

    protected GenderedNumberToWordsConverter(GrammaticalGender defaultGender = GrammaticalGender.Masculine) =>
        _defaultGender = defaultGender;

    /// <inheritdoc/>
    public string Convert(long number) =>
        Convert(number, _defaultGender);

    /// <inheritdoc/>
    public string Convert(long number, WordForm wordForm) =>
        Convert(number, wordForm, _defaultGender);

    /// <inheritdoc/>
    public string Convert(long number, bool addAnd) =>
        Convert(number, _defaultGender);

    /// <inheritdoc/>
    public string Convert(long number, bool addAnd, WordForm wordForm) =>
        Convert(number, wordForm, _defaultGender, addAnd);

    /// <inheritdoc/>
    public abstract string Convert(long number, GrammaticalGender gender, bool addAnd = true);

    /// <inheritdoc/>
    public virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd = true) =>
        Convert(number, gender, addAnd);

    /// <inheritdoc/>
    public string ConvertToOrdinal(int number) =>
        ConvertToOrdinal(number, _defaultGender);

    /// <inheritdoc/>
    public abstract string ConvertToOrdinal(int number, GrammaticalGender gender);

    /// <inheritdoc/>
    public string ConvertToOrdinal(int number, WordForm wordForm) =>
        ConvertToOrdinal(number, _defaultGender, wordForm);

    /// <inheritdoc/>
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm) =>
        ConvertToOrdinal(number, gender);

    /// <inheritdoc/>
    public virtual string ConvertToTuple(int number) =>
        Convert(number);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GenderlessNumberToWordsConverter.cs ---


namespace Humanizer;

abstract class GenderlessNumberToWordsConverter : INumberToWordsConverter
{
    /// <inheritdoc/>
    public abstract string Convert(long number);

    public string Convert(long number, WordForm wordForm) =>
        Convert(number);

    public virtual string Convert(long number, bool addAnd) =>
        Convert(number);

    public string Convert(long number, bool addAnd, WordForm wordForm) =>
        Convert(number, wordForm);

    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd = true) =>
        Convert(number);

    public virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd = true) =>
        Convert(number, addAnd, wordForm);

    public abstract string ConvertToOrdinal(int number);

    public string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        ConvertToOrdinal(number);

    public virtual string ConvertToOrdinal(int number, WordForm wordForm) =>
        ConvertToOrdinal(number);

    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm) =>
        ConvertToOrdinal(number, wordForm);

    public virtual string ConvertToTuple(int number) =>
        Convert(number);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GermanNumberToWordsConverter.cs ---


namespace Humanizer;

class GermanNumberToWordsConverter : GermanNumberToWordsConverterBase;


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GermanNumberToWordsConverterBase.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

abstract class GermanNumberToWordsConverterBase : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["null", "ein", "zwei", "drei", "vier", "fnf", "sechs", "sieben", "acht", "neun", "zehn", "elf", "zwlf", "dreizehn", "vierzehn", "fnfzehn", "sechzehn", "siebzehn", "achtzehn", "neunzehn"];
    static readonly string[] TensMap = ["null", "zehn", "zwanzig", "dreiig", "vierzig", "fnfzig", "sechzig", "siebzig", "achtzig", "neunzig"];
    static readonly string[] UnitsOrdinal = [string.Empty, "ers", "zwei", "drit", "vier", "fnf", "sechs", "sieb", "ach", "neun", "zehn", "elf", "zwlf", "dreizehn", "vierzehn", "fnfzehn", "sechzehn", "siebzehn", "achtzehn", "neunzehn"];
    static readonly string[] HundredOrdinalSingular = ["einhundert"];
    static readonly string[] HundredOrdinalPlural = ["{0}hundert"];
    static readonly string[] ThousandOrdinalSingular = ["eintausend"];
    static readonly string[] ThousandOrdinalPlural = ["{0}tausend"];
    static readonly string[] MillionOrdinalSingular = ["einmillion", "einemillion"];
    static readonly string[] MillionOrdinalPlural = ["{0}million", "{0}millionen"];
    static readonly string[] BillionOrdinalSingular = ["einmilliard", "einemilliarde"];
    static readonly string[] BillionOrdinalPlural = ["{0}milliard", "{0}milliarden"];

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return UnitsMap[number];
        }

        var parts = new List<string>();
        if (number < 0)
        {
            parts.Add("minus ");
            number = -number;
        }

        CollectParts(parts, ref number, 1000000000000000000, true, "{0} Trillionen", "eine Trillion");
        CollectParts(parts, ref number, 1000000000000000, true, "{0} Billiarden", "eine Billiarde");
        CollectParts(parts, ref number, 1000000000000, true, "{0} Billionen", "eine Billion");
        CollectParts(parts, ref number, 1000000000, true, "{0} Milliarden", "eine Milliarde");
        CollectParts(parts, ref number, 1000000, true, "{0} Millionen", "eine Million");
        CollectParts(parts, ref number, 1000, false, "{0}tausend", "eintausend");
        CollectParts(parts, ref number, 100, false, "{0}hundert", "einhundert");

        if (number > 0)
        {
            if (number < 20)
            {
                if (number == 1 && gender == GrammaticalGender.Feminine)
                {
                    parts.Add("eine");
                }
                else
                {
                    parts.Add(UnitsMap[number]);
                }
            }
            else
            {
                var units = number % 10;
                if (units > 0)
                {
                    parts.Add($"{UnitsMap[units]}und");
                }

                parts.Add(GetTens(number / 10));
            }
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return UnitsMap[number] + GetEndingForGender(gender);
        }

        var parts = new List<string>();
        if (number < 0)
        {
            parts.Add("minus ");
            number = -number;
        }

        CollectOrdinalParts(parts, ref number, 1000000000, true, BillionOrdinalPlural, BillionOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 1000000, true, MillionOrdinalPlural, MillionOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 1000, false, ThousandOrdinalPlural, ThousandOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 100, false, HundredOrdinalPlural, HundredOrdinalSingular);

        if (number > 0)
        {
            parts.Add(number < 20 ? UnitsOrdinal[number] : Convert(number));
        }

        if (number is 0 or >= 20)
        {
            parts.Add("s");
        }

        parts.Add(GetEndingForGender(gender));

        return string.Concat(parts);
    }

    void CollectParts(ICollection<string> parts, ref long number, long divisor, bool addSpaceBeforeNextPart, string pluralFormat, string singular)
    {
        if (number / divisor > 0)
        {
            parts.Add(Part(pluralFormat, singular, number / divisor));
            number %= divisor;
            if (addSpaceBeforeNextPart && number > 0)
            {
                parts.Add(" ");
            }
        }
    }

    void CollectOrdinalParts(ICollection<string> parts, ref int number, int divisor, bool evaluateNoRest, string[] pluralFormats, string[] singulars)
    {
        if (number / divisor > 0)
        {
            var noRest = evaluateNoRest ? NoRestIndex(number % divisor) : 0;
            parts.Add(Part(pluralFormats[noRest], singulars[noRest], number / divisor));
            number %= divisor;
        }
    }

    string Part(string pluralFormat, string singular, long number)
    {
        if (number == 1)
        {
            return singular;
        }

        return string.Format(pluralFormat, Convert(number));
    }

    static int NoRestIndex(int number) =>
        number == 0 ? 0 : 1;

    static string GetEndingForGender(GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => "ter",
            GrammaticalGender.Feminine => "te",
            GrammaticalGender.Neuter => "tes",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };

    protected virtual string GetTens(long tens) =>
        TensMap[tens];
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GermanSwissLiechtensteinNumberToWordsConverter.cs ---


namespace Humanizer;

class GermanSwissLiechtensteinNumberToWordsConverter : GermanNumberToWordsConverterBase
{
    protected override string GetTens(long tens)
    {
        if (tens == 3)
        {
            return "dreissig";
        }

        return base.GetTens(tens);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\GreekNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class GreekNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitMap = ["", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensNoDiacriticsMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] HundredMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] HundredsMap = ["", "", "", "", "", "", "", "", "", ""];

    static readonly Dictionary<long, string> rdinalMap = new()
    {
        {
            0, string.Empty
        },
        {
            1, ""
        },
        {
            2, ""
        },
        {
            3, ""
        },
        {
            4, ""
        },
        {
            5, ""
        },
        {
            6, ""
        },
        {
            7, ""
        },
        {
            8, ""
        },
        {
            9, ""
        },
        {
            10, ""
        },
        {
            20, ""
        },
        {
            30, ""
        },
        {
            40, ""
        },
        {
            50, ""
        },
        {
            60, ""
        },
        {
            70, ""
        },
        {
            80, ""
        },
        {
            90, ""
        },
        {
            100, ""
        },
        {
            200, ""
        },
        {
            300, ""
        },
        {
            400, ""
        },
        {
            500, ""
        },
        {
            600, ""
        },
        {
            700, ""
        },
        {
            800, ""
        },
        {
            900, ""
        },
        {
            1000, ""
        }
    };

    public override string Convert(long number) =>
        ConvertImpl(number, false);

    public override string ConvertToOrdinal(int number)
    {
        if (number / 10 == 0)
        {
            return GetOneDigitOrdinal(number);
        }

        if (number / 10 > 0 && number / 10 < 10)
        {
            return GetTwoDigitOrdinal(number);

        }

        if (number / 100 > 0 && number / 100 < 10)
        {
            return GetThreeDigitOrdinal(number);
        }

        if (number / 1000 > 0 && number / 1000 < 10)
        {
            return GetFourDigitOrdinal(number);
        }

        return string.Empty;
    }

    static string GetOneDigitOrdinal(int number)
    {
        if (rdinalMap.TryGetValue(number, out var output))
        {
            return output;
        }

        return string.Empty;
    }

    static string GetTwoDigitOrdinal(int number)
    {
        if (number == 11) return "";
        if (number == 12) return "";

        var decades = number / 10;

        if (!rdinalMap.TryGetValue(decades * 10, out var decadesString)) return string.Empty;

        if (number - decades * 10 > 0)
        {
            return decadesString + " " + GetOneDigitOrdinal(number - decades * 10);
        }

        return decadesString;
    }

    static string GetThreeDigitOrdinal(int number)
    {
        var hundreds = number / 100;

        if (!rdinalMap.TryGetValue(hundreds * 100, out var hundredsString)) return string.Empty;

        if (number - hundreds * 100 > 10)
        {
            return hundredsString + " " + GetTwoDigitOrdinal(number - hundreds * 100);
        }

        if (number - hundreds * 100 > 0)
        {
            return hundredsString + " " + GetOneDigitOrdinal(number - hundreds * 100);
        }

        return hundredsString;
    }

    static string GetFourDigitOrdinal(int number)
    {
        var thousands = number / 1000;

        if (!rdinalMap.TryGetValue(thousands * 1000, out var thousandsString)) return string.Empty;

        if (number - thousands * 1000 > 100)
        {
            return thousandsString + " " + GetThreeDigitOrdinal(number - thousands * 1000);
        }

        if (number - thousands * 1000 > 10)
        {
            return thousandsString + " " + GetTwoDigitOrdinal(number - thousands * 1000);
        }

        if (number - thousands * 1000 > 0)
        {
            return thousandsString + " " + GetOneDigitOrdinal(number - thousands * 1000);
        }

        return thousandsString;
    }

    string ConvertImpl(long number, bool returnPluralized)
    {
        if (number < 13)
        {
            return ConvertIntB13(number, returnPluralized);
        }

        if (number < 100)
        {
            return ConvertIntBH(number, returnPluralized);
        }

        if (number < 1000)
        {
            return ConvertIntBT(number, returnPluralized);
        }

        if (number < 1000000)
        {
            return ConvertIntBM(number);
        }

        if (number < 1000000000)
        {
            return ConvertIntBB(number);
        }

        if (number < 1000000000000)
        {
            return ConvertIntBTR(number);
        }

        return "";
    }

    static string ConvertIntB13(long number, bool returnPluralized) =>
        returnPluralized ? UnitsMap[number] : UnitMap[number];

    string ConvertIntBH(long number, bool returnPluralized)
    {
        var result = number / 10 == 1 ? TensNoDiacriticsMap[number / 10] : TensMap[number / 10];

        if (number % 10 != 0)
        {
            if (number / 10 != 1)
            {
                result += " ";
            }

            result += ConvertImpl(number % 10, returnPluralized)
                .ToLower();
        }

        return result;
    }

    string ConvertIntBT(long number, bool returnPluralized)
    {
        string result;

        if (number / 100 == 1)
        {
            if (number % 100 == 0)
            {
                return HundredMap[number / 100];
            }

            result = HundredsMap[number / 100];
        }
        else
        {
            result = returnPluralized ? HundredsMap[number / 100] : HundredMap[number / 100];
        }

        if (number % 100 != 0)
        {
            result += $" {ConvertImpl(number % 100, returnPluralized).ToLower()}";
        }

        return result;
    }

    string ConvertIntBM(long number)
    {
        if (number / 1000 == 1)
        {
            if (number % 1000 == 0)
            {
                return "";
            }

            return $" {ConvertImpl(number % 1000, false).ToLower()}";
        }

        var result = $"{ConvertImpl(number / 1000, true)} ";

        if (number % 1000 != 0)
        {
            result += $" {ConvertImpl(number % 1000, false).ToLower()}";
        }

        return result;
    }

    string ConvertIntBB(long number)
    {
        if (number / 1000000 == 1)
        {
            if (number % 1000000 == 0)
            {
                return " ";
            }

            return $"  {ConvertImpl(number % 1000000, true).ToLower()}";
        }

        var result = $"{ConvertImpl(number / 1000000, false)} ";

        if (number % 1000000 != 0)
        {
            result += $" {ConvertImpl(number % 1000000, false).ToLower()}";
        }

        return result;
    }

    string ConvertIntBTR(long number)
    {
        if (number / 1000000000 == 1)
        {
            if (number % 1000000000 == 0)
            {
                return " ";
            }

            return $"  {ConvertImpl(number % 1000000000, true).ToLower()}";
        }

        var result = $"{ConvertImpl(number / 1000000000, false)} ";

        if (number % 1000000000 != 0)
        {
            result += $" {ConvertImpl(number % 1000000000, false).ToLower()}";
        }

        return result;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\HebrewNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class HebrewNumberToWordsConverter(CultureInfo culture) :
    GenderedNumberToWordsConverter(GrammaticalGender.Feminine)
{
    static readonly string[] UnitsFeminine = ["", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsMasculine = ["", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensUnit = ["", "", "", "", "", "", "", "", ""];

    class DescriptionAttribute(string description) :
        Attribute
    {
        public string Description { get; set; } = description;
    }

    enum Group
    {
        Hundreds = 100,
        Thousands = 1000,

        [Description("")]
        Millions = 1000000,

        [Description("")]
        Billions = 1000000000
    }

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;

        if (number < 0)
        {
            return $" {Convert(-number, gender)}";
        }

        if (number == 0)
        {
            return UnitsFeminine[0];
        }

        var parts = new List<string>();
        if (number >= (int) Group.Billions)
        {
            ToBigNumber(number, Group.Billions, parts);
            number %= (int) Group.Billions;
        }

        if (number >= (int) Group.Millions)
        {
            ToBigNumber(number, Group.Millions, parts);
            number %= (int) Group.Millions;
        }

        if (number >= (int) Group.Thousands)
        {
            ToThousands(number, parts);
            number %= (int) Group.Thousands;
        }

        if (number >= (int) Group.Hundreds)
        {
            ToHundreds(number, parts);
            number %= (int) Group.Hundreds;
        }

        if (number > 0)
        {
            var appendAnd = parts.Count != 0;

            if (number <= 10)
            {
                var unit = gender == GrammaticalGender.Masculine ? UnitsMasculine[number] : UnitsFeminine[number];
                if (appendAnd)
                {
                    unit = "" + unit;
                }

                parts.Add(unit);
            }
            else if (number < 20)
            {
                var unit = Convert(number % 10, gender);
                unit = unit.Replace("", "");
                unit = $"{unit} {(gender == GrammaticalGender.Masculine ? "" : "")}";
                if (appendAnd)
                {
                    unit = "" + unit;
                }

                parts.Add(unit);
            }
            else
            {
                var tenUnit = TensUnit[number / 10 - 1];
                if (number % 10 == 0)
                {
                    parts.Add(tenUnit);
                }
                else
                {
                    var unit = Convert(number % 10, gender);
                    parts.Add($"{tenUnit} {unit}");
                }
            }
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        number.ToString(culture);

    void ToBigNumber(int number, Group group, List<string> parts)
    {
        // Big numbers (million and above) always use the masculine form
        // See https://www.safa-ivrit.org/dikduk/numbers.php

        var digits = number / (int) group;
        if (digits == 2)
        {
            parts.Add("");
        }
        else if (digits > 2)
        {
            parts.Add(Convert(digits, GrammaticalGender.Masculine));
        }

        parts.Add(group.Humanize());
    }

    void ToThousands(int number, List<string> parts)
    {
        var thousands = number / (int) Group.Thousands;

        if (thousands == 1)
        {
            parts.Add("");
        }
        else if (thousands == 2)
        {
            parts.Add("");
        }
        else if (thousands == 8)
        {
            parts.Add(" ");
        }
        else if (thousands <= 10)
        {
            parts.Add(UnitsFeminine[thousands] + "" + " ");
        }
        else
        {
            parts.Add(Convert(thousands) + " ");
        }
    }

    static void ToHundreds(int number, List<string> parts)
    {
        // For hundreds, Hebrew is using the feminine form
        // See https://www.safa-ivrit.org/dikduk/numbers.php

        var hundreds = number / (int) Group.Hundreds;

        if (hundreds == 1)
        {
            parts.Add("");
        }
        else if (hundreds == 2)
        {
            parts.Add("");
        }
        else
        {
            parts.Add(UnitsFeminine[hundreds] + " ");
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\IcelandicNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

class IcelandicNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nll", string.Empty, string.Empty, string.Empty, string.Empty, "fimm", "sex", "sj", "tta", "nu", "tu", "ellefu", "tlf", "rettn", "fjrtn", "fimmtn", "sextn", "sautjn", "tjn", "ntjn"];
    static readonly string[] FeminineUnitsMap = [string.Empty, "ein", "tvr", "rjr", "fjrar"];
    static readonly string[] MasculineUnitsMap = [string.Empty, "einn", "tveir", "rr", "fjrir"];
    static readonly string[] NeuterUnitsMap = [string.Empty, "eitt", "tv", "rj", "fjgur"];
    static readonly string[] TensMap = [string.Empty, "tu", "tuttugu", "rjtu", "fjrutu", "fimmtu", "sextu", "sjtu", "ttatu", "nutu"];
    static readonly string[] UnitsOrdinalPrefixes = ["nllt", "fyrst", string.Empty, "rij", "fjr", "fimmt", "sjtt", "sjund", "ttund", "nund", "tund", "elleft", "tlft", "rettnd", "fjrtnd", "fimmtnd", "sextnd", "sautjnd", "tjnd", "ntjnd"];
    static readonly string[] TensOrdinalPrefixes = [string.Empty, "tund", "tuttugast", "rtugast", "fertugast", "fimmtugast", "sextugast", "sjtugast", "ttugast", "ntugast"];
    const string AndSplit = "og";

    class Fact
    {
        public long Power { get; set; }
        public GrammaticalGender Gender { get; set; }
        public required string Plural { get; set; }
        public required string Single { get; set; }
        public required string OrdinalPrefix { get; set; }
    }

    static readonly Dictionary<int, Fact> PowerOfTenMap = new()
    {
        {
            0, new()
            {
                Power = 0,
                Single = string.Empty,
                Plural = string.Empty,
                OrdinalPrefix = string.Empty,
                Gender = GrammaticalGender.Neuter
            }
        },
        {
            2, new()
            {
                Power = 2,
                Single = "hundra",
                Plural = "hundru",
                OrdinalPrefix = "hundruast",
                Gender = GrammaticalGender.Neuter
            }
        },
        {
            3, new()
            {
                Power = 1000,
                Single = "eitt sund",
                Plural = "sund",
                OrdinalPrefix = "sundast",
                Gender = GrammaticalGender.Neuter
            }
        },
        {
            6, new()
            {
                Power = 1000000,
                Single = "ein milljn",
                Plural = "milljnir",
                OrdinalPrefix = "milljnast",
                Gender = GrammaticalGender.Feminine
            }
        },
        {
            9, new()
            {
                Power = 1000000000,
                Single = "einn milljarur",
                Plural = "milljarar",
                OrdinalPrefix = "milljarast",
                Gender = GrammaticalGender.Masculine
            }
        },
        {
            12, new()
            {
                Power = 1000000000000,
                Single = "ein billjn",
                Plural = "billjnir",
                OrdinalPrefix = "billjnast",
                Gender = GrammaticalGender.Feminine
            }
        },
        {
            15, new()
            {
                Power = 1000000000000000,
                Single = "einn billjarur",
                Plural = "billjarar",
                OrdinalPrefix = "billjarast",
                Gender = GrammaticalGender.Masculine
            }
        },
        {
            18, new()
            {
                Power = 1000000000000000000,
                Single = "ein trilljn",
                Plural = "trilljnir",
                OrdinalPrefix = "trilljnast",
                Gender = GrammaticalGender.Feminine
            }
        }
    };

    static bool IsAndSplitNeeded(int number) =>
        number <= 20 || number % 10 == 0 && number < 100 || number % 100 == 0;

    static string GetOrdinalEnding(GrammaticalGender gender) =>
        gender == GrammaticalGender.Masculine ? "i" : "a";

    static void GetUnits(ICollection<string?> builder, long number, GrammaticalGender gender)
    {
        if (number is > 0 and < 5)
        {
            var genderedForm = gender switch
            {
                GrammaticalGender.Masculine => MasculineUnitsMap[number],
                GrammaticalGender.Neuter => NeuterUnitsMap[number],
                GrammaticalGender.Feminine => FeminineUnitsMap[number],
                _ => throw new ArgumentOutOfRangeException(nameof(gender))
            };
            builder.Add(genderedForm);
        }
        else
        {
            builder.Add(UnitsMap[number]);
        }
    }

    static void CollectOrdinalParts(ICollection<string?> builder, int threeDigitPart, Fact conversionRule, GrammaticalGender partGender, GrammaticalGender ordinalGender)
    {
        var hundreds = threeDigitPart / 100;
        var hundredRemainder = threeDigitPart % 100;
        var units = hundredRemainder % 10;
        var decade = hundredRemainder / 10 * 10;
        var hasThousand = conversionRule.Power > 100;

        if (hundreds != 0)
        {
            GetUnits(builder, hundreds, GrammaticalGender.Neuter);
            var hundredPrefix = hundreds == 1 ? PowerOfTenMap[2].Single : PowerOfTenMap[2].Plural;
            if (hundredRemainder < 20 && false == hasThousand)
            {
                var genderedFormWithPostfix = partGender switch
                {
                    GrammaticalGender.Masculine => hundredPrefix + "asti",
                    GrammaticalGender.Neuter => hundredPrefix + "asta",
                    GrammaticalGender.Feminine => hundredPrefix + "asta",
                    _ => throw new ArgumentOutOfRangeException(nameof(partGender))
                };
                builder.Add(genderedFormWithPostfix);
            }
            else
            {
                builder.Add(hundredPrefix);
            }
        }

        if (decade >= 20)
        {
            if (units != 0)
            {
                builder.Add(CollectOrdinalPartsUnderAHundred(decade, partGender));
                builder.Add(AndSplit);
                builder.Add(CollectOrdinalPartsUnderAHundred(units, partGender));
            }
            else
            {
                if (hundreds != 0)
                {
                    builder.Add(AndSplit);
                }

                builder.Add(CollectOrdinalPartsUnderAHundred(decade, partGender));
            }
        }
        else if (hundredRemainder != 0)
        {
            if (hundreds != 0)
            {
                builder.Add(AndSplit);
            }

            if (hasThousand)
            {
                GetUnits(builder, hundredRemainder, conversionRule.Gender);
            }
            else
            {
                builder.Add(CollectOrdinalPartsUnderAHundred(hundredRemainder, partGender));
            }
        }

        if (hasThousand)
        {
            builder.Add(conversionRule.OrdinalPrefix + GetOrdinalEnding(ordinalGender));
        }
    }

    static string? CollectOrdinalPartsUnderAHundred(int number, GrammaticalGender gender)
    {
        if (number is >= 0 and < 20)
        {
            if (number == 2)
            {
                return gender switch
                {
                    GrammaticalGender.Masculine => "annar",
                    GrammaticalGender.Feminine => "nnur",
                    GrammaticalGender.Neuter => "anna",
                    _ => throw new ArgumentOutOfRangeException(nameof(gender))
                };
            }

            return UnitsOrdinalPrefixes[number] + GetOrdinalEnding(gender);
        }

        if (number < 100 && number % 10 == 0)
        {
            return TensOrdinalPrefixes[number / 10] + GetOrdinalEnding(gender);
        }

        return null;
    }

    static void CollectParts(IList<string?> parts, ref long number, ref bool needsAnd, Fact rule)
    {
        var remainder = number / rule.Power;
        if (remainder > 0)
        {
            number %= rule.Power;
            var prevLen = parts.Count;
            CollectPart(parts, remainder, rule);
            if (number == 0 && needsAnd && false == parts
                    .Skip(prevLen)
                    .Contains(AndSplit))
            {
                parts.Insert(prevLen, AndSplit);
            }

            needsAnd = true;
        }
    }

    static void CollectPart(ICollection<string?> parts, long number, Fact rule)
    {
        if (number == 1)
        {
            parts.Add(rule.Single);
        }
        else
        {
            CollectPartUnderOneThousand(parts, number, rule.Gender);
            parts.Add(rule.Plural);
        }
    }

    static void CollectPartUnderOneThousand(ICollection<string?> builder, long number, GrammaticalGender gender)
    {
        var hundreds = number / 100;
        var hundredRemainder = number % 100;
        var units = hundredRemainder % 10;
        var tens = hundredRemainder / 10;

        if (hundreds != 0)
        {
            GetUnits(builder, hundreds, GrammaticalGender.Neuter);
            builder.Add(hundreds == 1 ? PowerOfTenMap[2].Single : PowerOfTenMap[2].Plural);
        }

        if (tens >= 2)
        {
            if (units != 0)
            {
                builder.Add(TensMap[tens]);
                builder.Add(AndSplit);
                GetUnits(builder, units, gender);
            }
            else
            {
                if (hundreds != 0)
                {
                    builder.Add(AndSplit);
                }

                builder.Add(TensMap[tens]);

            }
        }
        else if (hundredRemainder != 0)
        {
            if (hundreds != 0)
            {
                builder.Add(AndSplit);
            }

            GetUnits(builder, hundredRemainder, gender);
        }
    }

    static void CollectOrdinal(IList<string?> parts, ref int number, ref bool needsAnd, Fact rule, GrammaticalGender gender)
    {
        var remainder = number / rule.Power;
        if (remainder > 0)
        {
            number %= (int) rule.Power;

            // https://malfar.arnastofnun.is/grein/65658
            if (number > 0 && (number > 19 || (number % 100 > 10 && number % 100 % 10 == 0)))
            {
                if (remainder == 1)
                {
                    parts.Add(rule.Single);
                }
                else
                {
                    CollectPartUnderOneThousand(parts, remainder, rule.Gender);
                    if (rule.Power > 0)
                    {
                        parts.Add(rule.Plural);
                    }
                }
            }
            else
            {
                var prevLen = parts.Count;
                CollectOrdinalParts(parts, (int) remainder, rule, rule.Gender, gender);
                if (number == 0 && needsAnd && false == parts
                        .Skip(prevLen)
                        .Contains(AndSplit))
                {
                    parts.Insert(prevLen, AndSplit);
                }
            }

            needsAnd = true;
        }
    }

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return UnitsMap[number];
        }

        var parts = new List<string?>();
        if (number < 0)
        {
            parts.Add("mnus");
            number = -number;
        }

        var needsAnd = false;
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[18]);
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[15]);
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[12]);
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[9]);
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[6]);
        CollectParts(parts, ref number, ref needsAnd, PowerOfTenMap[3]);

        if (number > 0)
        {
            if (needsAnd && IsAndSplitNeeded((int) number))
            {
                parts.Add(AndSplit);
            }

            CollectPartUnderOneThousand(parts, number, gender);
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return UnitsOrdinalPrefixes[number] + GetOrdinalEnding(gender);
        }

        var parts = new List<string?>();
        var needsAnd = false;

        CollectOrdinal(parts, ref number, ref needsAnd, PowerOfTenMap[12], gender);
        CollectOrdinal(parts, ref number, ref needsAnd, PowerOfTenMap[9], gender);
        CollectOrdinal(parts, ref number, ref needsAnd, PowerOfTenMap[6], gender);
        CollectOrdinal(parts, ref number, ref needsAnd, PowerOfTenMap[3], gender);

        if (number > 0)
        {
            if (needsAnd && IsAndSplitNeeded(number))
            {
                parts.Add(AndSplit);
            }

            CollectOrdinalParts(parts, number, PowerOfTenMap[0], gender, gender);
        }

        return string.Join(" ", parts);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\IndianNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class IndianNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly Dictionary<long, string> OrdinalExceptions = new()
    {
        {
            1, "first"
        },
        {
            2, "second"
        },
        {
            3, "third"
        },
        {
            4, "fourth"
        },
        {
            5, "fifth"
        },
        {
            8, "eighth"
        },
        {
            9, "ninth"
        },
        {
            12, "twelfth"
        },
    };

    static readonly string[] Tillnineteen =
    [
        "one", "two", "three", "four", "five", "six", "seven", "eight",
        "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen",
        "seventeen", "eighteen", "nineteen"
    ];

    static readonly string[] Tens =
    [
        "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
        "eighty", "ninety"
    ];

    public override string Convert(long number) =>
        NumberToText(number)
            .Trim();

    public override string ConvertToOrdinal(int number)
    {
        var result = NumberToText(number)
            .Trim();
        return result;
    }

    static string NumberToText(long number)
    {
        if (number < 0)
            return "(Negative) " + NumberToText(-number);
        if (number == 0)
            return "";
        if (number <= 19)
            return Tillnineteen[number - 1] + " ";
        if (number <= 99)
            return Tens[number / 10 - 2] + " " + NumberToText(number % 10);
        if (number <= 199)
            return ("one hundred " + (number % 100 > 0 ? "and " : "") + NumberToText(number % 100)).Trim();
        if (number <= 999)
            return NumberToText(number / 100) + "hundred " + (number % 100 > 0 ? "and " : "") + NumberToText(number % 100);
        if (number <= 1999)
            return "one thousand " + NumberToText(number % 1000);
        if (number <= 99999)
            return NumberToText(number / 1000) + "thousand " + NumberToText(number % 1000);
        if (number <= 199999)
            return ("one lakh " + NumberToText(number % 100000)).Trim();
        if (number <= 9999999)
            return NumberToText(number / 100000) + "lakh " + NumberToText(number % 100000);
        if (number <= 19999999)
            return "one crore " + NumberToText(number % 10000000);
        return NumberToText(number / 10000000)
            .Trim() + " crore " + NumberToText(number % 10000000);
    }

    static bool ExceptionNumbersToWords(long number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\INumberToWordsConverter.cs ---


namespace Humanizer;

/// <summary>
/// An interface you should implement to localise ToWords and ToOrdinalWords methods
/// </summary>
public interface INumberToWordsConverter
{
    /// <summary>
    /// Converts the number to string using the locale's default grammatical gender
    /// </summary>
    string Convert(long number);

    /// <summary>
    /// Converts the number to a specific string form using the locale's default grammatical gender.
    /// </summary>
    string Convert(long number, WordForm wordForm);

    /// <summary>
    /// Converts the number to string using the locale's default grammatical gender with or without adding 'And'
    /// </summary>
    /// <param name="addAnd">Specify with our without adding "And"</param>
    string Convert(long number, bool addAnd);

    /// <summary>
    /// Converts the number to a specific string form using the locale's default grammatical gender with or without adding 'And'
    /// </summary>
    string Convert(long number, bool addAnd, WordForm wordForm);

    /// <summary>
    /// Converts the number to string using the provided grammatical gender
    /// </summary>
    string Convert(long number, GrammaticalGender gender, bool addAnd = true);

    /// <summary>
    /// Converts the number to a specific string form using the provided grammatical gender.
    /// </summary>
    string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd = true);

    /// <summary>
    /// Converts the number to ordinal string using the locale's default grammatical gender
    /// </summary>
    string ConvertToOrdinal(int number);

    /// <summary>
    /// Converts the number to a specific ordinal string form using the locale's default grammatical gender.
    /// </summary>
    string ConvertToOrdinal(int number, WordForm wordForm);

    /// <summary>
    /// Converts the number to ordinal string using the provided grammatical gender
    /// </summary>
    string ConvertToOrdinal(int number, GrammaticalGender gender);

    /// <summary>
    /// Converts the number to a specific ordinal string form using the provided grammatical gender.
    /// </summary>
    string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm);

    /// <summary>
    /// Converts integer to named tuple (e.g. 'single', 'double' etc.).
    /// </summary>
    string ConvertToTuple(int number);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\ItalianNumberToWordsConverter.cs ---


using System;

namespace Humanizer;

class ItalianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;

        if (number < 0)
        {
            return "meno " + Convert(Math.Abs(number), gender);
        }

        var cruncher = new ItalianCardinalNumberCruncher(number, gender);

        return cruncher.Convert();
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        var cruncher = new ItalianOrdinalNumberCruncher(number, gender);

        return cruncher.Convert();
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\JapaneseNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class JapaneseNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap1 = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsMap2 = ["", "", "", ""];

    static readonly string[] UnitsMap3 =
    [
        "", "", "", "", "", "", "", "", "", "", "", "", "",
        "", "", "", "", ""
    ];

    public override string Convert(long number) =>
        ConvertImpl(number, false);

    public override string ConvertToOrdinal(int number) =>
        ConvertImpl(number, true);

    static string ConvertImpl(long number, bool isOrdinal)
    {
        if (number == 0)
        {
            return isOrdinal ? "" : "";
        }

        if (number < 0)
        {
            return $" {ConvertImpl(-number, false)}";
        }

        var parts = new List<string>();
        var groupLevel = 0;
        while (number > 0)
        {
            var groupNumber = number % 10000;
            number /= 10000;

            var n0 = groupNumber % 10;
            var n1 = (groupNumber % 100 - groupNumber % 10) / 10;
            var n2 = (groupNumber % 1000 - groupNumber % 100) / 100;
            var n3 = (groupNumber - groupNumber % 1000) / 1000;

            parts.Add(
                UnitsMap1[n3] + (n3 == 0 ? "" : UnitsMap2[3])
                              + UnitsMap1[n2] + (n2 == 0 ? "" : UnitsMap2[2])
                              + UnitsMap1[n1] + (n1 == 0 ? "" : UnitsMap2[1])
                              + (n0 == 1 ? "" : UnitsMap1[n0])
                              + (groupNumber == 0 ? "" : UnitsMap3[groupLevel])
            );

            groupLevel++;
        }

        parts.Reverse();
        var toWords = string.Concat(parts);

        if (isOrdinal)
        {
            toWords = $"{toWords}";
        }

        return toWords;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\KoreanNumberToWordsConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class KoreanNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap1 = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsMap2 = ["", "", "", ""];
    static readonly string[] UnitsMap3 = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

    static readonly Dictionary<long, string> OrdinalExceptions = new()
    {
        {
            0, ""
        },
        {
            1, ""
        },
        {
            2, ""
        },
        {
            3, ""
        },
        {
            4, ""
        },
        {
            5, ""
        },
        {
            6, ""
        },
        {
            7, ""
        },
        {
            8, ""
        },
        {
            9, ""
        },
        {
            10, ""
        },
        {
            11, ""
        },
        {
            12, ""
        },
        {
            13, ""
        },
        {
            14, ""
        },
        {
            15, ""
        },
        {
            16, ""
        },
        {
            17, ""
        },
        {
            18, ""
        },
        {
            19, ""
        },
    };

    public override string Convert(long number) =>
        ConvertImpl(number, false);

    public override string ConvertToOrdinal(int number) =>
        ConvertImpl(number, true);

    static string ConvertImpl(long number, bool isOrdinal)
    {
        if (isOrdinal && number < 20)
        {
            if (OrdinalExceptions.TryGetValue(number, out var words))
                return words;
        }

        if (number == 0)
        {
            return "";
        }

        if (number < 0)
        {
            return $" {ConvertImpl(-number, false)}";
        }

        var parts = new List<string>();
        var groupLevel = 0;
        while (number > 0)
        {
            var groupNumber = number % 10000;
            number /= 10000;

            var n0 = groupNumber % 10;
            var n1 = (groupNumber % 100 - groupNumber % 10) / 10;
            var n2 = (groupNumber % 1000 - groupNumber % 100) / 100;
            var n3 = (groupNumber - groupNumber % 1000) / 1000;

            parts.Add(
                UnitsMap1[n3] + (n3 == 0 ? "" : UnitsMap2[3])
                              + UnitsMap1[n2] + (n2 == 0 ? "" : UnitsMap2[2])
                              + UnitsMap1[n1] + (n1 == 0 ? "" : UnitsMap2[1])
                              + (n0 == 1 ? "" : UnitsMap1[n0])
                              + (groupNumber == 0 ? "" : UnitsMap3[groupLevel])
            );

            groupLevel++;
        }

        parts.Reverse();
        var toWords = string.Concat(parts);

        if (isOrdinal)
        {
            toWords = $"{toWords}";
        }

        return toWords;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\LatvianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class LatvianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nulle", "vien", "div", "trs", "etr", "piec", "se", "septi", "asto", "devi", "desmit", "vienpadsmit", "divpadsmit", "trspadsmit", "etrpadsmit", "piecpadsmit", "sepadsmit", "septipadsmit", "astopadsmit", "devipadsmit"];
    static readonly string[] TensMap = ["nulle", "desmit", "divdesmit", "trsdesmit", "etrdesmit", "piecdesmit", "sedesmit", "septidesmit", "astodesmit", "devidesmit"];
    static readonly string[] HundredsMap = ["nulle", "simt", "divsimt", "trssimt", "etrsimt", "piecsimt", "sesimt", "septisimt", "astosimt", "devisimt"];
    static readonly string[] UnitsOrdinal = [string.Empty, "pirm", "otr", "tre", "ceturt", "piekt", "sest", "septt", "astot", "devt", "desmit", "vienpadsmit", "divpadsmit", "trspadsmit", "etrpadsmit", "piecpadsmit", "sepadsmit", "septipadsmit", "astopadsmit", "devipadsmit", "divdesmit"];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var parts = new List<string>();

        if (input / 1000000 > 0)
        {
            string millionPart;
            if (input == 1000000)
            {
                millionPart = "miljons";
            }
            else
            {
                millionPart = Convert(input / 1000000, GrammaticalGender.Masculine) + " miljoni";
            }
            input %= 1000000;
            parts.Add(millionPart);
        }

        if (input / 1000 > 0)
        {
            string thousandsPart;
            if (input == 1000)
            {
                thousandsPart = "tkstotis";
            }
            else if (input is > 1000 and < 2000)
            {
                thousandsPart = "tksto";
            }
            else
            {
                thousandsPart = Convert(input / 1000, GrammaticalGender.Masculine) + " tkstoi";
            }
            parts.Add(thousandsPart);
            input %= 1000;
        }

        if (input / 100 > 0)
        {
            string hundredsPart;
            if (input == 100)
            {
                hundredsPart = parts.Contains("tksto") ? "viens simts" : "simts";
            }
            else if (input is > 100 and < 200)
            {
                hundredsPart = "simtu";
            }
            else
            {
                hundredsPart = Convert(input / 100, GrammaticalGender.Masculine) + " simti";
            }
            parts.Add(hundredsPart);
            input %= 100;
        }

        if (input > 19)
        {
            var tensPart = TensMap[input / 10];
            parts.Add(tensPart);
            input %= 10;
        }

        if (input > 0)
        {
            parts.Add(UnitsMap[input] + GetCardinalEndingForGender(gender, input));
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int input, GrammaticalGender gender)
    {
        if (input == 0)
        {
            return "nulle";
        }

        var parts = new List<string>();

        if (input < 0)
        {
            parts.Add("mnus");
            input = -input;
        }

        if (input / 1000000 > 0)
        {
            string millionPart;
            if (input == 1000000)
            {
                millionPart = "miljon" + GetOrdinalEndingForGender(gender);
            }
            else
            {
                millionPart = Convert(input / 1000000, GrammaticalGender.Masculine) + " miljon" + GetOrdinalEndingForGender(gender);
            }
            input %= 1000000;
            parts.Add(millionPart);
        }

        if (input / 1000 > 0)
        {
            string thousandsPart;
            if (input % 1000 == 0)
            {
                if (input == 1000)
                {
                    thousandsPart = "tksto" + GetOrdinalEndingForGender(gender);
                }
                else
                {
                    thousandsPart = Convert(input / 1000, GrammaticalGender.Masculine) + " tksto" + GetOrdinalEndingForGender(gender);
                }
            }
            else
            {
                if (input is > 1000 and < 2000)
                {
                    thousandsPart = "tksto";
                }
                else
                {
                    thousandsPart = Convert(input / 1000, GrammaticalGender.Masculine) + " tkstoi";
                }
            }
            parts.Add(thousandsPart);
            input %= 1000;
        }

        if (input / 100 > 0)
        {
            string hundredsPart;
            if (input % 100 == 0)
            {
                hundredsPart = HundredsMap[input / 100] + GetOrdinalEndingForGender(gender);
            }
            else
            {
                if (input is > 100 and < 200)
                {
                    hundredsPart = "simtu";
                }
                else
                {
                    hundredsPart = Convert(input / 100, GrammaticalGender.Masculine) + " simti";
                }
            }
            parts.Add(hundredsPart);
            input %= 100;
        }

        if (input > 19)
        {
            var tensPart = TensMap[input / 10];
            if (input % 10 == 0)
            {
                tensPart += GetOrdinalEndingForGender(gender);
            }
            parts.Add(tensPart);
            input %= 10;
        }

        if (input > 0)
        {
            parts.Add(UnitsOrdinal[input] + GetOrdinalEndingForGender(gender));
        }

        return string.Join(" ", parts);
    }

    static string GetOrdinalEndingForGender(GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => "ais",
            GrammaticalGender.Feminine => "",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };

    static string GetCardinalEndingForGender(GrammaticalGender gender, long number)
    {
        switch (gender)
        {
            case GrammaticalGender.Masculine:
                if (number == 1)
                {
                    return "s";
                }

                if (number != 3 && number < 10)
                {
                    return "i";
                }

                return "";
            case GrammaticalGender.Feminine:
                if (number == 1)
                {
                    return "a";
                }

                if (number != 3 && number < 10)
                {
                    return "as";
                }

                return "";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\LithuanianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class LithuanianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nulis", "vienas", "du", "trys", "keturi", "penki", "ei", "septyni", "atuoni", "devyni", "deimt", "vienuolika", "dvylika", "trylika", "keturiolika", "penkiolika", "eiolika", "septyniolika", "atuoniolika", "devyniolika"];
    static readonly string[] TensMap = [string.Empty, "deimt", "dvideimt", "trisdeimt", "keturiasdeimt", "penkiasdeimt", "eiasdeimt", "septyniasdeimt", "atuoniasdeimt", "devyniasdeimt"];
    static readonly string[] HundredsMap = [string.Empty, "imtas", "du imtai", "trys imtai", "keturi imtai", "penki imtai", "ei imtai", "septyni imtai", "atuoni imtai", "devyni imtai"];

    static readonly string[] OrdinalUnitsMap = [string.Empty, "pirm", "antr", "trei", "ketvirt", "penkt", "et", "septint", "atunt", "devint", "deimt", "vienuolikt", "dvylikt", "trylikt", "keturiolikt", "penkiolikt", "eiolikt", "septyniolikt", "atuoniolikt", "devyniolikt", "dvideimt"];
    static readonly string[] OrdinalTensMap = [string.Empty, "deimt", "dvideimt", "trisdeimt", "keturiasdeimt", "penkiasdeimt", "eiasdeimt", "septyniasdeimt", "atuoniasdeimt", "devyniasdeimt"];
    static readonly string[] OrdinalHundredsMap = [string.Empty, "imt", "du imt", "trys imt", "keturi imt", "penki imt", "ei imt", "septyni imt", "atuoni imt", "devyni imt"];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (gender == GrammaticalGender.Neuter)
        {
            throw new NotSupportedException();
        }

        var parts = new List<string>();
        var number = input;

        HandleNegative(parts, ref number);
        CollectParts(parts, ref number, 1000000000000000000, GrammaticalGender.Masculine, "kvintilijonas", "kvintilijonai", "kvintilijon");
        CollectParts(parts, ref number, 1000000000000000, GrammaticalGender.Masculine, "kvadrilijonas", "kvadrilijonai", "kvadrilijon");
        CollectParts(parts, ref number, 1000000000000, GrammaticalGender.Masculine, "trilijonas", "trilijonai", "trilijon");
        CollectParts(parts, ref number, 1000000000, GrammaticalGender.Masculine, "milijardas", "milijardai", "milijard");
        CollectParts(parts, ref number, 1000000, GrammaticalGender.Masculine, "milijonas", "milijonai", "milijon");
        CollectParts(parts, ref number, 1000, GrammaticalGender.Masculine, "tkstantis", "tkstaniai", "tkstani");
        CollectPartsUnderOneThousand(parts, number, gender);

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int input, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Neuter)
        {
            throw new NotSupportedException();
        }

        var parts = new List<string>();
        var number = (long) input;

        HandleNegative(parts, ref number);
        CollectOrdinalParts(parts, ref number, 1000000000, GrammaticalGender.Masculine, "milijard" + GetOrdinalEndingForGender(gender), "milijardas", "milijardai", "milijard");
        CollectOrdinalParts(parts, ref number, 1000000, GrammaticalGender.Masculine, "milijon" + GetOrdinalEndingForGender(gender), "milijonas", "milijonai", "milijon");
        CollectOrdinalParts(parts, ref number, 1000, GrammaticalGender.Masculine, "tkstant" + GetOrdinalEndingForGender(gender), "tkstantis", "tkstaniai", "tkstani");
        CollectOrdinalPartsUnderOneThousand(parts, number, gender, true);

        return string.Join(" ", parts);
    }

    static void HandleNegative(List<string> parts, ref long number)
    {
        if (number < 0)
        {
            parts.Add("minus");
            number = -number;
        }
    }

    static void CollectParts(ICollection<string> parts, ref long number, long divisor,
        GrammaticalGender gender, params string[] forms)
    {
        var result = number / divisor;
        if (result == 0)
        {
            return;
        }

        number %= divisor;

        if (result > 1)
        {
            CollectPartsUnderOneThousand(parts, result, gender);
        }

        parts.Add(ChooseForm(result, forms));
    }

    static void CollectOrdinalParts(ICollection<string> parts, ref long number, long divisor,
        GrammaticalGender gender, string ordinalForm, params string[] forms)
    {
        var result = number / divisor;
        if (result == 0)
        {
            return;
        }

        number %= divisor;

        if (result > 1)
        {
            CollectOrdinalPartsUnderOneThousand(parts, result, gender);
        }

        parts.Add(ChooseCardinalOrOrdinalForm(result, ordinalForm, forms, useOrdinalForm: number == 0));
    }

    static void CollectPartsUnderOneThousand(ICollection<string> parts, long number, GrammaticalGender gender)
    {
        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            parts.Add(HundredsMap[hundreds]);
        }

        if (number >= 20)
        {
            var tens = number / 10;
            parts.Add(TensMap[tens]);
            number %= 10;
        }

        if (number > 0 || parts.Count == 0)
        {
            parts.Add(GetCardinalNumberForGender(UnitsMap[number], gender));
        }
    }

    static void CollectOrdinalPartsUnderOneThousand(ICollection<string> parts, long number,
        GrammaticalGender gender, bool lastNumber = false)
    {
        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;

            parts.Add(!lastNumber || number > 0
                ? HundredsMap[hundreds]
                : OrdinalHundredsMap[hundreds] + GetOrdinalEndingForGender(gender));
        }

        if (number >= 20)
        {
            var tens = number / 10;
            number %= 10;

            parts.Add(!lastNumber || number > 0
                ? TensMap[tens]
                : OrdinalTensMap[tens] + GetOrdinalEndingForGender(gender));
        }

        if (number > 0)
        {
            parts.Add(!lastNumber
                ? UnitsMap[number]
                : OrdinalUnitsMap[number] + GetOrdinalEndingForGender(gender));
        }
        else if (number == 0 && parts.Count == 0)
        {
            parts.Add(gender == GrammaticalGender.Masculine ? "nulinis" : "nulin");
        }
    }

    static string ChooseForm(long number, string[] forms) =>
        forms[GetFormIndex(number)];

    static string ChooseCardinalOrOrdinalForm(long number, string ordinalForm, string[] cardinalForms,
        bool useOrdinalForm = false)
    {
        if (useOrdinalForm)
        {
            return ordinalForm;
        }

        return ChooseForm(number, cardinalForms);
    }

    static int GetFormIndex(long number)
    {
        var form = LithuanianNumberFormDetector.Detect(number);
        return form switch
        {
            LithuanianNumberForm.Singular => 0,
            LithuanianNumberForm.Plural => 1,
            LithuanianNumberForm.GenitivePlural => 2,
            _ => throw new ArgumentOutOfRangeException(nameof(form))
        };
    }

    static string GetCardinalNumberForGender(string number, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Masculine)
        {
            return number;
        }

        if (gender == GrammaticalGender.Feminine)
        {
            if (number == "du")
            {
                return "dvi";
            }

            if (number.EndsWith("as"))
            {
                return number.Substring(0, number.Length - 1);
            }

            if (number.EndsWith("i"))
            {
                return number + "os";
            }

            return number;
        }

        throw new ArgumentOutOfRangeException(nameof(gender));
    }

    static string GetOrdinalEndingForGender(GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => "as",
            GrammaticalGender.Feminine => "a",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\LuxembourgishNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class LuxembourgishNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["null", "een", "zwee", "dri", "vier", "fnnef", "sechs", "siwen", "aacht", "nng", "zng", "eelef", "zwielef", "drizng", "vierzng", "fofzng", "siechzng", "siwwenzng", "uechtzng", "nonzng"];
    static readonly string[] TensMap = ["null", "zng", "zwanzeg", "drsseg", "vierzeg", "fofzeg", "sechzeg", "siwwenzeg", "achtzeg", "nonzeg"];
    static readonly string[] UnitsOrdinal = [string.Empty, "isch", "zwee", "drt", "vier", "fnnef", "sechs", "siwen", "aach", "nng", "zng", "eelef", "zwielef", "drizng", "vierzng", "fofzng", "siechzng", "siwwenzng", "uechtzng", "nonzng"];
    static readonly string[] HundredOrdinalSingular = ["eenhonnert"];
    static readonly string[] HundredOrdinalPlural = ["{0}honnert"];
    static readonly string[] ThousandOrdinalSingular = ["eendausend"];
    static readonly string[] ThousandOrdinalPlural = ["{0}dausend"];
    static readonly string[] MillionOrdinalSingular = ["eemillioun", "engmillioun"];
    static readonly string[] MillionOrdinalPlural = ["{0}millioun", "{0}milliounen"];
    static readonly string[] BillionOrdinalSingular = ["eemilliard", "engmilliard"];
    static readonly string[] BillionOrdinalPlural = ["{0}milliard", "{0}milliarden"];

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
        => Convert(number, WordForm.Normal, gender, addAnd);

    public override string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd = true)
    {
        if (number == 0)
        {
            return UnitsMap[number];
        }

        var parts = new List<string>();
        if (number < 0)
        {
            parts.Add("minus ");
            number = -number;
        }

        CollectParts(parts, ref number, 1000000000000000000, true, "{0} Trilliounen", "eng Trillioun");
        CollectParts(parts, ref number, 1000000000000000, true, "{0} Billiarden", "eng Billiard");
        CollectParts(parts, ref number, 1000000000000, true, "{0} Billiounen", "eng Billioun");
        CollectParts(parts, ref number, 1000000000, true, "{0} Milliarden", "eng Milliard");
        CollectParts(parts, ref number, 1000000, true, "{0} Milliounen", "eng Millioun");
        CollectParts(parts, ref number, 1000, false, "{0}dausend", "eendausend");
        CollectParts(parts, ref number, 100, false, "{0}honnert", "eenhonnert");

        if (number <= 0)
        {
            return string.Concat(parts);
        }

        if (number < 20)
        {
            switch (number)
            {
                case 1 when gender == GrammaticalGender.Feminine:
                    parts.Add("eng");
                    break;
                case 2 when gender == GrammaticalGender.Feminine:
                    parts.Add("zwou");
                    break;
                case 1 or 7:
                    parts.Add(wordForm is WordForm.Eifeler
                        ? LuxembourgishFormatter.ApplyEifelerRule(UnitsMap[number])
                        : UnitsMap[number]);
                    break;
                default:
                    parts.Add(UnitsMap[number]);
                    break;
            }
        }
        else
        {
            var units = number % 10;
            var tens = TensMap[number / 10];

            if (units > 0)
            {
                var andPart = LuxembourgishFormatter.CheckForAndApplyEifelerRule("an", tens);
                parts.Add($"{UnitsMap[units]}{andPart}");
            }

            parts.Add(tens);
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return UnitsMap[number] + GetEndingForGender(gender);
        }

        var parts = new List<string>();
        if (number < 0)
        {
            parts.Add("minus ");
            number = -number;
        }

        CollectOrdinalParts(parts, ref number, 1000000000, true, BillionOrdinalPlural, BillionOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 1000000, true, MillionOrdinalPlural, MillionOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 1000, false, ThousandOrdinalPlural, ThousandOrdinalSingular);
        CollectOrdinalParts(parts, ref number, 100, false, HundredOrdinalPlural, HundredOrdinalSingular);

        if (number > 0)
        {
            parts.Add(number < 20 ? UnitsOrdinal[number] : Convert(number));
        }

        if (number is 0 or >= 20)
        {
            parts.Add("s");
        }

        parts.Add(GetEndingForGender(gender));

        return string.Concat(parts);
    }

    private void CollectParts(ICollection<string> parts, ref long number, long divisor, bool addSpaceBeforeNextPart, string pluralFormat, string singular)
    {
        if (number / divisor <= 0)
        {
            return;
        }

        parts.Add(Part(pluralFormat, singular, number / divisor, divisor));
        number %= divisor;
        if (addSpaceBeforeNextPart && number > 0)
        {
            parts.Add(" ");
        }
    }

    private void CollectOrdinalParts(ICollection<string> parts, ref int number, int divisor, bool evaluateNoRest, string[] pluralFormats, string[] singulars)
    {
        if (number / divisor <= 0)
        {
            return;
        }

        var noRest = evaluateNoRest ? NoRestIndex(number % divisor) : 0;
        parts.Add(Part(pluralFormats[noRest], singulars[noRest], number / divisor, divisor));
        number %= divisor;
    }

    private string Part(string pluralFormat, string singular, long number, long divisor) =>
        number switch
        {
            1 => singular,
            2 when divisor >= 1000000 => string.Format(pluralFormat, Convert(number, GrammaticalGender.Feminine)),
            7 => GetPartWithEifelerRule(pluralFormat, number, GrammaticalGender.Masculine),
            _ => string.Format(pluralFormat, Convert(number))
        };

    private static int NoRestIndex(int number) =>
        number == 0 ? 0 : 1;

    private static string GetEndingForGender(GrammaticalGender gender) =>
        gender switch
        {
            GrammaticalGender.Masculine => "ten",
            GrammaticalGender.Feminine => "t",
            GrammaticalGender.Neuter => "t",
            _ => throw new ArgumentOutOfRangeException(nameof(gender))
        };

    private string GetPartWithEifelerRule(string pluralFormat, long number, GrammaticalGender gender)
    {
        var nextWord = pluralFormat
            .Substring(3, pluralFormat.Length - 3)
            .TrimStart();
        var wordForm = LuxembourgishFormatter.DoesEifelerRuleApply(nextWord)
            ? WordForm.Eifeler
            : WordForm.Normal;
        return string.Format(pluralFormat, Convert(number, wordForm, gender));
    }
}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\MalteseNumberToWordsConvertor.cs ---


namespace Humanizer;

class MalteseNumberToWordsConvertor : GenderedNumberToWordsConverter
{
    static readonly string[] OrdinalOverrideMap =
    [
        "0", "l-ewwel", "it-tieni", "it-tielet", "ir-raba'", "il-ames", "is-sitt", "is-seba'", "it-tmien", "id-disa'",
        "l-gaxar", "il-dax", "it-tnax", "it-tlettax", "l-erbatax", "il-mistax", "is-sittax", "is-sbatax",
        "it-tmintax", "id-dsatax", "l-goxrin"
    ];

    static readonly string[] UnitsMap =
    [
        "ero", "wieed", "tnejn", "tlieta", "erbga", "amsa", "sitta", "sebga", "tmienja", "disga", "gaxra",
        "dax", "tnax", "tlettax", "erbatax", "mistax", "sittax", "sbatax", "tmintax", "dsatax"
    ];

    static readonly string[] TensMap =
        ["zero", "gaxra", "goxrin", "tletin", "erbgin", "amsin", "sittin", "sebgin", "tmenin", "disgin"];

    static readonly string[] HundredsMap =
    [
        string.Empty, string.Empty, string.Empty, "tlett", "erbga", "ames", "sitt", "sebga", "tminn", "disga",
        "gaxar"
    ];

    static readonly string[] PrefixMap =
    [
        string.Empty, string.Empty, string.Empty, "tlett", "erbat", "amest", "sitt", "sebat", "tmint", "disat",
        "gaxart", "dax-il", "tnax-il", "tletax-il", "erbatax-il", "mistax-il", "sittax-il", "sbatax-il",
        "tmintax-il", "dsatax-il"
    ];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        var negativeNumber = false;

        if (input < 0)
        {
            negativeNumber = true;
            input *= -1;
        }

        if (input < 1000000000)
        {
            return GetMillions(input, gender) + (negativeNumber ? " inqas minn ero" : string.Empty);
        }

        var billions = input / 1000000000;
        var tensInBillions = billions % 100;
        var millions = input % 1000000000;

        var billionsText = GetPrefixText(billions, tensInBillions, "biljun", "ew biljuni", "biljuni", false, gender);
        var millionsText = GetMillions(millions, gender);

        if (millions == 0)
        {
            return billionsText;
        }

        return $"{billionsText} u {millionsText}" + (negativeNumber ? " inqas minn ero" : string.Empty);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number <= 20)
        {
            return OrdinalOverrideMap[number];
        }

        var ordinal = Convert(number, gender);

        if (ordinal.StartsWith("d"))
        {
            return $"id-{Convert(number, gender)}";
        }
        if (ordinal.StartsWith("s"))
        {
            return $"is-{Convert(number, gender)}";
        }
        if (ordinal.StartsWith("t"))
        {
            return $"it-{Convert(number, gender)}";
        }
        if (ordinal.StartsWith("e"))
        {
            return $"l-{Convert(number, gender)}";
        }
        return $"il-{Convert(number, gender)}";
    }

    static string GetTens(long value, bool usePrefixMap, bool usePrefixMapForLowerDigits, GrammaticalGender gender)
    {
        if (value == 1 && gender == GrammaticalGender.Feminine)
        {
            return "wada";
        }

        if (value < 11 && usePrefixMap && usePrefixMapForLowerDigits)
        {
            return PrefixMap[value];
        }

        if (value < 11 && usePrefixMap && !usePrefixMapForLowerDigits)
        {
            return HundredsMap[value];
        }

        if (value is > 10 and < 20 && usePrefixMap)
        {
            return PrefixMap[value];
        }

        if (value < 20)
        {
            return UnitsMap[value];
        }

        var single = value % 10;
        var numberOfTens = value / 10;
        if (single == 0)
        {
            return TensMap[numberOfTens];
        }

        return $"{UnitsMap[single]} u {TensMap[numberOfTens]}";
    }

    static string GetHundreds(long value, bool usePrefixMap, bool usePrefixMapForLowerValueDigits, GrammaticalGender gender)
    {
        if (value < 100)
        {
            return GetTens(value, usePrefixMap, usePrefixMapForLowerValueDigits, gender);
        }

        var tens = value % 100;
        var numberOfHundreds = value / 100;

        string hundredsText;
        if (numberOfHundreds == 1)
        {
            hundredsText = "mija";
        }
        else if (numberOfHundreds == 2)
        {
            hundredsText = "mitejn";
        }
        else
        {
            hundredsText = HundredsMap[numberOfHundreds] + " mija";
        }

        if (tens == 0)
        {
            return hundredsText;
        }

        return $"{hundredsText} u {GetTens(tens, usePrefixMap, usePrefixMapForLowerValueDigits, gender)}";
    }

    static string GetThousands(long value, GrammaticalGender gender)
    {
        if (value < 1000)
        {
            return GetHundreds(value, false, false, gender);
        }

        var thousands = value / 1000;
        var tensInThousands = thousands % 100;
        var hundreds = value % 1000;

        var thousandsInText = GetPrefixText(thousands, tensInThousands, "elf", "elfejn", "elef", true, gender);

        var hundredsInText = GetHundreds(hundreds, false, false, gender);

        if (hundreds == 0)
        {
            return thousandsInText;
        }

        return $"{thousandsInText} u {hundredsInText}";
    }

    static string GetMillions(long value, GrammaticalGender gender)
    {
        if (value < 1000000)
        {
            return GetThousands(value, gender);
        }

        var millions = value / 1000000;
        var tensInMillions = millions % 100;
        var thousands = value % 1000000;

        var millionsText = GetPrefixText(millions, tensInMillions, "miljun", "ew miljuni", "miljuni", false, gender);
        var thousandsText = GetThousands(thousands, gender);

        if (thousands == 0)
        {
            return millionsText;
        }

        return $"{millionsText} u {thousandsText}";
    }

    static string GetPrefixText(long thousands, long tensInThousands, string singular, string dual, string plural, bool usePrefixMapForLowerValueDigits, GrammaticalGender gender)
    {
        if (thousands == 1)
        {
            return singular;
        }

        if (thousands == 2)
        {
            return dual;
        }

        if (tensInThousands > 10)
        {
            return $"{GetHundreds(thousands, true, usePrefixMapForLowerValueDigits, gender)} {singular}";
        }

        if (thousands == 100)
        {
            return $"mitt {singular}";
        }

        if (thousands == 101)
        {
            return $"mija u {singular}";
        }

        return $"{GetHundreds(thousands, true, usePrefixMapForLowerValueDigits, gender)} {plural}";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\NorwegianBokmalNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class NorwegianBokmalNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["null", "en", "to", "tre", "fire", "fem", "seks", "sju", "tte", "ni", "ti", "elleve", "tolv", "tretten", "fjorten", "femten", "seksten", "sytten", "atten", "nitten"];
    static readonly string[] TensMap = ["null", "ti", "tjue", "tretti", "frti", "femti", "seksti", "sytti", "tti", "nitti"];

    static readonly Dictionary<int, string> OrdinalExceptions = new()
    {
        {
            0, "nullte"
        },
        {
            1, "frste"
        },
        {
            2, "andre"
        },
        {
            3, "tredje"
        },
        {
            4, "fjerde"
        },
        {
            5, "femte"
        },
        {
            6, "sjette"
        },
        {
            11, "ellevte"
        },
        {
            12, "tolvte"
        }
    };

    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        return Convert((int) number, false, gender);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        Convert(number, true, gender);

    string Convert(int number, bool isOrdinal, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return GetUnitValue(0, isOrdinal);
        }

        if (number < 0)
        {
            return $"minus {Convert(-number, isOrdinal, gender)}";
        }

        if (number == 1)
        {
            switch (gender)
            {
                case GrammaticalGender.Feminine:
                    return "ei";
                case GrammaticalGender.Neuter:
                    return "et";
            }
        }

        var parts = new List<string>();

        var millionOrMore = false;

        const int billion = 1000000000;
        if (number / billion > 0)
        {
            millionOrMore = true;
            var isExactOrdinal = isOrdinal && number % billion == 0;
            parts.Add(Part("{0} milliard" + (isExactOrdinal ? "" : "er"), (isExactOrdinal ? "" : "en ") + "milliard", number / billion, !isExactOrdinal));
            number %= billion;
        }

        const int million = 1000000;
        if (number / million > 0)
        {
            millionOrMore = true;
            var isExactOrdinal = isOrdinal && number % million == 0;
            parts.Add(Part("{0} million" + (isExactOrdinal ? "" : "er"), (isExactOrdinal ? "" : "en ") + "million", number / million, !isExactOrdinal));
            number %= million;
        }

        var thousand = false;
        if (number / 1000 > 0)
        {
            thousand = true;
            parts.Add(Part("{0}tusen", number % 1000 < 100 ? "tusen" : "ettusen", number / 1000));
            number %= 1000;
        }

        var hundred = false;
        if (number / 100 > 0)
        {
            hundred = true;
            parts.Add(Part("{0}hundre", thousand || millionOrMore ? "ethundre" : "hundre", number / 100));
            number %= 100;
        }

        if (number > 0)
        {
            if (parts.Count != 0)
            {
                if (millionOrMore && !hundred && !thousand)
                {
                    parts.Add("og ");
                }
                else
                {
                    parts.Add("og");
                }
            }

            if (number < 20)
            {
                parts.Add(GetUnitValue(number, isOrdinal));
            }
            else
            {
                var lastPart = TensMap[number / 10];
                if (number % 10 > 0)
                {
                    lastPart += $"{GetUnitValue(number % 10, isOrdinal)}";
                }
                else if (isOrdinal)
                {
                    lastPart = lastPart.TrimEnd('e') + "ende";
                }

                parts.Add(lastPart);
            }
        }
        else if (isOrdinal)
        {
            parts[^1] += (number == 0 ? "" : "en") + (millionOrMore ? "te" : "de");
        }

        var toWords = string
            .Concat(parts)
            .Trim();

        return toWords;
    }

    static string GetUnitValue(int number, bool isOrdinal)
    {
        if (isOrdinal)
        {
            if (ExceptionNumbersToWords(number, out var exceptionString))
            {
                return exceptionString;
            }

            if (number < 13)
            {
                return UnitsMap[number]
                    .TrimEnd('e') + "ende";
            }

            return UnitsMap[number] + "de";
        }

        return UnitsMap[number];
    }

    static bool ExceptionNumbersToWords(int number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);

    string Part(string pluralFormat, string singular, int number, bool postfixSpace = false)
    {
        var postfix = postfixSpace ? " " : "";
        if (number == 1)
        {
            return singular + postfix;
        }

        return string.Format(pluralFormat, Convert(number)) + postfix;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\PolishNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class PolishNumberToWordsConverter(CultureInfo culture) :
    GenderedNumberToWordsConverter
{
    static readonly string[] HundredsMap =
    [
        "zero", "sto", "dwiecie", "trzysta", "czterysta", "piset", "szeset", "siedemset", "osiemset", "dziewiset"
    ];

    static readonly string[] TensMap =
    [
        "zero", "dziesi", "dwadziecia", "trzydzieci", "czterdzieci", "pidziesit", "szedziesit",
        "siedemdziesit", "osiemdziesit", "dziewidziesit"
    ];

    static readonly string[] UnitsMap =
    [
        "zero", "jeden", "dwa", "trzy", "cztery", "pi", "sze", "siedem", "osiem", "dziewi", "dziesi",
        "jedenacie", "dwanacie", "trzynacie", "czternacie", "pitnacie", "szesnacie", "siedemnacie",
        "osiemnacie", "dziewitnacie"
    ];

    static readonly string[][] PowersOfThousandMap =
    [
        ["tysic", "tysice", "tysicy"],
        ["milion", "miliony", "milionw"],
        ["miliard", "miliardy", "miliardw"],
        ["bilion", "biliony", "bilionw"],
        ["biliard", "biliardy", "biliardw"],
        ["trylion", "tryliony", "trylionw"]
    ];

    const long MaxPossibleDivisor = 1_000_000_000_000_000_000;

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input == 0)
        {
            return "zero";
        }

        var parts = new List<string>();
        CollectParts(parts, input, gender);

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        number.ToString(culture);

    static void CollectParts(ICollection<string> parts, long input, GrammaticalGender gender)
    {
        var inputSign = 1;
        if (input < 0)
        {
            parts.Add("minus");
            inputSign = -1;
        }

        var number = input;
        var divisor = MaxPossibleDivisor;
        var power = PowersOfThousandMap.Length - 1;
        while (divisor > 0)
        {
            var multiplier = (int) Math.Abs(number / divisor);
            if (divisor > 1)
            {
                if (multiplier > 1)
                {
                    CollectPartsUnderThousand(parts, multiplier, GrammaticalGender.Masculine);
                }

                if (multiplier > 0)
                {
                    parts.Add(GetPowerOfThousandNameForm(multiplier, power));
                }
            }
            else if (multiplier > 0)
            {
                if (multiplier == 1 && Math.Abs(input) != 1)
                {
                    gender = GrammaticalGender.Masculine;
                }

                CollectPartsUnderThousand(parts, multiplier, gender);
            }

            number -= multiplier * divisor * inputSign;
            divisor /= 1000;
            power--;
        }
    }

    static void CollectPartsUnderThousand(ICollection<string> parts, int number, GrammaticalGender gender)
    {
        var hundredsDigit = number / 100;
        var tensDigit = number % 100 / 10;
        var unitsDigit = number % 10;

        if (hundredsDigit >= 1)
        {
            parts.Add(HundredsMap[hundredsDigit]);
        }

        if (tensDigit >= 2)
        {
            parts.Add(TensMap[tensDigit]);
        }

        if (tensDigit != 1 && unitsDigit == 2)
        {
            var genderedForm = gender == GrammaticalGender.Feminine ? "dwie" : "dwa";
            parts.Add(genderedForm);
        }
        else if (number == 1)
        {
            var genderedForm = gender switch
            {
                GrammaticalGender.Masculine => "jeden",
                GrammaticalGender.Feminine => "jedna",
                GrammaticalGender.Neuter => "jedno",
                _ => throw new ArgumentOutOfRangeException(nameof(gender))
            };
            parts.Add(genderedForm);
        }
        else
        {
            var unit = unitsDigit + 10 * (tensDigit == 1 ? 1 : 0);
            if (unit > 0)
            {
                parts.Add(UnitsMap[unit]);
            }
        }
    }

    static string GetPowerOfThousandNameForm(int multiplier, int power)
    {
        const int singularIndex = 0;
        const int pluralIndex = 1;
        const int genitiveIndex = 2;
        if (multiplier == 1)
        {
            return PowersOfThousandMap[power][singularIndex];
        }

        var multiplierUnitsDigit = multiplier % 10;
        var multiplierTensDigit = multiplier % 100 / 10;
        if (multiplierTensDigit == 1 || multiplierUnitsDigit <= 1 || multiplierUnitsDigit >= 5)
        {
            return PowersOfThousandMap[power][genitiveIndex];
        }

        return PowersOfThousandMap[power][pluralIndex];
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\PortugueseNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class PortugueseNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] PortugueseUnitsMap = ["zero", "um", "dois", "trs", "quatro", "cinco", "seis", "sete", "oito", "nove", "dez", "onze", "doze", "treze", "quatorze", "quinze", "dezesseis", "dezessete", "dezoito", "dezenove"];
    static readonly string[] PortugueseTensMap = ["zero", "dez", "vinte", "trinta", "quarenta", "cinquenta", "sessenta", "setenta", "oitenta", "noventa"];
    static readonly string[] PortugueseHundredsMap = ["zero", "cento", "duzentos", "trezentos", "quatrocentos", "quinhentos", "seiscentos", "setecentos", "oitocentos", "novecentos"];

    static readonly string[] PortugueseOrdinalUnitsMap = ["zero", "primeiro", "segundo", "terceiro", "quarto", "quinto", "sexto", "stimo", "oitavo", "nono"];
    static readonly string[] PortugueseOrdinalTensMap = ["zero", "dcimo", "vigsimo", "trigsimo", "quadragsimo", "quinquagsimo", "sexagsimo", "septuagsimo", "octogsimo", "nonagsimo"];
    static readonly string[] PortugueseOrdinalHundredsMap = ["zero", "centsimo", "ducentsimo", "trecentsimo", "quadringentsimo", "quingentsimo", "sexcentsimo", "septingentsimo", "octingentsimo", "noningentsimo"];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > 999999999999 or < -999999999999)
        {
            throw new NotImplementedException();
        }

        var number = input;

        if (number == 0)
        {
            return "zero";
        }

        if (number < 0)
        {
            return $"menos {Convert(Math.Abs(number), gender)}";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            // gender is not applied for billions
            parts.Add(number / 1000000000 == 1
                ? "mil milhes"
                : $"{Convert(number / 1000000000)} mil milhes");

            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            // gender is not applied for millions
            parts.Add(number / 1000000 >= 2
                ? $"{Convert(number / 1000000, GrammaticalGender.Masculine)} milhes"
                : $"{Convert(number / 1000000, GrammaticalGender.Masculine)} milho");

            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            // gender is not applied for thousands
            parts.Add(number / 1000 == 1 ? "mil" : $"{Convert(number / 1000, GrammaticalGender.Masculine)} mil");
            number %= 1000;
        }

        if (number / 100 > 0)
        {
            if (number == 100)
            {
                parts.Add(parts.Count > 0 ? "e cem" : "cem");
            }
            else
            {
                // Gender is applied to hundreds starting from 200
                parts.Add(ApplyGender(PortugueseHundredsMap[number / 100], gender));
            }

            number %= 100;
        }

        if (number > 0)
        {
            if (parts.Count != 0)
            {
                parts.Add("e");
            }

            if (number < 20)
            {
                parts.Add(ApplyGender(PortugueseUnitsMap[number], gender));
            }
            else
            {
                var lastPart = PortugueseTensMap[number / 10];
                if (number % 10 > 0)
                {
                    lastPart += $" e {ApplyGender(PortugueseUnitsMap[number % 10], gender)}";
                }

                parts.Add(lastPart);
            }
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        // N/A in Portuguese ordinal
        if (number == 0)
        {
            return "zero";
        }

        var parts = new List<string>();

        if (number / 1000000000 > 0)
        {
            parts.Add(number / 1000000000 == 1
                ? $"{ApplyOrdinalGender("milsimo", gender)} {ApplyOrdinalGender("milionsimo", gender)}"
                : $"{Convert(number / 1000000000)} {ApplyOrdinalGender("milsimo", gender)} {ApplyOrdinalGender("milionsimo", gender)}");

            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add(number / 1000000 == 1
                ? ApplyOrdinalGender("milionsimo", gender)
                : string.Format("{0} " + ApplyOrdinalGender("milionsimo", gender), ConvertToOrdinal(number / 1000000000, gender)));

            number %= 1000000;
        }

        if (number / 1000 > 0)
        {
            parts.Add(number / 1000 == 1
                ? ApplyOrdinalGender("milsimo", gender)
                : string.Format("{0} " + ApplyOrdinalGender("milsimo", gender), ConvertToOrdinal(number / 1000, gender)));

            number %= 1000;
        }

        if (number / 100 > 0)
        {
            parts.Add(ApplyOrdinalGender(PortugueseOrdinalHundredsMap[number / 100], gender));
            number %= 100;
        }

        if (number / 10 > 0)
        {
            parts.Add(ApplyOrdinalGender(PortugueseOrdinalTensMap[number / 10], gender));
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(ApplyOrdinalGender(PortugueseOrdinalUnitsMap[number], gender));
        }

        return string.Join(" ", parts);
    }

    static string ApplyGender(string toWords, GrammaticalGender gender)
    {
        if (gender != GrammaticalGender.Feminine)
        {
            return toWords;
        }

        if (toWords.EndsWith("os"))
        {
            return toWords.Substring(0, toWords.Length - 2) + "as";
        }

        if (toWords.EndsWith("um"))
        {
            return toWords.Substring(0, toWords.Length - 2) + "uma";
        }

        if (toWords.EndsWith("dois"))
        {
            return toWords.Substring(0, toWords.Length - 4) + "duas";
        }

        return toWords;
    }

    static string ApplyOrdinalGender(string toWords, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Feminine)
        {
            return toWords.TrimEnd('o') + 'a';
        }

        return toWords;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\RomanianNumberToWordsConverter.cs ---


using System;

namespace Humanizer;

class RomanianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    public override string Convert(long number, GrammaticalGender gender, bool addAnd = true)
    {
        if (number is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var converter = new RomanianCardinalNumberConverter();
        return converter.Convert((int) number, gender);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        var converter = new RomanianOrdinalNumberConverter();
        return converter.Convert(number, gender);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\RussianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class RussianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] HundredsMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsOrdinalPrefixes = [string.Empty, string.Empty, "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensOrdinalPrefixes = [string.Empty, "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensOrdinal = [string.Empty, "", "", "", "", "", "", "", "", ""];
    static readonly string[] UnitsOrdinal = [string.Empty, "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input == 0)
        {
            return "";
        }

        var parts = new List<string>();

        if (input < 0)
        {
            parts.Add("");
        }

        CollectParts(parts, ref input, 1000000000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000, GrammaticalGender.Feminine, "", "", "");

        if (input != 0)
        {
            CollectPartsUnderOneThousand(parts, Math.Abs(input), gender);
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int input, GrammaticalGender gender)
    {
        if (input == 0)
        {
            return "" + GetEndingForGender(gender, input);
        }

        var parts = new List<string>();

        if (input < 0)
        {
            parts.Add("");
            input = -input;
        }

        var number = (long) input;
        CollectOrdinalParts(parts, ref number, 1000000000, GrammaticalGender.Masculine, "" + GetEndingForGender(gender, number), "", "", "");
        CollectOrdinalParts(parts, ref number, 1000000, GrammaticalGender.Masculine, "" + GetEndingForGender(gender, number), "", "", "");
        CollectOrdinalParts(parts, ref number, 1000, GrammaticalGender.Feminine, "" + GetEndingForGender(gender, number), "", "", "");

        if (number >= 100)
        {
            var ending = GetEndingForGender(gender, number);
            var hundreds = number / 100;
            number %= 100;
            if (number == 0)
            {
                parts.Add(UnitsOrdinalPrefixes[hundreds] + "" + ending);
            }
            else
            {
                parts.Add(HundredsMap[hundreds]);
            }
        }

        if (number >= 20)
        {
            var ending = GetEndingForGender(gender, number);
            var tens = number / 10;
            number %= 10;
            if (number == 0)
            {
                parts.Add(TensOrdinal[tens] + ending);
            }
            else
            {
                parts.Add(TensMap[tens]);
            }
        }

        if (number > 0)
        {
            parts.Add(UnitsOrdinal[number] + GetEndingForGender(gender, number));
        }

        return string.Join(" ", parts);
    }

    static void CollectPartsUnderOneThousand(ICollection<string> parts, long number, GrammaticalGender gender)
    {
        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            parts.Add(HundredsMap[hundreds]);
        }

        if (number >= 20)
        {
            var tens = number / 10;
            parts.Add(TensMap[tens]);
            number %= 10;
        }

        if (number > 0)
        {
            if (number == 1 && gender == GrammaticalGender.Feminine)
            {
                parts.Add("");
            }
            else if (number == 1 && gender == GrammaticalGender.Neuter)
            {
                parts.Add("");
            }
            else if (number == 2 && gender == GrammaticalGender.Feminine)
            {
                parts.Add("");
            }
            else if (number < 20)
            {
                parts.Add(UnitsMap[number]);
            }
        }
    }

    static string GetPrefix(long number)
    {
        var parts = new List<string>();

        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            if (hundreds != 1)
            {
                parts.Add(UnitsOrdinalPrefixes[hundreds] + "");
            }
            else
            {
                parts.Add("");
            }
        }

        if (number >= 20)
        {
            var tens = number / 10;
            number %= 10;
            parts.Add(TensOrdinalPrefixes[tens]);
        }

        if (number > 0)
        {
            parts.Add(number == 1 ? "" : UnitsOrdinalPrefixes[number]);
        }

        return string.Concat(parts);
    }

    static void CollectParts(ICollection<string> parts, ref long number, long divisor, GrammaticalGender gender, params string[] forms)
    {
        var result = Math.Abs(number / divisor);
        if (result == 0)
        {
            return;
        }

        CollectPartsUnderOneThousand(parts, result, gender);
        parts.Add(ChooseOneForGrammaticalNumber(result, forms));
        number = Math.Abs(number % divisor);
    }

    static void CollectOrdinalParts(ICollection<string> parts, ref long number, int divisor, GrammaticalGender gender, string prefixedForm, params string[] forms)
    {
        if (number < divisor)
        {
            return;
        }

        var result = number / divisor;
        number %= divisor;
        if (number == 0)
        {
            if (result == 1)
            {
                parts.Add(prefixedForm);
            }
            else
            {
                parts.Add(GetPrefix(result) + prefixedForm);
            }
        }
        else
        {
            CollectPartsUnderOneThousand(parts, result, gender);
            parts.Add(ChooseOneForGrammaticalNumber(result, forms));
        }
    }

    static int GetIndex(RussianGrammaticalNumber number)
    {
        if (number == RussianGrammaticalNumber.Singular)
        {
            return 0;
        }

        if (number == RussianGrammaticalNumber.Paucal)
        {
            return 1;
        }

        return 2;
    }

    static string ChooseOneForGrammaticalNumber(long number, string[] forms) =>
        forms[GetIndex(RussianGrammaticalNumberDetector.Detect(number))];

    static string GetEndingForGender(GrammaticalGender gender, long number)
    {
        switch (gender)
        {
            case GrammaticalGender.Masculine:
                if (number is 0 or 2 or 6 or 7 or 8 or 40)
                {
                    return "";
                }

                if (number == 3)
                {
                    return "";
                }

                return "";
            case GrammaticalGender.Feminine:
                if (number == 3)
                {
                    return "";
                }

                return "";
            case GrammaticalGender.Neuter:
                if (number == 3)
                {
                    return "";
                }

                return "";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\SerbianCyrlNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class SerbianCyrlNumberToWordsConverter(CultureInfo culture) :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;

        if (number == 0)
        {
            return "";
        }

        if (number < 0)
        {
            return $"- {Convert(-number)}";
        }

        var parts = new List<string>();
        var billions = number / 1000000000;

        if (billions > 0)
        {
            parts.Add(Part("", " ", "{0} ", "{0} ", billions));
            number %= 1000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var millions = number / 1000000;

        if (millions > 0)
        {
            parts.Add(Part("", " ", "{0} ", "{0} ", millions));
            number %= 1000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var thousands = number / 1000;

        if (thousands > 0)
        {
            parts.Add(Part("", " ", "{0} ", "{0} ", thousands));
            number %= 1000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var hundreds = number / 100;

        if (hundreds > 0)
        {
            parts.Add(Part("", "", "{0}", "{0}", hundreds));
            number %= 100;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        if (number > 0)
        {
            if (number < 20)
            {
                parts.Add(UnitsMap[number]);
            }
            else
            {
                parts.Add(TensMap[number / 10]);

                var units = number % 10;

                if (units > 0)
                {
                    parts.Add($" {UnitsMap[units]}");
                }
            }
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number) =>
        //TODO: In progress
        number.ToString(culture);

    string Part(string singular, string dual, string trialQuadral, string plural, int number)
    {
        switch (number)
        {
            case 1:
                return singular;
            case 2:
                return dual;
            case 3:
            case 4:
                return string.Format(trialQuadral, Convert(number));
            default:
                return string.Format(plural, Convert(number));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\SerbianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class SerbianNumberToWordsConverter(CultureInfo culture) :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nula", "jedan", "dva", "tri", "etiri", "pet", "est", "sedam", "osam", "devet", "deset", "jedanaest", "dvanaest", "trinaest", "etrnaest", "petnaest", "estnaest", "sedemnaest", "osemnaest", "devetnaest"];
    static readonly string[] TensMap = ["nula", "deset", "dvadeset", "trideset", "etrdeset", "petdeset", "estdeset", "sedamdeset", "osamdeset", "devetdeset"];

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;
        if (number == 0)
        {
            return "nula";
        }

        if (number < 0)
        {
            return $"- {Convert(-number)}";
        }

        var parts = new List<string>();
        var billions = number / 1000000000;

        if (billions > 0)
        {
            parts.Add(Part("milijarda", "dve milijarde", "{0} milijarde", "{0} milijarda", billions));
            number %= 1000000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var millions = number / 1000000;

        if (millions > 0)
        {
            parts.Add(Part("milion", "dva miliona", "{0} miliona", "{0} miliona", millions));
            number %= 1000000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var thousands = number / 1000;

        if (thousands > 0)
        {
            parts.Add(Part("hiljadu", "dve hiljade", "{0} hiljade", "{0} hiljada", thousands));
            number %= 1000;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var hundreds = number / 100;

        if (hundreds > 0)
        {
            parts.Add(Part("sto", "dvesto", "{0}sto", "{0}sto", hundreds));
            number %= 100;

            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        if (number > 0)
        {
            if (number < 20)
            {
                parts.Add(UnitsMap[number]);
            }
            else
            {
                parts.Add(TensMap[number / 10]);
                var units = number % 10;

                if (units > 0)
                {
                    parts.Add($" {UnitsMap[units]}");
                }
            }
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number) =>
        //TODO: In progress
        number.ToString(culture);

    string Part(string singular, string dual, string trialQuadral, string plural, int number)
    {
        switch (number)
        {
            case 1:
                return singular;
            case 2:
                return dual;
            case 3:
            case 4:
                return string.Format(trialQuadral, Convert(number));
            default:
                return string.Format(plural, Convert(number));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\SlovenianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class SlovenianNumberToWordsConverter(CultureInfo culture) :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["ni", "ena", "dva", "tri", "tiri", "pet", "est", "sedem", "osem", "devet", "deset", "enajst", "dvanajst", "trinajst", "tirinajst", "petnajst", "estnajst", "sedemnajst", "osemnajst", "devetnajst"];
    static readonly string[] TensMap = ["ni", "deset", "dvajset", "trideset", "tirideset", "petdeset", "estdeset", "sedemdeset", "osemdeset", "devetdeset"];

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;
        if (number == 0)
        {
            return "ni";
        }

        if (number < 0)
        {
            return $"minus {Convert(-number)}";
        }

        var parts = new List<string>();

        var billions = number / 1000000000;
        if (billions > 0)
        {
            parts.Add(Part("milijarda", "dve milijardi", "{0} milijarde", "{0} milijard", billions));
            number %= 1000000000;
            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var millions = number / 1000000;
        if (millions > 0)
        {
            parts.Add(Part("milijon", "dva milijona", "{0} milijone", "{0} milijonov", millions));
            number %= 1000000;
            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var thousands = number / 1000;
        if (thousands > 0)
        {
            parts.Add(Part("tiso", "dva tiso", "{0} tiso", "{0} tiso", thousands));
            number %= 1000;
            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        var hundreds = number / 100;
        if (hundreds > 0)
        {
            parts.Add(Part("sto", "dvesto", "{0}sto", "{0}sto", hundreds));
            number %= 100;
            if (number > 0)
            {
                parts.Add(" ");
            }
        }

        if (number > 0)
        {
            if (number < 20)
            {
                if (number > 1)
                {
                    parts.Add(UnitsMap[number]);
                }
                else
                {
                    parts.Add("ena");
                }
            }
            else
            {
                var units = number % 10;
                if (units > 0)
                {
                    parts.Add($"{UnitsMap[units]}in");
                }

                parts.Add(TensMap[number / 10]);
            }
        }

        return string.Concat(parts);
    }

    public override string ConvertToOrdinal(int number) =>
        number.ToString(culture);

    string Part(string singular, string dual, string trialQuadral, string plural, int number)
    {
        if (number == 1)
        {
            return singular;
        }

        if (number == 2)
        {
            return dual;
        }

        if (number is 3 or 4)
        {
            return string.Format(trialQuadral, Convert(number));
        }

        return string.Format(plural, Convert(number));
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\SpanishNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

class SpanishNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] HundredsRootMap =
    [
        "cero", "ciento", "doscient", "trescient", "cuatrocient", "quinient", "seiscient", "setecient",
        "ochocient", "novecient"
    ];

    static readonly string[] HundredthsRootMap =
    [
        "", "centsim", "ducentsim", "tricentsim", "cuadringentsim", "quingentsim", "sexcentsim",
        "septingentsim", "octingentsim", "noningentsim"
    ];

    static readonly string[] OrdinalsRootMap =
    [
        "", "primer", "segund", "tercer", "cuart", "quint", "sext",
        "sptim", "octav", "noven"
    ];

    static readonly string[] TensMap =
    [
        "cero", "diez", "veinte", "treinta", "cuarenta", "cincuenta", "sesenta", "setenta", "ochenta", "noventa"
    ];

    static readonly string[] TenthsRootMap =
    [
        "", "dcim", "vigsim", "trigsim", "cuadragsim", "quincuagsim", "sexagsim", "septuagsim",
        "octogsim", "nonagsim"
    ];

    static readonly string[] ThousandthsRootMap =
    [
        "", "milsim", "dosmilsim", "tresmilsim", "cuatromilsim", "cincomilsim", "seismilsim",
        "sietemilsim", "ochomilsim", "nuevemilsim"
    ];

    static readonly string[] TupleMap =
    [
        "cero veces", "una vez", "doble", "triple", "cudruple", "quntuple", "sxtuple", "sptuple", "ctuple",
        "nonuplo", "dcuplo", "undcuplo", "duodcuplo", "terciodcuplo"
    ];

    static readonly string[] UnitsMap =
    [
        "cero", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve", "diez", "once", "doce",
        "trece", "catorce", "quince", "diecisis", "diecisiete", "dieciocho", "diecinueve", "veinte", "veintiuno",
        "veintids", "veintitrs", "veinticuatro", "veinticinco", "veintisis", "veintisiete", "veintiocho", "veintinueve"
    ];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true) =>
        Convert(input, WordForm.Normal, gender, addAnd);

    public override string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd = true)
    {
        List<string> wordBuilder = [];

        if (number == 0)
        {
            return "cero";
        }

        if (number == long.MinValue)
        {
            return
                "menos nueve trillones doscientos veintitrs mil trescientos setenta y dos billones treinta y seis mil " +
                "ochocientos cincuenta y cuatro millones setecientos setenta y cinco mil ochocientos ocho";
        }

        if (number < 0)
        {
            return $"menos {Convert(-number)}";
        }

        wordBuilder.Add(ConvertGreaterThanMillion(number, out var remainder));
        wordBuilder.Add(ConvertThousands(remainder, out remainder, gender));
        wordBuilder.Add(ConvertHundreds(remainder, out remainder, gender));
        wordBuilder.Add(ConvertUnits(remainder, gender, wordForm));

        return BuildWord(wordBuilder);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender) =>
        ConvertToOrdinal(number, gender, WordForm.Normal);

    public override string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm)
    {
        List<string> wordBuilder = [];

        if (number is 0 or int.MinValue)
        {
            return "cero";
        }

        if (number < 0)
        {
            return ConvertToOrdinal(Math.Abs(number), gender);
        }

        if (IsRoundBillion(number))
        {
            return ConvertRoundBillionths(number, gender);
        }

        if (IsRoundMillion(number))
        {
            return ConvertToOrdinal(number / 1000, gender)
                .Replace("milsim", "millonsim");
        }

        wordBuilder.Add(ConvertTensAndHunderdsOfThousandths(number, out var remainder, gender));
        wordBuilder.Add(ConvertThousandths(remainder, out remainder, gender));
        wordBuilder.Add(ConvertHundredths(remainder, out remainder, gender));
        wordBuilder.Add(ConvertTenths(remainder, out remainder, gender));
        wordBuilder.Add(ConvertOrdinalUnits(remainder, gender, wordForm));

        return BuildWord(wordBuilder);
    }

    public override string ConvertToTuple(int number)
    {
        number = Math.Abs(number);

        if (number < TupleMap.Length)
            return TupleMap[number];

        return Convert(number) + " veces";
    }

    static string BuildWord(IReadOnlyList<string> wordParts)
    {
        var parts = wordParts.ToList();
        parts.RemoveAll(string.IsNullOrEmpty);
        return string.Join(" ", parts);
    }

    static string ConvertHundreds(in long inputNumber, out long remainder, GrammaticalGender gender)
    {
        var wordPart = string.Empty;
        remainder = inputNumber;

        if (inputNumber / 100 > 0)
        {
            wordPart = inputNumber == 100 ? "cien" : GetGenderedHundredsMap(gender)[(int) (inputNumber / 100)];

            remainder = inputNumber % 100;
        }

        return wordPart;
    }

    static string ConvertHundredths(in int number, out int remainder, GrammaticalGender gender) =>
        ConvertMappedOrdinalNumber(number, 100, HundredthsRootMap, out remainder, gender);

    static string ConvertMappedOrdinalNumber(
        in int number,
        in int divisor,
        IReadOnlyList<string> map,
        out int remainder,
        GrammaticalGender gender)
    {
        var wordPart = string.Empty;
        remainder = number;

        if (number / divisor > 0)
        {
            var genderedEnding = gender == GrammaticalGender.Feminine ? "a" : "o";
            wordPart = map[number / divisor] + genderedEnding;
            remainder = number % divisor;
        }

        return wordPart;
    }

    static string ConvertOrdinalUnits(in int number, GrammaticalGender gender, WordForm wordForm)
    {
        if (number is <= 0 or >= 10)
        {
            return string.Empty;
        }

        switch (gender)
        {
            case GrammaticalGender.Masculine:
            case GrammaticalGender.Neuter:
                if (HasOrdinalAbbreviation(number, wordForm))
                {
                    return OrdinalsRootMap[number];
                }

                return OrdinalsRootMap[number] + 'o';
            case GrammaticalGender.Feminine:
                return OrdinalsRootMap[number] + "a";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender), gender, null);
        }
    }

    static string ConvertTenths(in int number, out int remainder, GrammaticalGender gender) =>
        ConvertMappedOrdinalNumber(number, 10, TenthsRootMap, out remainder, gender);

    static string ConvertThousandths(in int number, out int remainder, GrammaticalGender gender) =>
        ConvertMappedOrdinalNumber(number, 1000, ThousandthsRootMap, out remainder, gender);

    static string ConvertUnits(long inputNumber, GrammaticalGender gender, WordForm wordForm = WordForm.Normal)
    {
        if (inputNumber <= 0)
        {
            return string.Empty;
        }

        UnitsMap[1] = GetGenderedOne(gender, wordForm);
        UnitsMap[21] = GetGenderedTwentyOne(gender, wordForm);

        if (inputNumber < 30)
        {
            return UnitsMap[inputNumber];
        }

        var wordPart = TensMap[inputNumber / 10];
        if (inputNumber % 10 <= 0)
        {
            return wordPart;
        }

        return wordPart + $" y {UnitsMap[inputNumber % 10]}";
    }

    static IReadOnlyList<string> GetGenderedHundredsMap(GrammaticalGender gender)
    {
        var genderedEnding = gender == GrammaticalGender.Feminine ? "as" : "os";
        var map = new List<string>();
        map.AddRange(HundredsRootMap.Take(2));

        for (var i = 2; i < HundredsRootMap.Length; i++)
        {
            map.Add(HundredsRootMap[i] + genderedEnding);
        }

        return map;
    }

    static string GetGenderedOne(GrammaticalGender gender, WordForm wordForm = WordForm.Normal)
    {
        switch (gender)
        {
            case GrammaticalGender.Masculine:
            case GrammaticalGender.Neuter:
                return wordForm == WordForm.Abbreviation ? "un" : "uno";
            case GrammaticalGender.Feminine:
                return "una";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender), gender, null);
        }
    }

    static string GetGenderedTwentyOne(GrammaticalGender gender, WordForm wordForm = WordForm.Normal)
    {
        switch (gender)
        {
            case GrammaticalGender.Masculine:
            case GrammaticalGender.Neuter:
                return wordForm == WordForm.Abbreviation ? "veintin" : "veintiuno";
            case GrammaticalGender.Feminine:
                return "veintiuna";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender), gender, null);
        }
    }

    static bool HasOrdinalAbbreviation(int number, WordForm wordForm) =>
        number is 1 or 3 && wordForm == WordForm.Abbreviation;

    static bool IsRoundBillion(int number) =>
        number >= 1000_000_000 && number % 1_000_000 == 0;

    static bool IsRoundMillion(int number) =>
        number >= 1000000 && number % 1000000 == 0;

    static string PluralizeGreaterThanMillion(string singularWord) =>
        singularWord.TrimEnd('', 'n') + "ones";

    static Dictionary<string, long> numbersAndWordsDict = new()
    {
        {
            "trilln", 1_000_000_000_000_000_000
        },
        {
            "billn", 1_000_000_000_000
        },
        {
            "milln", 1_000_000
        }
    };

    string ConvertGreaterThanMillion(in long inputNumber, out long remainder)
    {
        List<string> wordBuilder = [];

        remainder = inputNumber;
        foreach (var numberAndWord in numbersAndWordsDict)
        {
            if (remainder / numberAndWord.Value > 0)
            {
                if (remainder / numberAndWord.Value == 1)
                {
                    wordBuilder.Add($"un {numberAndWord.Key}");
                }
                else
                {
                    wordBuilder.Add(remainder / numberAndWord.Value % 10 == 1 ? $"{Convert(remainder / numberAndWord.Value, WordForm.Abbreviation, GrammaticalGender.Masculine)} {PluralizeGreaterThanMillion(numberAndWord.Key)}" : $"{Convert(remainder / numberAndWord.Value)} {PluralizeGreaterThanMillion(numberAndWord.Key)}");
                }

                remainder %= numberAndWord.Value;
            }
        }

        return BuildWord(wordBuilder);
    }

    string ConvertRoundBillionths(int number, GrammaticalGender gender)
    {
        var cardinalPart = Convert(number / 1_000_000, WordForm.Abbreviation, gender);
        var sep = number == 1_000_000_000 ? "" : " ";
        var ordinalPart = ConvertToOrdinal(1_000_000, gender);
        return cardinalPart + sep + ordinalPart;
    }

    string ConvertTensAndHunderdsOfThousandths(in int number, out int remainder, GrammaticalGender gender)
    {
        var wordPart = string.Empty;
        remainder = number;

        if (number / 10000 > 0)
        {
            wordPart = Convert(number / 1000 * 1000, gender);

            if (number < 30000 || IsRoundNumber(number))
            {
                if (number == 21000)
                {
                    wordPart = wordPart
                        .Replace("a", "")
                        .Replace("", "u");
                }

                wordPart = wordPart.Remove(wordPart.LastIndexOf(' '), 1);
            }

            wordPart += "sim" + (gender == GrammaticalGender.Masculine ? "o" : "a");

            remainder = number % 1000;
        }

        return wordPart;

        static bool IsRoundNumber(int number) =>
            (number % 10000 == 0 && number < 100000)
            || (number % 100000 == 0 && number < 1000000)
            || (number % 1000000 == 0 && number < 10000000)
            || (number % 10000000 == 0 && number < 100000000)
            || (number % 100000000 == 0 && number < 1000000000)
            || (number % 1000000000 == 0 && number < int.MaxValue);
    }

    string ConvertThousands(in long inputNumber, out long remainder, GrammaticalGender gender)
    {
        var wordPart = string.Empty;
        remainder = inputNumber;

        if (inputNumber / 1000 > 0)
        {
            if (inputNumber / 1000 == 1)
            {
                wordPart = "mil";
            }
            else
            {
                wordPart = gender == GrammaticalGender.Feminine ? $"{Convert(inputNumber / 1000, GrammaticalGender.Feminine)} mil" : $"{Convert(inputNumber / 1000, WordForm.Abbreviation, gender)} mil";
            }

            remainder = inputNumber % 1000;
        }

        return wordPart;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\SwedishNumberToWordsConverter.cs ---


using System;

namespace Humanizer;

class SwedishNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["noll", "ett", "tv", "tre", "fyra", "fem", "sex", "sju", "tta", "nio", "tio", "elva", "tolv", "tretton", "fjorton", "femton", "sexton", "sjutton", "arton", "nitton"];
    static readonly string[] TensMap = ["noll", "tio", "tjugo", "trettio", "fyrtio", "femtio", "sextio", "sjuttio", "ttio", "nittio", "hundra"];

    class Fact
    {
        public int Value { get; set; }
        public required string Name { get; set; }
        public required string Prefix { get; set; }
        public required string Postfix { get; set; }
        public bool DisplayOneUnit { get; set; }
        public GrammaticalGender Gender { get; set; } = GrammaticalGender.Neuter;
    }

    static readonly Fact[] Hunderds =
    [
        new()
        {
            Value = 1000000000,
            Name = "miljard",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true,
            Gender = GrammaticalGender.Masculine
        },
        new()
        {
            Value = 1000000,
            Name = "miljon",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true,
            Gender = GrammaticalGender.Masculine
        },
        new()
        {
            Value = 1000,
            Name = "tusen",
            Prefix = " ",
            Postfix = " ",
            DisplayOneUnit = true
        },
        new()
        {
            Value = 100,
            Name = "hundra",
            Prefix = "",
            Postfix = "",
            DisplayOneUnit = false
        }
    ];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;

        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $"minus {Convert(-number, gender)}";
        }

        var word = "";

        foreach (var m in Hunderds)
        {
            var divided = number / m.Value;

            if (divided <= 0)
            {
                continue;
            }

            if (divided == 1 && !m.DisplayOneUnit)
            {
                word += m.Name;
            }
            else
            {
                word += Convert(divided, m.Gender) + m.Prefix + m.Name;
            }

            // pluralise 1M+
            if (divided > 1 && input >= 1_000_000)
            {
                word += "er";
            }

            number %= m.Value;
            if (number > 0)
            {
                word += m.Postfix;
            }
        }

        if (number > 0)
        {
            if (number < 20)
            {
                if (number == 1 && gender == GrammaticalGender.Masculine)
                {
                    word += "en";
                }
                else
                {
                    word += UnitsMap[number];
                }
            }
            else
            {
                var tens = TensMap[number / 10];
                var unit = number % 10;
                if (unit > 0)
                {
                    var units = UnitsMap[unit];
                    word += tens + units;
                }
                else
                {
                    word += tens;
                }
            }
        }

        return word;
    }

    public override string Convert(long input) =>
        Convert(input, GrammaticalGender.Neuter);

    static string[] ordinalNumbers =
    [
        "nollte",
        "frsta",
        "andra",
        "tredje",
        "fjrde",
        "femte",
        "sjtte",
        "sjunde",
        "ttonde",
        "nionde",
        "tionde",
        "elfte",
        "tolfte",
        "trettonde",
        "fjortonde",
        "femtonde",
        "sextonde",
        "sjuttonde",
        "artonde",
        "nittonde",
        "tjugonde"
    ];

    public override string ConvertToOrdinal(int number)
    {
        var word = "";

        if (number < 0)
        {
            return $"minus {ConvertToOrdinal(-number)}";
        }

        if (number <= 20)
        {
            return ordinalNumbers[number];
        }

        // 21+
        if (number <= 100)
        {
            var tens = TensMap[number / 10];
            var unit = number % 10;
            if (unit > 0)
            {
                word += tens + ConvertToOrdinal(unit);
            }
            else if (number == 100)
            {
                word += tens + "de";
            }
            else
            {
                word += tens + "nde";
            }

            return word;
        }

        // 101+
        foreach (var m in Hunderds)
        {
            var divided = number / m.Value;

            if (divided <= 0)
            {
                continue;
            }

            if (divided == 1 && !m.DisplayOneUnit)
            {
                word += m.Name;
            }
            else
            {
                word += Convert(divided, m.Gender) + m.Prefix + m.Name;
            }

            // suffix -de/-te
            if (number % m.Value == 0)
            {
                word += number switch
                {
                    1_000_000 => "te",
                    _ => "de"
                };
            }

            number %= m.Value;
            if (number > 0)
            {
                word += ConvertToOrdinal(number);
            }
        }

        return word;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\TamilNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class TamilNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] HundredsMap = ["", "", "", "", "", "", "", "", ""];
    static readonly string[] ThousandsMap = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

    static readonly string[] LakhsMap = [""];

    static readonly Dictionary<long, string> OrdinalExceptions = new()
    {
        {
            1, ""
        },
        {
            2, ""
        },
        {
            3, ""
        },
        {
            4, ""
        },
        {
            5, ""
        },
        {
            8, ""
        },
        {
            9, ""
        },
        {
            12, ""
        },
    };

    public override string Convert(long number) =>
        ConvertImpl(number, false);

    public override string ConvertToOrdinal(int number) =>
        ConvertImpl(number, true);

    string ConvertImpl(long number, bool isOrdinal)
    {
        if (number == 0)
            return GetUnitValue(0, isOrdinal);

        if (number < 0)
            return $" {Convert(-number)}";

        var parts = new List<string>();

        if (number / 1000000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000000)} quintillion");
            number %= 1000000000000000000;
        }

        if (number / 1000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000)} quadrillion");
            number %= 1000000000000000;
        }

        //if ((number / 1000000000000) > 0)
        //{
        //    parts.Add(string.Format("{0} trillion", Convert(number / 1000000000000)));
        //    number %= 1000000000000;
        //}

        //if ((number / 1000000000) > 0)
        //{
        //    parts.Add(string.Format("{0} ", Convert(number / 1000000000)));
        //    number %= 1000000000;
        //}

        //if ((number / 1000000) > 0)
        //{
        //    parts.Add(string.Format("{0} ", Convert(number / 1000000)));
        //    number %= 1000000;
        //}

        if (number / 10000000 > 0) parts.Add(GetCroresValue(ref number));

        if (number / 100000 > 0) parts.Add(GetLakhsValue(ref number, isOrdinal));

        if (number / 1000 > 0) parts.Add(GetThousandsValue(ref number));

        if (number / 100 > 0) parts.Add(GetHundredsValue(ref number));

        if (number > 0)
            parts.Add(GetTensValue(number, isOrdinal));
        else if (isOrdinal)
            parts[^1] += "";

        var toWords = string.Join(" ", parts);

        if (isOrdinal)
        {
            toWords = RemoveOnePrefix(toWords);
        }

        return toWords;
    }

    static string GetUnitValue(long number, bool isOrdinal)
    {
        if (isOrdinal)
        {
            if (ExceptionNumbersToWords(number, out var exceptionString))
            {
                return exceptionString;
            }

            return UnitsMap[number] + "";
        }

        return UnitsMap[number];
    }

    static string GetTensValue(long number, bool isOrdinal, bool isThousand = false)
    {
        var local_word = "";
        if (number < 20)
            local_word = GetUnitValue(number, isOrdinal);
        else if (number is >= 20 and <= 99)
        {
            var lastPart = TensMap[number / 10];
            var quot = number / 10;
            if (number % 10 > 0)
            {
                if (quot == 9)
                    lastPart += " ";
                else if (quot is 7 or 8 or 4)
                    lastPart += " ";
                else
                    lastPart += " ";

                if (!isThousand) lastPart += $"{GetUnitValue(number % 10, isOrdinal)}";
            }
            else if (number % 10 == 0)
            {
                if (isThousand)
                {
                    if (quot == 9)
                        lastPart += "";
                    else
                        lastPart += "";
                }
                else
                {
                    if (quot == 9)
                        lastPart += "";
                    else
                        lastPart += "";
                }
            }
            else if (isOrdinal)
                lastPart = lastPart.TrimEnd('y') + "ieth";

            local_word = lastPart;
        }

        return local_word;
    }

    static string GetLakhsValue(ref long number, bool isOrdinal)
    {
        var num_above_10 = number / 100000;
        var local_word = "";
        if (num_above_10 >= 20)
        {
            local_word = GetTensValue(num_above_10, false, false);
            local_word += " " + LakhsMap[0];
        }
        else if (num_above_10 == 1)
            local_word = " " + LakhsMap[0];
        else local_word += GetTensValue(number / 100000, isOrdinal) + " " + LakhsMap[0];

        if (number % 1000000 == 0 || number % 100000 == 0)
            local_word += "";
        else
            local_word += "";

        number %= 100000;
        return local_word;
    }

    static string GetCroresValue(ref long number)
    {
        var local_word = "";
        var num_above_10 = number / 10000000;
        var str_crore = "";

        if (num_above_10 is > 99999 and <= 9999999)
        {
            local_word = GetLakhsValue(ref num_above_10, false);
            local_word += " ";
        }

        if (num_above_10 is > 999 and <= 99999)
        {
            local_word += GetThousandsValue(ref num_above_10);
            local_word += " ";
        }

        if (num_above_10 is > 99 and <= 999)
        {
            local_word += GetHundredsValue(ref num_above_10);
            local_word += " ";
        }

        if (num_above_10 >= 20)
        {
            local_word += GetTensValue(num_above_10, false, false);
            local_word += " ";
        }
        else if (num_above_10 == 1)
            local_word = " ";
        else if (num_above_10 > 0) local_word += GetTensValue(num_above_10, false) + " ";

        local_word = local_word.TrimEnd() + " " + str_crore;
        if (number % 10000000 == 0 || number % 100000000 == 0)
            local_word += "";
        else
            local_word += "";

        number %= 10000000;
        return local_word;
    }

    static string GetThousandsValue(ref long number)
    {
        var num_above_10 = number / 1000;
        var local_word = "";
        if (num_above_10 >= 20)
        {
            local_word = GetTensValue(num_above_10, false, true);

            if (num_above_10 % 10 == 1)
                local_word += "";
            else if (num_above_10 % 10 > 1)
                local_word += ThousandsMap[num_above_10 % 10 - 1];

        }
        else
            local_word += ThousandsMap[number / 1000 - 1];

        number %= 1000;

        if (number > 0)
            local_word += "";
        else
            local_word += "";

        return local_word;
    }

    static string GetHundredsValue(ref long number)
    {
        var local_word = HundredsMap[number / 100 - 1];
        if (number / 100 == 9)
        {
            if (number % 100 == 0)
                local_word += "";
            else
                local_word += "";
        }
        else if (number % 100 >= 1)
            local_word += "";
        else
            local_word += "";

        number %= 100;

        return local_word;
    }

    static string RemoveOnePrefix(string toWords)
    {
        // one hundred => hundredth
        if (toWords.StartsWith("one", StringComparison.Ordinal))
            toWords = toWords.Remove(0, 4);

        return toWords;
    }

    static bool ExceptionNumbersToWords(long number, [NotNullWhen(true)] out string? words) =>
        OrdinalExceptions.TryGetValue(number, out words);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\ThaiNumberToWordsConverter.cs ---


namespace Humanizer;

class ThaiNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    public override string Convert(long numbermoney)
    {
        var Textreturn = "";
        if (numbermoney == 0)
        {
            return "";
        }

        if (numbermoney < 0)
        {
            Textreturn = "";
            numbermoney = -numbermoney;
        }

        if (numbermoney / 1000000 > 0)
        {
            Textreturn += Convert(numbermoney / 1000000) + "";
            numbermoney %= 1000000;
        }

        if (numbermoney / 100000 > 0)
        {
            Textreturn += Convert(numbermoney / 100000) + "";
            numbermoney %= 100000;
        }

        if (numbermoney / 10000 > 0)
        {
            Textreturn += Convert(numbermoney / 10000) + "";
            numbermoney %= 10000;
        }

        if (numbermoney / 1000 > 0)
        {
            Textreturn += Convert(numbermoney / 1000) + "";
            numbermoney %= 1000;
        }

        if (numbermoney / 100 > 0)
        {
            Textreturn += Convert(numbermoney / 100) + "";
            numbermoney %= 100;
        }

        if (numbermoney > 0)
        {
            if (Textreturn != "")
            {
                Textreturn += "";
            }

            var unitsMap = new[]
            {
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            };
            var tensMap = new[]
            {
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            };

            if (numbermoney < 20)
            {
                Textreturn += unitsMap[numbermoney];
            }
            else
            {
                Textreturn += tensMap[numbermoney / 10];
                if (numbermoney % 10 > 0)
                {
                    Textreturn += "" + unitsMap[numbermoney % 10];
                }
            }
        }

        return Textreturn;
    }

    public override string ConvertToOrdinal(int number) =>
        Convert(number);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\TurkishNumberToWordConverter.cs ---


using System.Collections.Generic;

namespace Humanizer;

class TurkishNumberToWordConverter :
    GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["sfr", "bir", "iki", "", "drt", "be", "alt", "yedi", "sekiz", "dokuz"];
    static readonly string[] TensMap = ["sfr", "on", "yirmi", "otuz", "krk", "elli", "altm", "yetmi", "seksen", "doksan"];

    static readonly Dictionary<char, string> OrdinalSuffix = new()
    {
        {
            '', "nc"
        },
        {
            'i', "inci"
        },
        {
            'u', "uncu"
        },
        {
            '', "nc"
        },
        {
            'o', "uncu"
        },
        {
            '', "nc"
        },
        {
            'e', "inci"
        },
        {
            'a', "nc"
        },
    };

    static readonly Dictionary<char, string> TupleSuffix = new()
    {
        {
            '', "l"
        },
        {
            'i', "li"
        },
        {
            'u', "lu"
        },
        {
            '', "l"
        },
        {
            'o', "lu"
        },
        {
            '', "l"
        },
        {
            'e', "li"
        },
        {
            'a', "l"
        },
    };

    public override string Convert(long input)
    {
        var number = input;
        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (number < 0)
        {
            return $"eksi {Convert(-number)}";
        }

        var parts = new List<string>();

        if (number / 1000000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000000)} kentilyon");
            number %= 1000000000000000000;
        }

        if (number / 1000000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000000)} katrilyon");
            number %= 1000000000000000;
        }

        if (number / 1000000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000000)} trilyon");
            number %= 1000000000000;
        }

        if (number / 1000000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000000)} milyar");
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            parts.Add($"{Convert(number / 1000000)} milyon");
            number %= 1000000;
        }

        var thousand = number / 1000;
        if (thousand > 0)
        {
            parts.Add($"{(thousand > 1 ? Convert(thousand) : "")} bin".Trim());
            number %= 1000;
        }

        var hundred = number / 100;
        if (hundred > 0)
        {
            parts.Add($"{(hundred > 1 ? Convert(hundred) : "")} yz".Trim());
            number %= 100;
        }

        if (number / 10 > 0)
        {
            parts.Add(TensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            parts.Add(UnitsMap[number]);
        }

        var toWords = string.Join(" ", parts);

        return toWords;
    }

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);
        var wordSuffix = string.Empty;
        var suffixFoundOnLastVowel = false;

        for (var i = word.Length - 1; i >= 0; i--)
        {
            if (OrdinalSuffix.TryGetValue(word[i], out wordSuffix))
            {
                suffixFoundOnLastVowel = i == word.Length - 1;
                break;
            }
        }

        if (word[^1] == 't')
        {
            word = word.Substring(0, word.Length - 1) + 'd';
        }

        if (suffixFoundOnLastVowel)
        {
            word = word.Substring(0, word.Length - 1);
        }

        return $"{word}{wordSuffix}";
    }

    public override string ConvertToTuple(int number)
    {
        switch (number)
        {
            case 1:
                return "tek";
            case 2:
                return "ift";
            default:
                var word = Convert(number);
                var wordSuffix = string.Empty;

                for (var i = word.Length - 1; i >= 0; i--)
                {
                    if (TupleSuffix.TryGetValue(word[i], out wordSuffix))
                    {
                        break;
                    }
                }

                return $"{word}{wordSuffix}";
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\UkrainianNumberToWordsConverter.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

class UkrainianNumberToWordsConverter : GenderedNumberToWordsConverter
{
    static readonly string[] HundredsMap = ["", "", "", "", "", "'", "", "", "", "'"];
    static readonly string[] TensMap = ["", "", "", "", "", "'", "", "", "", "'"];
    static readonly string[] UnitsMap = ["", "", "", "", "", "'", "", "", "", "'", "", "", "", "", "", "'", "", "", "", "'"];
    static readonly string[] UnitsOrdinalPrefixes = [string.Empty, string.Empty, "", "", "", "'", "", "", "", "'", "", "", "", "", "", "'", "", "", "", "'", ""];
    static readonly string[] TensOrdinalPrefixes = [string.Empty, "", "", "", "", "'", "", "", "", "'"];
    static readonly string[] TensOrdinal = [string.Empty, "", "", "", "", "'", "", "", "", "'"];
    static readonly string[] UnitsOrdinal = ["", "", "", "", "", "'", "", "", "", "'", "", "", "", "", "", "'", "", "", "", "'"];

    public override string Convert(long input, GrammaticalGender gender, bool addAnd = true)
    {
        if (input == 0)
        {
            return "";
        }

        var parts = new List<string>();

        if (input < 0)
        {
            parts.Add("");
        }

        CollectParts(parts, ref input, 1000000000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000000, GrammaticalGender.Masculine, "", "", "");
        CollectParts(parts, ref input, 1000, GrammaticalGender.Feminine, "", "", "");

        if (input != 0)
        {
            CollectPartsUnderOneThousand(parts, Math.Abs(input), gender);
        }

        return string.Join(" ", parts);
    }

    public override string ConvertToOrdinal(int number, GrammaticalGender gender)
    {
        if (number == 0)
        {
            return "" + GetEndingForGender(gender, number);
        }

        var parts = new List<string>();

        if (number < 0)
        {
            parts.Add("");
            number = -number;
        }

        CollectOrdinalParts(parts, ref number, 1000000000, GrammaticalGender.Masculine, "" + GetEndingForGender(gender, number), "", "", "");
        CollectOrdinalParts(parts, ref number, 1000000, GrammaticalGender.Masculine, "" + GetEndingForGender(gender, number), "", "", "");
        CollectOrdinalParts(parts, ref number, 1000, GrammaticalGender.Feminine, "" + GetEndingForGender(gender, number), "", "", "");

        if (number >= 100)
        {
            var ending = GetEndingForGender(gender, number);
            var hundreds = number / 100;
            number %= 100;
            if (number == 0)
            {
                parts.Add(UnitsOrdinalPrefixes[hundreds] + "" + ending);
            }
            else
            {
                parts.Add(HundredsMap[hundreds]);
            }
        }

        if (number >= 20)
        {
            var ending = GetEndingForGender(gender, number);
            var tens = number / 10;
            number %= 10;
            if (number == 0)
            {
                parts.Add(TensOrdinal[tens] + ending);
            }
            else
            {
                parts.Add(TensMap[tens]);
            }
        }

        if (number > 0)
        {
            parts.Add(UnitsOrdinal[number] + GetEndingForGender(gender, number));
        }

        return string.Join(" ", parts);
    }

    static void CollectPartsUnderOneThousand(ICollection<string> parts, long number, GrammaticalGender gender)
    {
        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            parts.Add(HundredsMap[hundreds]);
        }

        if (number >= 20)
        {
            var tens = number / 10;
            parts.Add(TensMap[tens]);
            number %= 10;
        }

        if (number > 0)
        {
            if (number == 1 && gender == GrammaticalGender.Feminine)
            {
                parts.Add("");
            }
            else if (number == 1 && gender == GrammaticalGender.Neuter)
            {
                parts.Add("");
            }
            else if (number == 2 && gender == GrammaticalGender.Feminine)
            {
                parts.Add("");
            }
            else if (number < 20)
            {
                parts.Add(UnitsMap[number]);
            }
        }
    }

    static string GetPrefix(int number)
    {
        var parts = new List<string>();

        if (number >= 100)
        {
            var hundreds = number / 100;
            number %= 100;
            if (hundreds != 1)
            {
                parts.Add(UnitsOrdinalPrefixes[hundreds] + "");
            }
            else
            {
                parts.Add("");
            }
        }

        if (number >= 20)
        {
            var tens = number / 10;
            number %= 10;
            parts.Add(TensOrdinalPrefixes[tens]);
        }

        if (number > 0)
        {
            parts.Add(number == 1 ? "" : UnitsOrdinalPrefixes[number]);
        }

        return string.Concat(parts);
    }

    static void CollectParts(ICollection<string> parts, ref long number, long divisor, GrammaticalGender gender, params string[] forms)
    {
        var result = Math.Abs(number / divisor);
        if (result == 0)
        {
            return;
        }

        CollectPartsUnderOneThousand(parts, result, gender);
        parts.Add(ChooseOneForGrammaticalNumber(result, forms));
        number = Math.Abs(number % divisor);
    }

    static void CollectOrdinalParts(ICollection<string> parts, ref int number, int divisor, GrammaticalGender gender, string prefixedForm, params string[] forms)
    {
        if (number < divisor)
        {
            return;
        }

        var result = number / divisor;
        number %= divisor;
        if (number == 0)
        {
            if (result == 1)
            {
                parts.Add(prefixedForm);
            }
            else
            {
                parts.Add(GetPrefix(result) + prefixedForm);
            }
        }
        else
        {
            CollectPartsUnderOneThousand(parts, result, gender);
            parts.Add(ChooseOneForGrammaticalNumber(result, forms));
        }
    }

    static int GetIndex(RussianGrammaticalNumber number)
    {
        if (number == RussianGrammaticalNumber.Singular)
        {
            return 0;
        }

        if (number == RussianGrammaticalNumber.Paucal)
        {
            return 1;
        }

        return 2;
    }

    static string ChooseOneForGrammaticalNumber(long number, string[] forms) =>
        forms[GetIndex(RussianGrammaticalNumberDetector.Detect(number))];

    static string GetEndingForGender(GrammaticalGender gender, int number)
    {
        switch (gender)
        {
            case GrammaticalGender.Masculine:
                if (number == 3)
                {
                    return "";
                }

                return "";
            case GrammaticalGender.Feminine:
                if (number == 3)
                {
                    return "";
                }

                return "";
            case GrammaticalGender.Neuter:
                if (number == 3)
                {
                    return "";
                }

                return "";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\UzbekCyrlNumberToWordConverter.cs ---


using System;

namespace Humanizer;

class UzbekCyrlNumberToWordConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["", "", "", "", "", "", "", "", "", ""];
    static readonly string[] TensMap = ["", "", "", "", "", "", "", "", "", ""];

    static readonly string[] OrdinalSuffixes = ["", ""];

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;
        if (number < 0)
        {
            return $" {Convert(-number, true)}";
        }

        return Convert(number, true);
    }

    static string Convert(int number, bool checkForHundredRule)
    {
        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (checkForHundredRule && number == 100)
        {
            return "";
        }

        var sb = new StringBuilder();

        if (number / 1000000000 > 0)
        {
            sb.AppendFormat("{0}  ", Convert(number / 1000000000, false));
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            sb.AppendFormat("{0}  ", Convert(number / 1000000, true));
            number %= 1000000;
        }

        var thousand = number / 1000;
        if (thousand > 0)
        {
            sb.AppendFormat("{0}  ", Convert(thousand, true));
            number %= 1000;
        }

        var hundred = number / 100;
        if (hundred > 0)
        {
            sb.AppendFormat("{0}  ", Convert(hundred, false));
            number %= 100;
        }

        if (number / 10 > 0)
        {
            sb.AppendFormat("{0} ", TensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            sb.AppendFormat("{0} ", UnitsMap[number]);
        }

        return sb
            .ToString()
            .Trim();
    }

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);
        var i = 0;
        if (string.IsNullOrEmpty(word))
        {
            return string.Empty;
        }

        var lastChar = word[^1];
        if (lastChar is '' or '')
        {
            i = 1;
        }

        return $"{word}{OrdinalSuffixes[i]}";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\UzbekLatnNumberToWordConverter.cs ---


using System;

namespace Humanizer;

class UzbekLatnNumberToWordConverter : GenderlessNumberToWordsConverter
{
    static readonly string[] UnitsMap = ["nol", "bir", "ikki", "uch", "to`rt", "besh", "olti", "yetti", "sakkiz", "to`qqiz"];
    static readonly string[] TensMap = ["nol", "o`n", "yigirma", "o`ttiz", "qirq", "ellik", "oltmish", "yetmish", "sakson", "to`qson"];

    static readonly string[] OrdinalSuffixes = ["inchi", "nchi"];

    public override string Convert(long input)
    {
        if (input is > int.MaxValue or < int.MinValue)
        {
            throw new NotImplementedException();
        }

        var number = (int) input;
        if (number < 0)
        {
            return $"minus {Convert(-number, true)}";
        }

        return Convert(number, true);
    }

    static string Convert(int number, bool checkForHundredRule)
    {
        if (number == 0)
        {
            return UnitsMap[0];
        }

        if (checkForHundredRule && number == 100)
        {
            return "yuz";
        }

        var sb = new StringBuilder();

        if (number / 1000000000 > 0)
        {
            sb.AppendFormat("{0} milliard ", Convert(number / 1000000000, false));
            number %= 1000000000;
        }

        if (number / 1000000 > 0)
        {
            sb.AppendFormat("{0} million ", Convert(number / 1000000, true));
            number %= 1000000;
        }

        var thousand = number / 1000;
        if (thousand > 0)
        {
            sb.AppendFormat("{0} ming ", Convert(thousand, true));
            number %= 1000;
        }

        var hundred = number / 100;
        if (hundred > 0)
        {
            sb.AppendFormat("{0} yuz ", Convert(hundred, false));
            number %= 100;
        }

        if (number / 10 > 0)
        {
            sb.AppendFormat("{0} ", TensMap[number / 10]);
            number %= 10;
        }

        if (number > 0)
        {
            sb.AppendFormat("{0} ", UnitsMap[number]);
        }

        return sb
            .ToString()
            .Trim();
    }

    public override string ConvertToOrdinal(int number)
    {
        var word = Convert(number);
        var i = 0;
        if (string.IsNullOrEmpty(word))
        {
            return string.Empty;
        }

        var lastChar = word[^1];
        if (lastChar is 'i' or 'a')
        {
            i = 1;
        }

        return $"{word}{OrdinalSuffixes[i]}";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\NumberToWords\VietnameseNumberToWordsConverter.cs ---


namespace Humanizer;

class VietnameseNumberToWordsConverter : GenderlessNumberToWordsConverter
{
    const int OneBillion = 1000000000;
    const int OneMillion = 1000000;

    static readonly string[] NumberVerbalPairs =
    [
        "", "mt", "hai", "ba", "bn", "nm", "su", "by", "tm", "chn"
    ];

    public override string Convert(long number) =>
        number == 0
            ? "khng"
            : ConvertImpl(number);

    public override string ConvertToOrdinal(int number) =>
        $"th {ConvertToOrdinalImpl(number)}";

    string ConvertToOrdinalImpl(int number) =>
        number switch
        {
            1 => "nht",
            2 => "nh",
            4 => "t",
            _ => Convert(number)
        };

    static string ConvertImpl(long number, bool hasTens = false, bool isGreaterThanOneHundred = false)
    {
        if (number >= OneBillion)
        {
            return string.Format(
                    "{0} t {1}",
                    ConvertImpl(number / OneBillion),
                    ConvertImpl(number % OneBillion, isGreaterThanOneHundred: true)
                )
                .TrimEnd();
        }

        if (number >= OneMillion)
        {
            return string.Format(
                    "{0} triu {1}",
                    ConvertImpl(number / OneMillion),
                    ConvertImpl(number % OneMillion, isGreaterThanOneHundred: true)
                )
                .TrimEnd();
        }

        if (number >= 1000)
        {
            return string.Format(
                    "{0} nghn {1}",
                    ConvertImpl(number / 1000),
                    ConvertImpl(number % 1000, isGreaterThanOneHundred: true)
                )
                .TrimEnd();
        }

        if (number >= 100)
        {
            return string.Format(
                    "{0} trm {1}",
                    NumberVerbalPairs[number / 100],
                    ConvertImpl(number % 100, isGreaterThanOneHundred: true)
                )
                .TrimEnd();
        }

        if (number >= 20)
        {
            return string.Format(
                    "{0} mi {1}",
                    NumberVerbalPairs[number / 10],
                    ConvertImpl(number % 10, hasTens: true)
                )
                .TrimEnd();
        }

        if (number == 14)
        {
            return "mi bn";
        }

        if (number == 11)
        {
            return "mi mt";
        }

        if (number >= 10)
        {
            return $"mi {ConvertImpl(number % 10, hasTens: true)}".TrimEnd();
        }

        if (number == 5 && hasTens)
        {
            return "lm";
        }

        if (number == 4 && hasTens)
        {
            return "t";
        }

        if (number == 1 && hasTens)
        {
            return "mt";
        }

        if (number > 0 && isGreaterThanOneHundred && !hasTens)
        {
            return $"linh {NumberVerbalPairs[number]}";
        }

        return NumberVerbalPairs[number];
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\ArmenianOrdinalizer.cs ---


namespace Humanizer;

class ArmenianOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString)
    {
        if (number is 1 or -1)
        {
            return numberString + "-";
        }

        return numberString + "-";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\AzerbaijaniOrdinalizer.cs ---


namespace Humanizer;

class AzerbaijaniOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        numberString + ".";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\DefaultOrdinalizer.cs ---


namespace Humanizer;

class DefaultOrdinalizer : IOrdinalizer
{
    public virtual string Convert(int number, string numberString, GrammaticalGender gender) =>
        Convert(number, numberString);

    public virtual string Convert(int number, string numberString) =>
        numberString;

    public virtual string Convert(int number, string numberString, WordForm wordForm) =>
        Convert(number, numberString, default, wordForm);

    public virtual string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm) =>
        Convert(number, numberString, gender);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\DutchOrdinalizer.cs ---


namespace Humanizer;

class DutchOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        // N/A in Dutch
        if (number == 0)
        {
            return "0";
        }

        return numberString + "e";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\EnglishOrdinalizer.cs ---


namespace Humanizer;

class EnglishOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString)
    {
        var nMod100 = number % 100;

        if (nMod100 is >= 11 and <= 20)
        {
            return numberString + "th";
        }

        return (number % 10) switch
        {
            1 => numberString + "st",
            2 => numberString + "nd",
            3 => numberString + "rd",
            _ => numberString + "th"
        };
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\FrenchOrdinalizer.cs ---


namespace Humanizer;

class FrenchOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        if (number == 1)
        {
            if (gender == GrammaticalGender.Feminine)
            {
                return numberString + "re";
            }

            return numberString + "er";
        }

        return numberString + "me";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\GermanOrdinalizer.cs ---


namespace Humanizer;

class GermanOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        numberString + ".";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\IcelandicOrdinalizer.cs ---


namespace Humanizer;

class IcelandicOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        numberString + ".";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\IOrdinalizer.cs ---


namespace Humanizer;

/// <summary>
/// The interface used to localise the Ordinalize method
/// </summary>
public interface IOrdinalizer
{
    /// <summary>
    /// Ordinalizes the number
    /// </summary>
    string Convert(int number, string numberString);

    /// <summary>
    /// Ordinalizes the number to a locale's specific form.
    /// </summary>
    string Convert(int number, string numberString, WordForm wordForm);

    /// <summary>
    /// Ordinalizes the number using the provided grammatical gender
    /// </summary>
    string Convert(int number, string numberString, GrammaticalGender gender);

    /// <summary>
    /// Ordinalizes the number to a locale's specific form using the provided grammatical gender.
    /// </summary>
    string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\ItalianOrdinalizer.cs ---


namespace Humanizer;

class ItalianOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        // No ordinal for 0 in italian (neologism apart)
        if (number == 0)
        {
            return "0";
        }

        if (gender == GrammaticalGender.Feminine)
        {
            return numberString + "";
        }

        return numberString + "";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\LuxembourgishOrdinalizer.cs ---


namespace Humanizer;

class LuxembourgishOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        numberString + ".";
}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\PortugueseOrdinalizer.cs ---


namespace Humanizer;

class PortugueseOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        // N/A in Portuguese
        if (number == 0)
        {
            return "0";
        }

        if (gender == GrammaticalGender.Feminine)
        {
            return numberString + "";
        }

        return numberString + "";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\RomanianOrdinalizer.cs ---


namespace Humanizer;

class RomanianOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        // No ordinal for 0 (zero) in Romanian.
        if (number == 0)
        {
            return "0";
        }

        // Exception from the rule.
        if (number == 1)
        {
            if (gender == GrammaticalGender.Feminine)
            {
                return "prima"; // ntia
            }

            return "primul"; // ntiul
        }

        if (gender == GrammaticalGender.Feminine)
        {
            return $"a {numberString}-a";
        }

        return $"al {numberString}-lea";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\RussianOrdinalizer.cs ---


namespace Humanizer;

class RussianOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Masculine)
        {
            return numberString + "-";
        }

        if (gender == GrammaticalGender.Feminine)
        {
            return numberString + "-";
        }

        return numberString + "-";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\SpanishOrdinalizer.cs ---


using System;

namespace Humanizer;

class SpanishOrdinalizer(CultureInfo culture) : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine, WordForm.Normal);

    public override string Convert(int number, string numberString, GrammaticalGender gender) =>
        Convert(number, numberString, gender, WordForm.Normal);

    public override string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm)
    {
        // N/A in Spanish
        if (number is 0 or int.MinValue)
        {
            return "0";
        }

        if (number < 0)
        {
            return Convert(-number, GetNumberString(-number), gender);
        }

        switch (gender)
        {
            case GrammaticalGender.Masculine:
            case GrammaticalGender.Neuter:
                return numberString + GetWordForm(number, wordForm);
            case GrammaticalGender.Feminine:
                return numberString + ".";
            default:
                throw new ArgumentOutOfRangeException(nameof(gender), gender, null);
        }
    }

    string GetNumberString(int number) =>
        number.ToString(culture);

    static string GetWordForm(int number, WordForm wordForm) =>
        (number % 10 == 1 || number % 10 == 3) && wordForm == WordForm.Abbreviation ? ".er" : ".";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\TurkishOrdinalizer.cs ---


namespace Humanizer;

class TurkishOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        numberString + ".";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Ordinalizers\UkrainianOrdinalizer.cs ---


namespace Humanizer;

class UkrainianOrdinalizer : DefaultOrdinalizer
{
    public override string Convert(int number, string numberString) =>
        Convert(number, numberString, GrammaticalGender.Masculine);

    public override string Convert(int number, string numberString, GrammaticalGender gender)
    {
        if (gender == GrammaticalGender.Masculine)
        {
            return numberString + "-";
        }

        if (gender == GrammaticalGender.Feminine)
        {
            if (number % 10 == 3)
            {
                return numberString + "-";
            }

            return numberString + "-";
        }

        if (gender == GrammaticalGender.Neuter)
        {
            if (number % 10 == 3)
            {
                return numberString + "-";
            }
        }

        return numberString + "-";
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\BrazilianPortugueseTimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class BrazilianPortugueseTimeOnlyToClockNotationConverter : ITimeOnlyToClockNotationConverter
{
    public string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive)
    {
        switch (time)
        {
            case { Hour: 0, Minute: 0 }:
                return "meia-noite";
            case { Hour: 12, Minute: 0 }:
                return "meio-dia";
        }

        var normalizedHour = time.Hour % 12;
        var normalizedMinutes = (int)(roundToNearestFive == ClockNotationRounding.NearestFiveMinutes
            ? 5 * Math.Round(time.Minute / 5.0)
            : time.Minute);

        return normalizedMinutes switch
        {
            00 => $"{normalizedHour.ToWords(GrammaticalGender.Feminine)} em ponto",
            30 => $"{normalizedHour.ToWords(GrammaticalGender.Feminine)} e meia",
            40 => $"vinte para as {(normalizedHour + 1).ToWords(GrammaticalGender.Feminine)}",
            45 => $"quinze para as {(normalizedHour + 1).ToWords(GrammaticalGender.Feminine)}",
            50 => $"dez para as {(normalizedHour + 1).ToWords(GrammaticalGender.Feminine)}",
            55 => $"cinco para as {(normalizedHour + 1).ToWords(GrammaticalGender.Feminine)}",
            60 => $"{(normalizedHour + 1).ToWords(GrammaticalGender.Feminine)} em ponto",
            _ => $"{normalizedHour.ToWords(GrammaticalGender.Feminine)} e {normalizedMinutes.ToWords()}"
        };
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\DefaultTimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class DefaultTimeOnlyToClockNotationConverter : ITimeOnlyToClockNotationConverter
{
    public string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive)
    {
        switch (time)
        {
            case { Hour: 0, Minute: 0 }:
                return "midnight";
            case { Hour: 12, Minute: 0 }:
                return "noon";
        }

        var normalizedHour = time.Hour % 12;
        var normalizedMinutes = (int)(roundToNearestFive == ClockNotationRounding.NearestFiveMinutes
            ? 5 * Math.Round(time.Minute / 5.0)
            : time.Minute);

        return normalizedMinutes switch
        {
            00 => $"{normalizedHour.ToWords()} o'clock",
            05 => $"five past {normalizedHour.ToWords()}",
            10 => $"ten past {normalizedHour.ToWords()}",
            15 => $"a quarter past {normalizedHour.ToWords()}",
            20 => $"twenty past {normalizedHour.ToWords()}",
            25 => $"twenty-five past {normalizedHour.ToWords()}",
            30 => $"half past {normalizedHour.ToWords()}",
            40 => $"twenty to {(normalizedHour + 1).ToWords()}",
            45 => $"a quarter to {(normalizedHour + 1).ToWords()}",
            50 => $"ten to {(normalizedHour + 1).ToWords()}",
            55 => $"five to {(normalizedHour + 1).ToWords()}",
            60 => $"{(normalizedHour + 1).ToWords()} o'clock",
            _ => $"{normalizedHour.ToWords()} {normalizedMinutes.ToWords()}"
        };
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\EsTimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class EsTimeOnlyToClockNotationConverter : ITimeOnlyToClockNotationConverter
{
    const int MORNING = 6;
    const int NOON = 12;
    const int AFTERNOON = 21;

    public string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive)
    {
        switch (time)
        {
            case { Hour: 0, Minute: 0 }:
                return "medianoche";

            case { Hour: 12, Minute: 0 }:
                return "medioda";
        }

        var article = GetArticle(time);
        var articleNextHour = GetArticle(time.AddHours(1));
        var hour = NormalizeHour(time).ToWords(GrammaticalGender.Feminine);
        var nextHour = NormalizeHour(time.AddHours(1)).ToWords(GrammaticalGender.Feminine);
        var dayPeriod = GetDayPeriod(time);
        var dayPeriodNextHour = GetDayPeriod(time.AddHours(1));

        var normalizedMinutes = (int)(roundToNearestFive == ClockNotationRounding.NearestFiveMinutes
            ? 5 * Math.Round(time.Minute / 5.0)
            : time.Minute);

        var clockNotationMap = new Dictionary<int, string>
        {
            { 0, $"{article} {hour} {dayPeriod}" },
            { 15 , $"{article} {hour} y cuarto {dayPeriod}" },
            { 30 , $"{article} {hour} y media {dayPeriod}"},
            { 35 , $"{articleNextHour} {nextHour} menos veinticinco {dayPeriodNextHour}"},
            { 40 , $"{articleNextHour} {nextHour} menos veinte {dayPeriodNextHour}"},
            { 45 , $"{articleNextHour} {nextHour} menos cuarto {dayPeriodNextHour}"},
            { 50 , $"{articleNextHour} {nextHour} menos diez {dayPeriodNextHour}"},
            { 55 , $"{articleNextHour} {nextHour} menos cinco {dayPeriodNextHour}"},
            { 60 , $"{articleNextHour} {nextHour} {dayPeriodNextHour}"},
        };

        return clockNotationMap.GetValueOrDefault(
            normalizedMinutes,
            $"{article} {hour} y {normalizedMinutes.ToWords()} {dayPeriod}");
    }

    static int NormalizeHour(TimeOnly time) =>
        time.Hour % 12 != 0 ? time.Hour % 12 : 12;

    static string GetArticle(TimeOnly time) =>
        time.Hour is 1 or 13 ? "la" : "las";

    static string GetDayPeriod(TimeOnly time)
    {
        if (IsEarlyMorning(time))
        {
            return "de la madrugada";
        }

        if (IsMorning(time))
        {
            return "de la maana";
        }

        if (IsAfternoon(time))
        {
            return "de la tarde";
        }

        return "de la noche";
    }

    static bool IsEarlyMorning(TimeOnly time) =>
        time.Hour is >= 1 and < MORNING;

    static bool IsMorning(TimeOnly time) =>
        time.Hour is >= MORNING and < NOON;

    static bool IsAfternoon(TimeOnly time) =>
        time.Hour is >= NOON and < AFTERNOON;
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\FrTimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class FrTimeOnlyToClockNotationConverter : ITimeOnlyToClockNotationConverter
{
    public string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive)
    {
        var normalizedMinutes = (int)(roundToNearestFive == ClockNotationRounding.NearestFiveMinutes
            ? 5 * Math.Round(time.Minute / 5.0)
            : time.Minute);

        return normalizedMinutes switch
        {
            00 => GetHourExpression(time.Hour),
            60 => GetHourExpression(time.Hour + 1),
            _ => $"{GetHourExpression(time.Hour)} {normalizedMinutes.ToWords(GrammaticalGender.Feminine)}"
        };

        static string GetHourExpression(int hour) =>
            hour switch
            {
                0 => "minuit",
                12 => "midi",
                _ => hour.ToWords(GrammaticalGender.Feminine) + (hour > 1 ? " heures" : " heure")
            };
    }
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\ITimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// The interface used to localise the ToClockNotation method.
/// </summary>
public interface ITimeOnlyToClockNotationConverter
{
    /// <summary>
    /// Converts the time to Clock Notation
    /// </summary>
    string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeToClockNotation\LbTimeOnlyToClockNotationConverter.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

class LbTimeOnlyToClockNotationConverter : ITimeOnlyToClockNotationConverter
{
    public string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive)
    {
        var roundedTime = roundToNearestFive is ClockNotationRounding.NearestFiveMinutes
            ? GetRoundedTime(time)
            : time;

        return roundedTime switch
        {
            { Hour: 0, Minute: 0 } => "Mtternuecht",
            { Hour: 12, Minute: 0 } => "Mtteg",
            _ => roundedTime.Minute switch
            {
                00 => GetHourExpression(roundedTime.Hour, "Auer"),
                15 => $"Virel op {GetHourExpression(roundedTime.Hour)}",
                25 => $"{GetMinuteExpression(30 - roundedTime.Minute, "vir")} hallwer {GetHourExpression(roundedTime.Hour + 1)}",
                30 => $"hallwer {GetHourExpression(roundedTime.Hour + 1)}",
                35 => $"{GetMinuteExpression(roundedTime.Minute - 30, "op")} hallwer {GetHourExpression(roundedTime.Hour + 1)}",
                45 => $"Virel vir {GetHourExpression(roundedTime.Hour + 1)}",
                60 => GetHourExpression(roundedTime.Hour + 1, "Auer"),
                01 => $"{GetMinuteExpression(roundedTime.Minute, "Minutt")} op {GetHourExpression(roundedTime.Hour)}",
                59 => $"{GetMinuteExpression(60 - roundedTime.Minute, "Minutt")} vir {GetHourExpression(roundedTime.Hour + 1)}",
                05 or 10 or 20 => $"{GetMinuteExpression(roundedTime.Minute, "op")} {GetHourExpression(roundedTime.Hour)}",
                40 or 50 or 55 => $"{GetMinuteExpression(60 - roundedTime.Minute, "vir")} {GetHourExpression(roundedTime.Hour + 1)}",
                > 00 and < 25 => $"{GetMinuteExpression(roundedTime.Minute, "Minutten")} op {GetHourExpression(roundedTime.Hour)}",
                > 25 and < 30 => $"{GetMinuteExpression(30 - roundedTime.Minute, "Minutten")} vir hallwer {GetHourExpression(roundedTime.Hour + 1)}",
                > 30 and < 35 => $"{GetMinuteExpression(roundedTime.Minute - 30, "Minutten")} op hallwer {GetHourExpression(roundedTime.Hour + 1)}",
                > 35 and < 60 => $"{GetMinuteExpression(60 - roundedTime.Minute, "Minutten")} vir {GetHourExpression(roundedTime.Hour + 1)}",
                _ => $"{GetHourExpression(time.Hour, "Auer")} {GetMinuteExpression(time.Minute)}"
            }
        };
    }

    private static TimeOnly GetRoundedTime(TimeOnly time)
    {
        var tempRoundedMinutes = (int)(5 * Math.Round(time.Minute / 5.0));
        var roundedHours = tempRoundedMinutes == 60 ? time.Hour + 1 : time.Hour;
        var roundedMinutes = tempRoundedMinutes == 60 ? 0 : tempRoundedMinutes;
        return new(roundedHours, roundedMinutes);
    }

    private static string GetMinuteExpression(int minute, string nextWord = "")
        => GetFormattedExpression(minute, nextWord);

    private static string GetHourExpression(int hour, string nextWord = "")
    {
        var normalizedHour = hour % 12;
        var hourExpression = normalizedHour == 0 ? 12 : normalizedHour;

        return GetFormattedExpression(hourExpression, nextWord);
    }

    private static string GetFormattedExpression(int number, string nextWord) =>
        (number switch
        {
            1 or 2 => $"{number.ToWords(GrammaticalGender.Feminine)} {nextWord}",
            7 => $"{number.ToWords(LuxembourgishFormatter.DoesEifelerRuleApply(nextWord) ? WordForm.Eifeler : WordForm.Normal)} {nextWord}",
            _ => $"{number.ToWords()} {nextWord}"
        }).TrimEnd();
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\DataUnit.cs ---


namespace Humanizer;

public enum DataUnit
{
    Bit,
    Byte,
    Kilobyte,
    Megabyte,
    Gigabyte,
    Terabyte
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\ResourceKeys.Common.cs ---


using System;

namespace Humanizer;

public partial class ResourceKeys
{
    static void ValidateRange(int count)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\ResourceKeys.DateHumanize.cs ---


using System;

namespace Humanizer;

public partial class ResourceKeys
{
    /// <summary>
    /// Encapsulates the logic required to get the resource keys for DateTime.Humanize
    /// </summary>
    public static class DateHumanize
    {
        /// <summary>
        /// Resource key for Now.
        /// </summary>
        public const string Now = "DateHumanize_Now";

        /// <summary>
        /// Resource key for Never.
        /// </summary>
        public const string Never = "DateHumanize_Never";

        /// <summary>
        /// Generates Resource Keys according to convention.
        /// </summary>
        /// <param name="timeUnit">Time unit</param>
        /// <param name="timeUnitTense">Is time unit in future or past</param>
        /// <param name="count">Number of units, default is One.</param>
        /// <returns>Resource key, like DateHumanize_SingleMinuteAgo</returns>
        public static string GetResourceKey(TimeUnit timeUnit, Tense timeUnitTense, int count = 1)
        {
            ValidateRange(count);

            if (count == 0)
            {
                return Now;
            }

            if (count == 1)
            {
                if (timeUnitTense == Tense.Future)
                {
                    return timeUnit switch
                    {
                        TimeUnit.Millisecond => "DateHumanize_SingleMillisecondFromNow",
                        TimeUnit.Second => "DateHumanize_SingleSecondFromNow",
                        TimeUnit.Minute => "DateHumanize_SingleMinuteFromNow",
                        TimeUnit.Hour => "DateHumanize_SingleHourFromNow",
                        TimeUnit.Day => "DateHumanize_SingleDayFromNow",
                        TimeUnit.Week => "DateHumanize_SingleWeekFromNow",
                        TimeUnit.Month => "DateHumanize_SingleMonthFromNow",
                        TimeUnit.Year => "DateHumanize_SingleYearFromNow",
                        _ => throw new ArgumentOutOfRangeException(nameof(timeUnit), timeUnit, null)
                    };
                }

                return timeUnit switch
                {
                    TimeUnit.Millisecond => "DateHumanize_SingleMillisecondAgo",
                    TimeUnit.Second => "DateHumanize_SingleSecondAgo",
                    TimeUnit.Minute => "DateHumanize_SingleMinuteAgo",
                    TimeUnit.Hour => "DateHumanize_SingleHourAgo",
                    TimeUnit.Day => "DateHumanize_SingleDayAgo",
                    TimeUnit.Week => "DateHumanize_SingleWeekAgo",
                    TimeUnit.Month => "DateHumanize_SingleMonthAgo",
                    TimeUnit.Year => "DateHumanize_SingleYearAgo",
                    _ => throw new ArgumentOutOfRangeException(nameof(timeUnit), timeUnit, null)
                };
            }

            if (timeUnitTense == Tense.Future)
            {
                return timeUnit switch
                {
                    TimeUnit.Millisecond => "DateHumanize_MultipleMillisecondsFromNow",
                    TimeUnit.Second => "DateHumanize_MultipleSecondsFromNow",
                    TimeUnit.Minute => "DateHumanize_MultipleMinutesFromNow",
                    TimeUnit.Hour => "DateHumanize_MultipleHoursFromNow",
                    TimeUnit.Day => "DateHumanize_MultipleDaysFromNow",
                    TimeUnit.Week => "DateHumanize_MultipleWeeksFromNow",
                    TimeUnit.Month => "DateHumanize_MultipleMonthsFromNow",
                    TimeUnit.Year => "DateHumanize_MultipleYearsFromNow",
                    _ => throw new ArgumentOutOfRangeException(nameof(timeUnit), timeUnit, null)
                };
            }

            return timeUnit switch
            {
                TimeUnit.Millisecond => "DateHumanize_MultipleMillisecondsAgo",
                TimeUnit.Second => "DateHumanize_MultipleSecondsAgo",
                TimeUnit.Minute => "DateHumanize_MultipleMinutesAgo",
                TimeUnit.Hour => "DateHumanize_MultipleHoursAgo",
                TimeUnit.Day => "DateHumanize_MultipleDaysAgo",
                TimeUnit.Week => "DateHumanize_MultipleWeeksAgo",
                TimeUnit.Month => "DateHumanize_MultipleMonthsAgo",
                TimeUnit.Year => "DateHumanize_MultipleYearsAgo",
                _ => throw new ArgumentOutOfRangeException(nameof(timeUnit), timeUnit, null)
            };
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\ResourceKeys.TimeSpanHumanize.cs ---


using System;

namespace Humanizer;

public partial class ResourceKeys
{
    /// <summary>
    /// Encapsulates the logic required to get the resource keys for TimeSpan.Humanize
    /// Examples: TimeSpanHumanize_SingleMinute, TimeSpanHumanize_MultipleHours.
    /// </summary>
    public static class TimeSpanHumanize
    {
        /// <summary>
        /// Generates Resource Keys according to convention.
        /// </summary>
        /// <param name="unit">Time unit, <see cref="TimeUnit"/>.</param>
        /// <param name="count">Number of units, default is One.</param>
        /// <param name="toWords">Result to words, default is false.</param>
        /// <returns>Resource key, like TimeSpanHumanize_SingleMinute</returns>
        public static string GetResourceKey(TimeUnit unit, int count = 1, bool toWords = false)
        {
            ValidateRange(count);

            if (count == 0 && toWords)
            {
                return "TimeSpanHumanize_Zero";
            }

            if (count == 1)
            {
                return unit switch
                {
                    TimeUnit.Millisecond => "TimeSpanHumanize_SingleMillisecond",
                    TimeUnit.Second => "TimeSpanHumanize_SingleSecond",
                    TimeUnit.Minute => "TimeSpanHumanize_SingleMinute",
                    TimeUnit.Hour => "TimeSpanHumanize_SingleHour",
                    TimeUnit.Day => "TimeSpanHumanize_SingleDay",
                    TimeUnit.Week => "TimeSpanHumanize_SingleWeek",
                    TimeUnit.Month => "TimeSpanHumanize_SingleMonth",
                    TimeUnit.Year => "TimeSpanHumanize_SingleYear",
                    _ => throw new ArgumentOutOfRangeException(nameof(unit), unit, null)
                };
            }

            return unit switch
            {
                TimeUnit.Millisecond => "TimeSpanHumanize_MultipleMilliseconds",
                TimeUnit.Second => "TimeSpanHumanize_MultipleSeconds",
                TimeUnit.Minute => "TimeSpanHumanize_MultipleMinutes",
                TimeUnit.Hour => "TimeSpanHumanize_MultipleHours",
                TimeUnit.Day => "TimeSpanHumanize_MultipleDays",
                TimeUnit.Week => "TimeSpanHumanize_MultipleWeeks",
                TimeUnit.Month => "TimeSpanHumanize_MultipleMonths",
                TimeUnit.Year => "TimeSpanHumanize_MultipleYears",
                _ => throw new ArgumentOutOfRangeException(nameof(unit), unit, null)
            };
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\ResourceKeys.TimeUnitSymbol.cs ---


using System;

namespace Humanizer;

public partial class ResourceKeys
{
    /// <summary>
    /// Encapsulates the logic required to get the resource keys for TimeUnit.ToSymbol
    /// </summary>
    public static class TimeUnitSymbol
    {
        /// <summary>
        /// Generates Resource Keys according to convention.
        /// Examples: TimeUnit_Minute, TimeUnit_Hour.
        /// </summary>
        /// <param name="unit">Time unit, <see cref="TimeUnit"/>.</param>
        /// <returns>Resource key, like TimeSpanHumanize_SingleMinute</returns>
        public static string GetResourceKey(TimeUnit unit) =>
            unit switch
            {
                TimeUnit.Millisecond => "TimeUnit_Millisecond",
                TimeUnit.Second => "TimeUnit_Second",
                TimeUnit.Minute => "TimeUnit_Minute",
                TimeUnit.Hour => "TimeUnit_Hour",
                TimeUnit.Day => "TimeUnit_Day",
                TimeUnit.Week => "TimeUnit_Week",
                TimeUnit.Month => "TimeUnit_Month",
                TimeUnit.Year => "TimeUnit_Year",
                _ => throw new ArgumentOutOfRangeException(nameof(unit), unit, null)
            };
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Resources.cs ---


using System;
using System.Resources;

namespace Humanizer;

/// <summary>
/// Provides access to the resources of Humanizer
/// </summary>
public static class Resources
{
    static readonly ResourceManager ResourceManager = new("Humanizer.Properties.Resources", typeof(Resources).GetTypeInfo()
        .Assembly);

    /// <summary>
    /// Returns the value of the specified string resource
    /// </summary>
    /// <param name="resourceKey">The name of the resource to retrieve.</param>
    /// <param name="culture">The culture of the resource to retrieve. If not specified, current thread's UI culture is used.</param>
    /// <returns>The value of the resource localized for the specified culture.</returns>
    public static string GetResource(string resourceKey, CultureInfo? culture = null)
    {
        var resource = ResourceManager.GetString(resourceKey, culture);

        if (resource == null || string.IsNullOrEmpty(resource))
        {
            throw new ArgumentException($@"The resource object with key '{resourceKey}' was not found", nameof(resourceKey));
        }

        return resource;
    }

    /// <summary>
    /// Tries to get the value of the specified string resource, without fallback
    /// </summary>
    /// <param name="resourceKey">The name of the resource to retrieve.</param>
    /// <param name="culture">The culture of the resource to retrieve. If not specified, current thread's UI culture is used.</param>
    /// <param name="result">The value of the resource localized for the specified culture if found; null otherwise.</param>
    /// <returns>true if the specified string resource was found for the given culture; otherwise, false.</returns>
    public static bool TryGetResource(string resourceKey, CultureInfo? culture, [NotNullWhen(true)] out string? result)
    {
        culture ??= CultureInfo.DefaultThreadCurrentCulture;
        var resourceSet = ResourceManager.GetResourceSet(culture, createIfNotExists: false, tryParents: false);
        result = resourceSet?.GetString(resourceKey);
        return result is not null;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\Tense.cs ---


namespace Humanizer;

/// <summary>
/// Enumerates the possible time references; past or future.
/// </summary>
public enum Tense
{
    Future,
    Past
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Localisation\TimeUnit.cs ---


namespace Humanizer;

public enum TimeUnit
{
    Millisecond,
    Second,
    Minute,
    Hour,
    Day,
    Week,
    Month,
    Year
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\ICulturedStringTransformer.cs ---


namespace Humanizer;

/// <summary>
/// Can transform a string with the given culture
/// </summary>
public interface ICulturedStringTransformer : IStringTransformer
{
    /// <summary>
    /// Transform the input
    /// </summary>
    /// <param name="input">String to be transformed</param>
    string Transform(string input, CultureInfo culture);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\IStringTransformer.cs ---


namespace Humanizer;

/// <summary>
/// Can transform a string
/// </summary>
public interface IStringTransformer
{
    /// <summary>
    /// Transform the input
    /// </summary>
    /// <param name="input">String to be transformed</param>
    string Transform(string input);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\To.cs ---


using System.Linq;

namespace Humanizer;

/// <summary>
/// A portal to string transformation using IStringTransformer
/// </summary>
public static class To
{
    /// <summary>
    /// Transforms a string using the provided transformers. Transformations are applied in the provided order.
    /// </summary>
    public static string Transform(this string input, params IStringTransformer[] transformers) =>
        transformers.Aggregate(input, (current, stringTransformer) => stringTransformer.Transform(current));

    /// <summary>
    /// Transforms a string using the provided transformers. Transformations are applied in the provided order.
    /// </summary>
    public static string Transform(this string input, CultureInfo culture, params ICulturedStringTransformer[] transformers) =>
        transformers.Aggregate(input, (current, stringTransformer) => stringTransformer.Transform(current, culture));

    /// <summary>
    /// Changes string to title case
    /// </summary>
    /// <example>
    /// "INvalid caSEs arE corrected" -> "Invalid Cases Are Corrected"
    /// </example>
    public static ICulturedStringTransformer TitleCase { get; } = new ToTitleCase();

    /// <summary>
    /// Changes the string to lower case
    /// </summary>
    /// <example>
    /// "Sentence casing" -> "sentence casing"
    /// </example>
    public static ICulturedStringTransformer LowerCase { get; } = new ToLowerCase();

    /// <summary>
    /// Changes the string to upper case
    /// </summary>
    /// <example>
    /// "lower case statement" -> "LOWER CASE STATEMENT"
    /// </example>
    public static ICulturedStringTransformer UpperCase { get; } = new ToUpperCase();

    /// <summary>
    /// Changes the string to sentence case
    /// </summary>
    /// <example>
    /// "lower case statement" -> "Lower case statement"
    /// </example>
    public static ICulturedStringTransformer SentenceCase { get; } = new ToSentenceCase();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\ToLowerCase.cs ---


namespace Humanizer;

class ToLowerCase : ICulturedStringTransformer
{
    public string Transform(string input) =>
        Transform(input, null);

    public string Transform(string input, CultureInfo? culture)
    {
        culture ??= CultureInfo.DefaultThreadCurrentCulture;

        return culture.TextInfo.ToLower(input);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\ToSentenceCase.cs ---


namespace Humanizer;

class ToSentenceCase : ICulturedStringTransformer
{
    public string Transform(string input) =>
        Transform(input, null);

    public string Transform(string input, CultureInfo? culture)
    {
        culture ??= CultureInfo.DefaultThreadCurrentCulture;

        if (input.Length >= 1)
        {
            return culture.TextInfo.ToUpper(input[0]) + input.Substring(1);
        }

        return culture.TextInfo.ToUpper(input);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\ToTitleCase.cs ---


using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

class ToTitleCase : ICulturedStringTransformer
{
    public string Transform(string input) =>
        Transform(input, null);

    static Regex regex = new(@"(\w|[^\u0000-\u007F])+'?\w*", RegexOptions.Compiled);

    public string Transform(string input, CultureInfo? culture)
    {
        culture ??= CultureInfo.DefaultThreadCurrentCulture;
        var matches = regex.Matches(input);
        var builder = new StringBuilder(input);
        var textInfo = culture.TextInfo;
        foreach (Match word in matches)
        {
            var value = word.Value;
            if (AllCapitals(value) || lookups.Contains(value))
            {
                continue;
            }

            builder[word.Index] = textInfo.ToUpper(value[0]);
            Overwrite(builder, word.Index + 1, textInfo.ToLower(value[1..]));
        }

        return builder.ToString();
    }

    static void Overwrite(StringBuilder builder, int index, string replacement) =>
        builder
            .Remove(index, replacement.Length)
            .Insert(index, replacement);

    static bool AllCapitals(string input)
    {
        foreach (var ch in input)
        {
            if (!char.IsUpper(ch))
            {
                return false;
            }
        }

        return true;
    }

    static FrozenSet<string> lookups;

    static ToTitleCase()
    {
        var articles = new List<string> { "a", "an", "the" };
        var conjunctions = new List<string> { "and", "as", "but", "if", "nor", "or", "so", "yet" };
        var prepositions = new List<string> { "as", "at", "by", "for", "in", "of", "off", "on", "to", "up", "via" };

        lookups = articles.Concat(conjunctions).Concat(prepositions).ToFrozenSet();
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Transformer\ToUpperCase.cs ---


namespace Humanizer;

class ToUpperCase : ICulturedStringTransformer
{
    public string Transform(string input) =>
        Transform(input, null);

    public string Transform(string input, CultureInfo? culture)
    {
        culture ??= CultureInfo.DefaultThreadCurrentCulture;

        return culture.TextInfo.ToUpper(input);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Truncation\FixedLengthTruncator.cs ---


namespace Humanizer;

/// <summary>
/// Truncate a string to a fixed length
/// </summary>
class FixedLengthTruncator : ITruncator
{
    [return: NotNullIfNotNull(nameof(value))]
    public string? Truncate(string? value, int length, string? truncationString, TruncateFrom truncateFrom = TruncateFrom.Right)
    {
        if (value == null)
        {
            return null;
        }

        if (value.Length == 0)
        {
            return value;
        }

        if (truncationString == null || truncationString.Length > length)
        {
            return truncateFrom == TruncateFrom.Right
                ? value.Substring(0, length)
                : value.Substring(value.Length - length);
        }

        if (truncateFrom == TruncateFrom.Left)
        {
            return value.Length > length
                ? truncationString + value.Substring(value.Length - length + truncationString.Length)
                : value;
        }

        return value.Length > length
            ? value.Substring(0, length - truncationString.Length) + truncationString
            : value;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Truncation\FixedNumberOfCharactersTruncator.cs ---


using System.Linq;

namespace Humanizer;

/// <summary>
/// Truncate a string to a fixed number of letters or digits
/// </summary>
class FixedNumberOfCharactersTruncator : ITruncator
{
    [return: NotNullIfNotNull(nameof(value))]
    public string? Truncate(string? value, int length, string? truncationString, TruncateFrom truncateFrom = TruncateFrom.Right)
    {
        if (value == null)
        {
            return null;
        }

        if (value.Length == 0)
        {
            return value;
        }

        truncationString ??= string.Empty;

        if (truncationString.Length > length)
        {
            return truncateFrom == TruncateFrom.Right ? value.Substring(0, length) : value.Substring(value.Length - length);
        }

        var alphaNumericalCharactersProcessed = 0;

        if (value.Count(char.IsLetterOrDigit) <= length)
        {
            return value;
        }

        if (truncateFrom == TruncateFrom.Left)
        {
            for (var i = value.Length - 1; i > 0; i--)
            {
                if (char.IsLetterOrDigit(value[i]))
                {
                    alphaNumericalCharactersProcessed++;
                }

                if (alphaNumericalCharactersProcessed + truncationString.Length == length)
                {
                    return truncationString + value.Substring(i);
                }
            }
        }

        for (var i = 0; i < value.Length - truncationString.Length; i++)
        {
            if (char.IsLetterOrDigit(value[i]))
            {
                alphaNumericalCharactersProcessed++;
            }

            if (alphaNumericalCharactersProcessed + truncationString.Length == length)
            {
                return value.Substring(0, i + 1) + truncationString;
            }
        }

        return value;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Truncation\FixedNumberOfWordsTruncator.cs ---


using System;
using System.Linq;

namespace Humanizer;

/// <summary>
/// Truncate a string to a fixed number of words
/// </summary>
class FixedNumberOfWordsTruncator : ITruncator
{
    [return: NotNullIfNotNull(nameof(value))]
    public string? Truncate(string? value, int length, string? truncationString, TruncateFrom truncateFrom = TruncateFrom.Right)
    {
        if (value == null)
        {
            return null;
        }

        if (value.Length == 0)
        {
            return value;
        }

        var numberOfWords = value.Split((char[]?)null, StringSplitOptions.RemoveEmptyEntries).Count();
        if (numberOfWords <= length)
        {
            return value;
        }

        return truncateFrom == TruncateFrom.Left
            ? TruncateFromLeft(value, length, truncationString)
            : TruncateFromRight(value, length, truncationString);
    }

    static string TruncateFromRight(string value, int length, string? truncationString)
    {
        var lastCharactersWasWhiteSpace = true;
        var numberOfWordsProcessed = 0;
        for (var i = 0; i < value.Length; i++)
        {
            if (char.IsWhiteSpace(value[i]))
            {
                if (!lastCharactersWasWhiteSpace)
                {
                    numberOfWordsProcessed++;
                }

                lastCharactersWasWhiteSpace = true;

                if (numberOfWordsProcessed == length)
                {
                    return value.Substring(0, i) + truncationString;
                }
            }
            else
            {
                lastCharactersWasWhiteSpace = false;
            }
        }
        return value + truncationString;
    }

    static string TruncateFromLeft(string value, int length, string? truncationString)
    {
        var lastCharactersWasWhiteSpace = true;
        var numberOfWordsProcessed = 0;
        for (var i = value.Length - 1; i > 0; i--)
        {
            if (char.IsWhiteSpace(value[i]))
            {
                if (!lastCharactersWasWhiteSpace)
                {
                    numberOfWordsProcessed++;
                }

                lastCharactersWasWhiteSpace = true;

                if (numberOfWordsProcessed == length)
                {
                    return truncationString + value.Substring(i + 1).TrimEnd();
                }
            }
            else
            {
                lastCharactersWasWhiteSpace = false;
            }
        }
        return truncationString + value;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Truncation\ITruncator.cs ---


namespace Humanizer;

/// <summary>
/// Can truncate a string.
/// </summary>
public interface ITruncator
{
    /// <summary>
    /// Truncate a string
    /// </summary>
    /// <param name="value">The string to truncate</param>
    /// <param name="length">The length to truncate to</param>
    /// <param name="truncationString">The string used to truncate with</param>
    /// <param name="truncateFrom">The enum value used to determine from where to truncate the string</param>
    /// <returns>The truncated string</returns>
    [return: NotNullIfNotNull(nameof(value))]
    string? Truncate(string? value, int length, string? truncationString, TruncateFrom truncateFrom = TruncateFrom.Right);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Truncation\Truncator.cs ---


namespace Humanizer;

/// <summary>
/// Gets a ITruncator
/// </summary>
public static class Truncator
{
    /// <summary>
    /// Fixed length truncator
    /// </summary>
    public static ITruncator FixedLength => new FixedLengthTruncator();

    /// <summary>
    /// Fixed number of characters truncator
    /// </summary>
    public static ITruncator FixedNumberOfCharacters => new FixedNumberOfCharactersTruncator();

    /// <summary>
    /// Fixed number of words truncator
    /// </summary>
    public static ITruncator FixedNumberOfWords => new FixedNumberOfWordsTruncator();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\ArticlePrefixSort.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Contains methods for removing, appending and prepending article prefixes for sorting strings ignoring the article.
/// </summary>
public static class EnglishArticle
{
    static Regex _regex = new("^((The)|(the)|(a)|(A)|(An)|(an))\\s\\w+", RegexOptions.Compiled);

    /// <summary>
    /// Removes the prefixed article and appends it to the same string.
    /// </summary>
    /// <param name="items">The input array of strings</param>
    /// <returns>Sorted string array</returns>
    public static string[] AppendArticlePrefix(string[] items)
    {
        if (items.Length == 0)
        {
            throw new ArgumentOutOfRangeException(nameof(items));
        }

        var transformed = new string[items.Length];

        for (var i = 0; i < items.Length; i++)
        {
            var item = items[i]
                .AsSpan();
            if (_regex.IsMatch(item))
            {
                var indexOf = item.IndexOf(' ');
                var removed = item[indexOf..]
                    .TrimStart();
                var article = item[..indexOf]
                    .TrimEnd();
                transformed[i] = $"{removed} {article}";
            }
            else
            {
                transformed[i] = item
                    .Trim()
                    .ToString();
            }
        }

        Array.Sort(transformed);
        return transformed;
    }

    /// <summary>
    /// Removes the previously appended article and prepends it to the same string.
    /// </summary>
    /// <param name="appended">Sorted string array</param>
    /// <returns>String array</returns>
    public static string[] PrependArticleSuffix(string[] appended)
    {
        var inserted = new string[appended.Length];
        var the = " the".AsSpan();
        var an = " an".AsSpan();
        var a = " a".AsSpan();

        for (var i = 0; i < appended.Length; i++)
        {
            var append = appended[i]
                .AsSpan();
            if (append.EndsWith(the, StringComparison.OrdinalIgnoreCase))
            {
                inserted[i] = ToOriginalFormat(append, 3);
            }
            else if (append.EndsWith(an, StringComparison.OrdinalIgnoreCase))
            {
                inserted[i] = ToOriginalFormat(append, 2);
            }
            else if (append.EndsWith(a, StringComparison.OrdinalIgnoreCase))
            {
                inserted[i] = ToOriginalFormat(append, 1);
            }
            else
            {
                inserted[i] = appended[i];
            }
        }

        return inserted;
    }

    static string ToOriginalFormat(ReadOnlySpan<System.Char> value, int suffixLength) =>
        $"{value[^suffixLength..]} {value[..^(suffixLength + 1)]}";
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\CasingExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// ApplyCase method to allow changing the case of a sentence easily
/// </summary>
public static class CasingExtensions
{
    /// <summary>
    /// Changes the casing of the provided input
    /// </summary>
    public static string ApplyCase(this string input, LetterCasing casing) =>
        casing switch
        {
            LetterCasing.Title => input.Transform(To.TitleCase),
            LetterCasing.LowerCase => input.Transform(To.LowerCase),
            LetterCasing.AllCaps => input.Transform(To.UpperCase),
            LetterCasing.Sentence => input.Transform(To.SentenceCase),
            _ => throw new ArgumentOutOfRangeException(nameof(casing))
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\ClockNotationRounding.cs ---


namespace Humanizer;

/// <summary>
/// Options for specifying readable clock notation
/// </summary>
public enum ClockNotationRounding
{
    /// <summary>
    /// Do not round minutes
    /// </summary>
    None,

    /// <summary>
    /// Round time to nearest five minutes
    /// </summary>
    NearestFiveMinutes
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\CollectionHumanizeExtensions.cs ---


using System;
using System.Collections.Generic;

namespace Humanizer;

/// <summary>
/// Humanizes an IEnumerable into a human readable list
/// </summary>
public static class CollectionHumanizeExtensions
{
    /// <summary>
    /// Formats the collection for display, calling ToString() on each object and
    /// using the default separator for the current culture.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection) =>
        Configurator.CollectionFormatter.Humanize(collection);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
    /// and using the default separator for the current culture.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection, Func<T, string> displayFormatter)
    {
        if (displayFormatter == null)
        {
            throw new ArgumentNullException(nameof(displayFormatter));
        }

        return Configurator.CollectionFormatter.Humanize(collection, displayFormatter);
    }

    /// <summary>
    /// Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
    /// and using the default separator for the current culture.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection, Func<T, object> displayFormatter)
    {
        if (displayFormatter == null)
        {
            throw new ArgumentNullException(nameof(displayFormatter));
        }

        return Configurator.CollectionFormatter.Humanize(collection, displayFormatter);
    }

    /// <summary>
    /// Formats the collection for display, calling ToString() on each object
    /// and using the provided separator.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection, string separator) =>
        Configurator.CollectionFormatter.Humanize(collection, separator);

    /// <summary>
    /// Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
    /// and using the provided separator.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection, Func<T, string> displayFormatter, string separator)
    {
        if (displayFormatter == null)
        {
            throw new ArgumentNullException(nameof(displayFormatter));
        }

        return Configurator.CollectionFormatter.Humanize(collection, displayFormatter, separator);
    }

    /// <summary>
    /// Formats the collection for display, calling <paramref name="displayFormatter"/> on each element
    /// and using the provided separator.
    /// </summary>
    public static string Humanize<T>(this IEnumerable<T> collection, Func<T, object> displayFormatter, string separator)
    {
        if (displayFormatter == null)
        {
            throw new ArgumentNullException(nameof(displayFormatter));
        }

        return Configurator.CollectionFormatter.Humanize(collection, displayFormatter, separator);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateHumanizeExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Humanizes DateTime into human readable sentence
/// </summary>
public static class DateHumanizeExtensions
{
    /// <summary>
    /// Turns the current or provided date into a human readable sentence
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="utcDate">Nullable boolean value indicating whether the date is in UTC or local. If null, current date is used with the same DateTimeKind of input</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateTime input, bool? utcDate = null, DateTime? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        var comparisonBase = dateToCompareAgainst ?? DateTime.UtcNow;
        utcDate ??= input.Kind != DateTimeKind.Local;
        comparisonBase = utcDate.Value ? comparisonBase.ToUniversalTime() : comparisonBase.ToLocalTime();

        return Configurator.DateTimeHumanizeStrategy.Humanize(input, comparisonBase, culture);
    }

    /// <summary>
    /// Turns the current or provided date into a human readable sentence, overload for the nullable DateTime, returning 'never' in case null
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="utcDate">Nullable boolean value indicating whether the date is in UTC or local. If null, current date is used with the same DateTimeKind of input</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateTime? input, bool? utcDate = null, DateTime? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        if (input.HasValue)
        {
            return Humanize(input.Value, utcDate, dateToCompareAgainst, culture);
        }

        return Configurator
            .GetFormatter(culture)
            .DateHumanize_Never();
    }

    /// <summary>
    /// Turns the current or provided date into a human readable sentence
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateTimeOffset input, DateTimeOffset? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        var comparisonBase = dateToCompareAgainst ?? DateTimeOffset.UtcNow;

        return Configurator.DateTimeOffsetHumanizeStrategy.Humanize(input, comparisonBase, culture);
    }

    /// <summary>
    /// Turns the current or provided date into a human readable sentence, overload for the nullable DateTimeOffset, returning 'never' in case null
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateTimeOffset? input, DateTimeOffset? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        if (input.HasValue)
        {
            return Humanize(input.Value, dateToCompareAgainst, culture);
        }

        return Configurator
            .GetFormatter(culture)
            .DateHumanize_Never();
    }

#if NET6_0_OR_GREATER
    /// <summary>
    /// Turns the current or provided date into a human readable sentence
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateOnly input, DateOnly? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        var comparisonBase = dateToCompareAgainst ?? DateOnly.FromDateTime(DateTime.UtcNow);
        return Configurator.DateOnlyHumanizeStrategy.Humanize(input, comparisonBase, culture);
    }

    /// <summary>
    /// Turns the current or provided date into a human readable sentence, overload for the nullable DateTime, returning 'never' in case null
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="dateToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this DateOnly? input, DateOnly? dateToCompareAgainst = null, CultureInfo? culture = null)
    {
        if (input.HasValue)
        {
            return Humanize(input.Value, dateToCompareAgainst, culture);
        }

        return Configurator
            .GetFormatter(culture)
            .DateHumanize_Never();
    }

    /// <summary>
    /// Turns the current or provided time into a human readable sentence
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="useUtc">If <paramref name="timeToCompareAgainst"/> is null, used to determine if the current time is UTC or local. Defaults to UTC.</param>
    /// <param name="timeToCompareAgainst">Date to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this TimeOnly input, TimeOnly? timeToCompareAgainst = null, bool useUtc = true, CultureInfo? culture = null)
    {
        var comparisonBase = timeToCompareAgainst ?? TimeOnly.FromDateTime(useUtc ? DateTime.UtcNow : DateTime.Now);

        return Configurator.TimeOnlyHumanizeStrategy.Humanize(input, comparisonBase, culture);
    }

    /// <summary>
    /// Turns the current or provided time into a human readable sentence, overload for the nullable TimeOnly, returning 'never' in case null
    /// </summary>
    /// <param name="input">The date to be humanized</param>
    /// <param name="useUtc">If <paramref name="timeToCompareAgainst"/> is null, used to determine if the current time is UTC or local. Defaults to UTC.</param>
    /// <param name="timeToCompareAgainst">Time to compare the input against. If null, current date is used as base</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>distance of time in words</returns>
    public static string Humanize(this TimeOnly? input, TimeOnly? timeToCompareAgainst = null, bool useUtc = true, CultureInfo? culture = null)
    {
        if (input.HasValue)
        {
            return Humanize(input.Value, timeToCompareAgainst, useUtc, culture);
        }

        return Configurator
            .GetFormatter(culture)
            .DateHumanize_Never();
    }

#endif
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\DateToOrdinalWordsExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Humanizes DateTime into human readable sentence
/// </summary>
public static class DateToOrdinalWordsExtensions
{
    /// <summary>
    /// Turns the provided date into ordinal words
    /// </summary>
    /// <param name="input">The date to be made into ordinal words</param>
    /// <returns>The date in ordinal words</returns>
    public static string ToOrdinalWords(this DateTime input) =>
        Configurator.DateToOrdinalWordsConverter.Convert(input);

    /// <summary>
    /// Turns the provided date into ordinal words
    /// </summary>
    /// <param name="input">The date to be made into ordinal words</param>
    /// <param name="grammaticalCase">The grammatical case to use for output words</param>
    /// <returns>The date in ordinal words</returns>
    public static string ToOrdinalWords(this DateTime input, GrammaticalCase grammaticalCase) =>
        Configurator.DateToOrdinalWordsConverter.Convert(input, grammaticalCase);

#if NET6_0_OR_GREATER
    /// <summary>
    /// Turns the provided date into ordinal words
    /// </summary>
    /// <param name="input">The date to be made into ordinal words</param>
    /// <returns>The date in ordinal words</returns>
    public static string ToOrdinalWords(this DateOnly input) =>
        Configurator.DateOnlyToOrdinalWordsConverter.Convert(input);

    /// <summary>
    /// Turns the provided date into ordinal words
    /// </summary>
    /// <param name="input">The date to be made into ordinal words</param>
    /// <param name="grammaticalCase">The grammatical case to use for output words</param>
    /// <returns>The date in ordinal words</returns>
    public static string ToOrdinalWords(this DateOnly input, GrammaticalCase grammaticalCase) =>
        Configurator.DateOnlyToOrdinalWordsConverter.Convert(input, grammaticalCase);
#endif
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\EnumCache.cs ---


using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;

namespace Humanizer;

static class EnumCache<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] T>
    where T : struct, Enum
{
    static (T Zero, FrozenDictionary<T, string> Humanized, Dictionary<string, T> Dehumanized, FrozenSet<T> Values, bool IsBitFieldEnum) info;

    static EnumCache()
    {
        var values = EnumPolyfill.GetValues<T>().ToFrozenSet();
        var type = typeof(T);
        var zero = (T)Convert.ChangeType(Enum.ToObject(type, 0), type);
        var humanized = new Dictionary<T, string>();
        var dehumanized = new Dictionary<string, T>(StringComparer.OrdinalIgnoreCase);
        foreach (var value in values)
        {
            var description = GetDescription(value);
            humanized[value] = description;
            dehumanized[description] = value;
        }

        var isBitFieldEnum = type.GetCustomAttribute(typeof(FlagsAttribute)) != null;
        info = (
            zero,
            humanized.ToFrozenDictionary(),
            dehumanized,
            values,
            isBitFieldEnum);
    }

    public static (T Zero, FrozenDictionary<T, string> Humanized, FrozenSet<T> Values) GetInfo() =>
        (info.Zero, info.Humanized, info.Values);

    public static Dictionary<string, T> GetDehumanized() =>
        info.Dehumanized;

    public static bool TreatAsFlags(T input)
    {
        var type = typeof(T);
        if (!info.IsBitFieldEnum)
        {
            return false;
        }

        return !Enum.IsDefined(type, input);
    }

    static string GetDescription(T input)
    {
        var type = typeof(T);
        var caseName = input.ToString();
        var member = type.GetField(caseName)!;

        if (TryGetDescription(member, out var description))
        {
            return description;
        }

        return caseName.Humanize();
    }

    static bool TryGetDescription(MemberInfo member, [NotNullWhen(true)] out string? description)
    {
        var displayAttribute = member.GetCustomAttribute<DisplayAttribute>();
        if (displayAttribute != null)
        {
            description = displayAttribute.GetDescription() ?? displayAttribute.GetName();

            return description != null;
        }

        foreach (var attr in member.GetCustomAttributes())
        {
            var attrType = attr.GetType();
            foreach (var property in attrType.GetRuntimeProperties())
            {
                if (property.PropertyType == typeof(string) &&
                    Configurator.EnumDescriptionPropertyLocator(property))
                {
                    description = (string)property.GetValue(attr, null)!;
                    return true;
                }
            }
        }

        description = null;
        return false;
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\EnumDehumanizeExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Contains extension methods for dehumanizing Enum string values.
/// </summary>
public static class EnumDehumanizeExtensions
{
    /// <summary>
    /// Dehumanizes a string into the Enum it was originally Humanized from!
    /// </summary>
    /// <typeparam name="TTargetEnum">The target enum</typeparam>
    /// <param name="input">The string to be converted</param>
    /// <exception cref="ArgumentException">If TTargetEnum is not an enum</exception>
    /// <exception cref="NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
    public static TTargetEnum DehumanizeTo<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] TTargetEnum>(this string input)
        where TTargetEnum : struct, Enum =>
        DehumanizeToPrivate<TTargetEnum>(input, OnNoMatch.ThrowsException)!.Value;

    /// <summary>
    /// Dehumanizes a string into the Enum it was originally Humanized from!
    /// </summary>
    /// <typeparam name="TTargetEnum">The target enum</typeparam>
    /// <param name="input">The string to be converted</param>
    /// <exception cref="ArgumentException">If TTargetEnum is not an enum</exception>
    /// <exception cref="NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
    public static TTargetEnum? DehumanizeTo<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] TTargetEnum>(this string input, OnNoMatch onNoMatch = OnNoMatch.ThrowsException)
        where TTargetEnum : struct, Enum =>
        DehumanizeToPrivate<TTargetEnum>(input, onNoMatch);

    static MethodInfo dehumanizeToMethod = typeof(EnumDehumanizeExtensions)
        .GetMethod("DehumanizeTo", [typeof(string), typeof(OnNoMatch)])!;

    /// <summary>
    /// Dehumanizes a string into the Enum it was originally Humanized from!
    /// </summary>
    /// <param name="input">The string to be converted</param>
    /// <param name="targetEnum">The target enum</param>
    /// <param name="onNoMatch">What to do when input is not matched to the enum.</param>
    /// <exception cref="NoMatchFoundException">Couldn't find any enum member that matches the string</exception>
    /// <exception cref="ArgumentException">If targetEnum is not an enum</exception>
    public static Enum DehumanizeTo(this string input, Type targetEnum, OnNoMatch onNoMatch = OnNoMatch.ThrowsException)
    {
        var genericMethod = dehumanizeToMethod.MakeGenericMethod(targetEnum);
        try
        {
            return (Enum) genericMethod.Invoke(null, [input, onNoMatch])!;
        }
        catch (TargetInvocationException exception)
        {
            throw exception.InnerException!;
        }
    }

    static T? DehumanizeToPrivate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] T>(string input, OnNoMatch onNoMatch)
        where T : struct, Enum
    {
        var dehumanized = EnumCache<T>.GetDehumanized();
        if (dehumanized.TryGetValue(input, out var value))
        {
            return value;
        }

        if (onNoMatch != OnNoMatch.ThrowsException)
        {
            return null;
        }

        throw new NoMatchFoundException($"Couldn't find any enum member that matches the string '{input}'");
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\EnumHumanizeExtensions.cs ---


using System;
using System.Linq;

namespace Humanizer;

/// <summary>
/// Contains extension methods for humanizing Enums
/// </summary>
public static class EnumHumanizeExtensions
{
    /// <summary>
    /// Turns an enum member into a human readable string; e.g. AnonymousUser -> Anonymous user. It also honors DescriptionAttribute data annotation
    /// </summary>
    /// <param name="input">The enum member to be humanized</param>
    public static string Humanize<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] T>(this T input)
        where T : struct, Enum
    {
        var (zero, humanized, values) = EnumCache<T>.GetInfo();
        if (EnumCache<T>.TreatAsFlags(input))
        {
            return values
                .Where(_ => _.CompareTo(zero) != 0 &&
                            input.HasFlag(_))
                .Select(_ => _.Humanize())
                .Humanize();
        }

        return humanized[input];
    }


    /// <summary>
    /// Turns an enum member into a human readable string with the provided casing; e.g. AnonymousUser with Title casing -> Anonymous User. It also honors DescriptionAttribute data annotation
    /// </summary>
    /// <param name="input">The enum member to be humanized</param>
    /// <param name="casing">The casing to use for humanizing the enum member</param>
    public static string Humanize<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicFields)] T>(this T input, LetterCasing casing)
        where T : struct, Enum
    {
        var humanizedEnum = Humanize(input);

        return humanizedEnum.ApplyCase(casing);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\GlobalUsings.cs ---


global using System.Collections.Frozen;
global using System.Globalization;
global using System.Reflection;
global using System.Text;
global using System.Text.RegularExpressions;
global using System.Diagnostics.CodeAnalysis;


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\GrammaticalCase.cs ---


namespace Humanizer;

/// <summary>
/// Options for specifying the desired grammatical case for the output words
/// </summary>
public enum GrammaticalCase
{
    /// <summary>
    /// Indicates the subject of a finite verb
    /// </summary>
    Nominative,
    /// <summary>
    /// Indicates the possessor of another noun
    /// </summary>
    Genitive,
    /// <summary>
    /// Indicates the indirect object of a verb
    /// </summary>
    Dative,
    /// <summary>
    /// Indicates the direct object of a verb
    /// </summary>
    Accusative,
    /// <summary>
    /// Indicates an object used in performing an action
    /// </summary>
    Instrumental,
    /// <summary>
    /// Indicates the object of a preposition
    /// </summary>
    Prepositional,
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\GrammaticalGender.cs ---


namespace Humanizer;

/// <summary>
/// Options for specifying the desired grammatical gender for the output words
/// </summary>
public enum GrammaticalGender
{
    /// <summary>
    /// Indicates masculine grammatical gender
    /// </summary>
    Masculine,
    /// <summary>
    /// Indicates feminine grammatical gender
    /// </summary>
    Feminine,
    /// <summary>
    /// Indicates neuter grammatical gender
    /// </summary>
    Neuter
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\HeadingExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Style for the cardinal direction humanization
/// </summary>
public enum HeadingStyle
{
    /// <summary>
    /// Returns an abbreviated format
    /// </summary>
    Abbreviated,

    /// <summary>
    /// Returns the full format
    /// </summary>
    Full
}

/// <summary>
/// Contains extensions to transform a number indicating a heading into the
/// textual representation of the heading.
/// </summary>
public static class HeadingExtensions
{
    internal static readonly string[] Headings = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];
    internal static readonly char[] HeadingArrows = ['', '', '', '', '', '', '', ''];

    // https://stackoverflow.com/a/7490772/1720761
    /// <summary>
    /// Returns a textual representation of the heading.
    ///
    /// This representation has a maximum deviation of 11.25 degrees.
    /// </summary>
    /// <returns>A textual representation of the heading</returns>
    /// <param name="heading">The heading value</param>
    /// <param name="style">Whether to return a short result or not. <see cref="HeadingStyle"/></param>
    /// <param name="culture">The culture to return the textual representation in</param>
    public static string ToHeading(this double heading, HeadingStyle style = HeadingStyle.Abbreviated, CultureInfo? culture = null)
    {
        var val = (int) (heading / 22.5 + .5);

        var result = Headings[val % 16];

        if (style == HeadingStyle.Abbreviated)
        {
            return Resources.GetResource($"{result}_Short", culture);
        }

        return Resources.GetResource(result, culture);
    }

    /// <summary>
    /// Returns a char arrow indicating the heading.
    ///
    /// This representation has a maximum deviation of 22.5 degrees.
    /// </summary>
    /// <returns>The heading arrow.</returns>
    public static char ToHeadingArrow(this double heading)
    {
        var val = (int) (heading / 45 + .5);

        return HeadingArrows[val % 8];
    }

    /// <summary>
    /// Returns a heading based on the short textual representation of the heading.
    /// </summary>
    /// <param name="heading">The short textual representation of a heading</param>
    /// <returns>The heading. -1 if the heading could not be parsed.</returns>
    public static double FromAbbreviatedHeading(this string heading) =>
        heading.FromAbbreviatedHeading(null);

    /// <summary>
    /// Returns a heading based on the short textual representation of the heading.
    /// </summary>
    /// <param name="heading">The short textual representation of a heading</param>
    /// <param name="culture">The culture of the heading</param>
    /// <returns>The heading. -1 if the heading could not be parsed.</returns>
    public static double FromAbbreviatedHeading(this string heading, CultureInfo? culture = null)
    {
        if (heading == null)
        {
            throw new ArgumentNullException(nameof(heading));
        }

        culture ??= CultureInfo.DefaultThreadCurrentCulture;

        var upperCaseHeading = culture.TextInfo.ToUpper(heading);
        for (var index = 0; index < Headings.Length; ++index)
        {
            var localizedShortHeading = Resources.GetResource($"{Headings[index]}_Short", culture);
            if (culture.CompareInfo.Compare(upperCaseHeading, localizedShortHeading) == 0)
            {
                return index * 22.5;
            }
        }

        return -1;
    }

    /// <summary>
    /// Returns a heading based on the heading arrow.
    /// </summary>
    public static double FromHeadingArrow(this char heading)
    {
        var index = Array.IndexOf(HeadingArrows, heading);

        if (index == -1)
        {
            return -1;
        }

        return index * 45.0;
    }

    /// <summary>
    /// Returns a heading based on the heading arrow.
    /// </summary>
    public static double FromHeadingArrow(this string heading)
    {
        if (heading == null)
        {
            throw new ArgumentNullException(nameof(heading));
        }

        if (heading.Length != 1)
        {
            return -1;
        }

        return heading[0]
            .FromHeadingArrow();
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\InflectorExtensions.cs ---


//The Inflector class was cloned from Inflector (https://github.com/srkirkland/Inflector)

//The MIT License (MIT)

//Copyright (c) 2013 Scott Kirkland

//Permission is hereby granted, free of charge, to any person obtaining a copy of
//this software and associated documentation files (the "Software"), to deal in
//the Software without restriction, including without limitation the rights to
//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
//the Software, and to permit persons to whom the Software is furnished to do so,
//subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
//FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
//COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
//IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

namespace Humanizer;

public static class InflectorExtensions
{
    /// <summary>
    /// Pluralizes the provided input considering irregular words
    /// </summary>
    /// <param name="word">Word to be pluralized</param>
    /// <param name="inputIsKnownToBeSingular">Normally you call Pluralize on singular words; but if you're unsure call it with false</param>
    [return: NotNullIfNotNull(nameof(word))]
    public static string? Pluralize(this string? word, bool inputIsKnownToBeSingular = true) =>
        Vocabularies.Default.Pluralize(word, inputIsKnownToBeSingular);

    /// <summary>
    /// Singularizes the provided input considering irregular words
    /// </summary>
    /// <param name="word">Word to be singularized</param>
    /// <param name="inputIsKnownToBePlural">Normally you call Singularize on plural words; but if you're unsure call it with false</param>
    /// <param name="skipSimpleWords">Skip singularizing single words that have an 's' on the end</param>
    public static string Singularize(this string word, bool inputIsKnownToBePlural = true, bool skipSimpleWords = false) =>
        Vocabularies.Default.Singularize(word, inputIsKnownToBePlural, skipSimpleWords);

    /// <summary>
    /// Humanizes the input with Title casing
    /// </summary>
    /// <param name="input">The string to be titleized</param>
    public static string Titleize(this string input) =>
        input.Humanize(LetterCasing.Title);

    /// <summary>
    /// By default, pascalize converts strings to UpperCamelCase also removing underscores
    /// </summary>
    public static string Pascalize(this string input) =>
        Regex.Replace(input, @"(?:[ _-]+|^)([a-zA-Z])", match => match
            .Groups[1]
            .Value.ToUpper());

    /// <summary>
    /// Same as Pascalize except that the first character is lower case
    /// </summary>
    public static string Camelize(this string input)
    {
        var word = input.Pascalize();
        return word.Length > 0
            ? word
                .Substring(0, 1)
                .ToLower() + word.Substring(1)
            : word;
    }

    /// <summary>
    /// Separates the input words with underscore
    /// </summary>
    /// <param name="input">The string to be underscored</param>
    public static string Underscore(this string input) =>
        Regex
            .Replace(
                Regex.Replace(
                    Regex.Replace(input, @"([\p{Lu}]+)([\p{Lu}][\p{Ll}])", "$1_$2"), @"([\p{Ll}\d])([\p{Lu}])", "$1_$2"), @"[-\s]", "_")
            .ToLower();

    /// <summary>
    /// Replaces underscores with dashes in the string
    /// </summary>
    public static string Dasherize(this string underscoredWord) =>
        underscoredWord.Replace('_', '-');

    /// <summary>
    /// Replaces underscores with hyphens in the string
    /// </summary>
    public static string Hyphenate(this string underscoredWord) =>
        Dasherize(underscoredWord);

    /// <summary>
    /// Separates the input words with hyphens and all the words are converted to lowercase
    /// </summary>
    public static string Kebaberize(this string input) =>
        Underscore(input)
            .Dasherize();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\InternalsVisibleTo.cs ---


using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("Humanizer.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100F9104F5F9BDB168AE140366EB1CD84C469B020EA3423D5D29996D5214CE2BD9B7C0BA3EAD1CA545C4399668AB8911E61CC1CC83C7DF6D50FD6B781365B467E65173F40A11C957D27C5AA0CB0F8DA9C91C988203CC8AEF1468C74A472839D0FD870DA8D13A4DC6B3AAFDAF0384D8E18E393C613D88BF02A64467A119902204FCC")]
[assembly: InternalsVisibleTo("Benchmarks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100F9104F5F9BDB168AE140366EB1CD84C469B020EA3423D5D29996D5214CE2BD9B7C0BA3EAD1CA545C4399668AB8911E61CC1CC83C7DF6D50FD6B781365B467E65173F40A11C957D27C5AA0CB0F8DA9C91C988203CC8AEF1468C74A472839D0FD870DA8D13A4DC6B3AAFDAF0384D8E18E393C613D88BF02A64467A119902204FCC")]


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\LetterCasing.cs ---


namespace Humanizer;

/// <summary>
/// Options for specifying the desired letter casing for the output string
/// </summary>
public enum LetterCasing
{
    /// <summary>
    /// SomeString -> Some String
    /// </summary>
    Title,
    /// <summary>
    /// SomeString -> SOME STRING
    /// </summary>
    AllCaps,
    /// <summary>
    /// SomeString -> some string
    /// </summary>
    LowerCase,
    /// <summary>
    /// SomeString -> Some string
    /// </summary>
    Sentence,
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\MetricNumeralExtensions.cs ---


// Wrote by Alois de Gouvello https://github.com/aloisdg

// The MIT License (MIT)

// Copyright (c) 2015 Alois de Gouvello

// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

/// <summary>
/// Contains extension methods for changing a number to Metric representation (ToMetric)
/// and from Metric representation back to the number (FromMetric)
/// </summary>
public static class MetricNumeralExtensions
{
    static readonly double BigLimit;
    static readonly double SmallLimit;

    static MetricNumeralExtensions()
    {
        const int limit = 27;
        BigLimit = Math.Pow(10, limit);
        SmallLimit = Math.Pow(10, -limit);
    }

    /// <summary>
    /// Symbols is a list of every symbols for the Metric system.
    /// </summary>
    static readonly List<char>[] Symbols =
    [
        ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'],
        ['m', '', 'n', 'p', 'f', 'a', 'z', 'y']
    ];

    /// <summary>
    /// UnitPrefixes link a Metric symbol (as key) to its prefix (as value).
    /// </summary>
    /// <remarks>
    /// We dont support :
    /// {'h', "hecto"},
    /// {'da', "deca" }, // !string
    /// {'d', "deci" },
    /// {'c', "centi"},
    /// </remarks>
    static readonly Dictionary<char, UnitPrefix> UnitPrefixes = new()
    {
        {
            'Y', new("yotta", "septillion", "quadrillion")
        },
        {
            'Z', new("zetta", "sextillion", "trilliard")
        },
        {
            'E', new("exa", "quintillion", "trillion")
        },
        {
            'P', new("peta", "quadrillion", "billiard")
        },
        {
            'T', new("tera", "trillion", "billion")
        },
        {
            'G', new("giga", "billion", "milliard")
        },
        {
            'M', new("mega", "million")
        },
        {
            'k', new("kilo", "thousand")
        },

        {
            'm', new("milli", "thousandth")
        },
        {
            '', new("micro", "millionth")
        },
        {
            'n', new("nano", "billionth", "milliardth")
        },
        {
            'p', new("pico", "trillionth", "billionth")
        },
        {
            'f', new("femto", "quadrillionth", "billiardth")
        },
        {
            'a', new("atto", "quintillionth", "trillionth")
        },
        {
            'z', new("zepto", "sextillionth", "trilliardth")
        },
        {
            'y', new("yocto", "septillionth", "quadrillionth")
        }
    };

    /// <summary>
    /// Converts a Metric representation into a number.
    /// </summary>
    /// <remarks>
    /// We don't support input in the format {number}{name} nor {number} {name}.
    /// We only provide a solution for {number}{symbol} and {number} {symbol}.
    /// </remarks>
    /// <param name="input">Metric representation to convert to a number</param>
    /// <example>
    /// <code>
    /// "1k".FromMetric() => 1000d
    /// "123".FromMetric() => 123d
    /// "100m".FromMetric() => 1E-1
    /// </code>
    /// </example>
    /// <returns>A number after a conversion from a Metric representation.</returns>
    public static double FromMetric(this string input)
    {
        input = CleanRepresentation(input);
        return BuildNumber(input, input[^1]);
    }

    /// <summary>
    /// Converts a number into a valid and Human-readable Metric representation.
    /// </summary>
    /// <remarks>
    /// Inspired by a snippet from Thom Smith.
    /// See <a href="http://stackoverflow.com/questions/12181024/formatting-a-number-with-a-metric-prefix">this link</a> for more.
    /// </remarks>
    /// <param name="input">Number to convert to a Metric representation.</param>
    /// <param name="formats">A bitwise combination of <see cref="MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
    /// <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
    /// <example>
    /// <code>
    /// 1000.ToMetric() => "1k"
    /// 123.ToMetric() => "123"
    /// 1E-1.ToMetric() => "100m"
    /// </code>
    /// </example>
    /// <returns>A valid Metric representation</returns>
    public static string ToMetric(this int input, MetricNumeralFormats? formats = null, int? decimals = null) =>
        ((double) input).ToMetric(formats, decimals);

    /// <summary>
    /// Converts a number into a valid and Human-readable Metric representation.
    /// </summary>
    /// <remarks>
    /// Inspired by a snippet from Thom Smith.
    /// See <a href="http://stackoverflow.com/questions/12181024/formatting-a-number-with-a-metric-prefix">this link</a> for more.
    /// </remarks>
    /// <param name="input">Number to convert to a Metric representation.</param>
    /// <param name="formats">A bitwise combination of <see cref="MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
    /// <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
    /// <example>
    /// <code>
    /// 1000d.ToMetric() => "1k"
    /// 123d.ToMetric() => "123"
    /// 1E-1.ToMetric() => "100m"
    /// </code>
    /// </example>
    /// <returns>A valid Metric representation</returns>
    public static string ToMetric(this double input, MetricNumeralFormats? formats = null, int? decimals = null)
    {
        if (input.Equals(0))
        {
            return input.ToString();
        }

        if (input.IsOutOfRange())
        {
            throw new ArgumentOutOfRangeException(nameof(input));
        }

        return BuildRepresentation(input, formats, decimals);
    }

    /// <summary>
    /// Clean or handle any wrong input
    /// </summary>
    /// <param name="input">Metric representation to clean</param>
    /// <returns>A cleaned representation</returns>
    static string CleanRepresentation(string input)
    {
        if (input == null)
        {
            throw new ArgumentNullException(nameof(input));
        }

        input = input.Trim();
        input = ReplaceNameBySymbol(input);
        if (input.Length == 0 || input.IsInvalidMetricNumeral())
        {
            throw new ArgumentException("Empty or invalid Metric string.", nameof(input));
        }

        return input.Replace(" ", string.Empty);
    }

    /// <summary>
    /// Build a number from a metric representation or from a number
    /// </summary>
    /// <param name="input">A Metric representation to parse to a number</param>
    /// <param name="last">The last character of input</param>
    /// <returns>A number build from a Metric representation</returns>
    static double BuildNumber(string input, char last) =>
        char.IsLetter(last)
            ? BuildMetricNumber(input, last)
            : double.Parse(input);

    /// <summary>
    /// Build a number from a metric representation
    /// </summary>
    /// <param name="input">A Metric representation to parse to a number</param>
    /// <param name="last">The last character of input</param>
    /// <returns>A number build from a Metric representation</returns>
    static double BuildMetricNumber(string input, char last)
    {
        double getExponent(List<char> symbols) => (symbols.IndexOf(last) + 1) * 3;
        var number = double.Parse(input.Remove(input.Length - 1));
        var exponent = Math.Pow(10, Symbols[0]
            .Contains(last)
            ? getExponent(Symbols[0])
            : -getExponent(Symbols[1]));
        return number * exponent;
    }

    /// <summary>
    /// Replace every symbol's name by its symbol representation.
    /// </summary>
    /// <param name="input">Metric representation with a name or a symbol</param>
    /// <returns>A metric representation with a symbol</returns>
    static string ReplaceNameBySymbol(string input) =>
        UnitPrefixes.Aggregate(input, (current, unitPrefix) =>
            current.Replace(unitPrefix.Value.Name, unitPrefix.Key.ToString()));

    /// <summary>
    /// Build a Metric representation of the number.
    /// </summary>
    /// <param name="input">Number to convert to a Metric representation.</param>
    /// <param name="formats">A bitwise combination of <see cref="MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
    /// <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
    /// <returns>A number in a Metric representation</returns>
    static string BuildRepresentation(double input, MetricNumeralFormats? formats, int? decimals)
    {
        var exponent = (int) Math.Floor(Math.Log10(Math.Abs(input)) / 3);

        if (!exponent.Equals(0)) return BuildMetricRepresentation(input, exponent, formats, decimals);
        var representation = decimals.HasValue
            ? Math
                .Round(input, decimals.Value)
                .ToString()
            : input.ToString();
        if ((formats & MetricNumeralFormats.WithSpace) == MetricNumeralFormats.WithSpace)
        {
            representation += " ";
        }

        return representation;
    }

    /// <summary>
    /// Build a Metric representation of the number.
    /// </summary>
    /// <param name="input">Number to convert to a Metric representation.</param>
    /// <param name="exponent">Exponent of the number in a scientific notation</param>
    /// <param name="formats">A bitwise combination of <see cref="MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
    /// <param name="decimals">If not null it is the numbers of decimals to round the number to</param>
    /// <returns>A number in a Metric representation</returns>
    static string BuildMetricRepresentation(double input, int exponent, MetricNumeralFormats? formats, int? decimals)
    {
        var number = input * Math.Pow(1000, -exponent);
        if (decimals.HasValue)
        {
            number = Math.Round(number, decimals.Value);
        }

        var symbol = Math.Sign(exponent) == 1
            ? Symbols[0][exponent - 1]
            : Symbols[1][-exponent - 1];
        return number.ToString("G15")
               + (formats.HasValue && formats.Value.HasFlag(MetricNumeralFormats.WithSpace) ? " " : string.Empty)
               + GetUnitText(symbol, formats);
    }

    /// <summary>
    /// Get the unit from a symbol of from the symbol's name.
    /// </summary>
    /// <param name="symbol">The symbol linked to the unit</param>
    /// <param name="formats">A bitwise combination of <see cref="MetricNumeralFormats"/> enumeration values that format the metric representation.</param>
    /// <returns>A symbol, a symbol's name, a symbol's short scale word or a symbol's long scale word</returns>
    static string GetUnitText(char symbol, MetricNumeralFormats? formats)
    {
        if (formats.HasValue
            && formats.Value.HasFlag(MetricNumeralFormats.UseName))
        {
            return UnitPrefixes[symbol].Name;
        }

        if (formats.HasValue
            && formats.Value.HasFlag(MetricNumeralFormats.UseShortScaleWord))
        {
            return UnitPrefixes[symbol].ShortScaleWord;
        }

        if (formats.HasValue
            && formats.Value.HasFlag(MetricNumeralFormats.UseLongScaleWord))
        {
            return UnitPrefixes[symbol].LongScaleWord;
        }

        return symbol.ToString();
    }

    /// <summary>
    /// Check if a Metric representation is out of the valid range.
    /// </summary>
    /// <param name="input">A Metric representation that may be out of the valid range.</param>
    /// <returns>True if input is out of the valid range.</returns>
    static bool IsOutOfRange(this double input)
    {
        bool outside(double min, double max) => !(max > input && input > min);

        return (Math.Sign(input) == 1 && outside(SmallLimit, BigLimit))
               || (Math.Sign(input) == -1 && outside(-BigLimit, -SmallLimit));
    }

    /// <summary>
    /// Check if a string is not a valid Metric representation.
    /// A valid representation is in the format "{0}{1}" or "{0} {1}"
    /// where {0} is a number and {1} is an allowed symbol.
    /// </summary>
    /// <remarks>
    /// ToDo: Performance: Use (string input, out number) to escape the double use of Parse()
    /// </remarks>
    /// <param name="input">>A string that may contain an invalid Metric representation.</param>
    /// <returns>True if input is not a valid Metric representation.</returns>
    static bool IsInvalidMetricNumeral(this string input)
    {
        var index = input.Length - 1;
        var last = input[index];
        var isSymbol = Symbols[0]
            .Contains(last) || Symbols[1]
            .Contains(last);
        return !double.TryParse(isSymbol ? input.Remove(index) : input, out _);
    }

    struct UnitPrefix(string name, string shortScaleWord, string? longScaleWord = null)
    {
        public string Name { get; } = name;
        public string ShortScaleWord { get; } = shortScaleWord;
        public string LongScaleWord => longScaleWord ?? ShortScaleWord;
    }
}



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\MetricNumeralFormats.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Flags for formatting the metric representation of numerals.
/// </summary>
[Flags]
public enum MetricNumeralFormats
{
    /// <summary>
    /// Use the metric prefix <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">long scale word</a>.
    /// </summary>
    UseLongScaleWord = 1,

    /// <summary>
    /// Use the metric prefix <a href="https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes">name</a> instead of the symbol.
    /// </summary>
    UseName = 2,

    /// <summary>
    /// Use the metric prefix <a href="https://en.wikipedia.org/wiki/Long_and_short_scales">short scale word</a>.
    /// </summary>
    UseShortScaleWord = 4,

    /// <summary>
    /// Include a space after the numeral.
    /// </summary>
    WithSpace = 8
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\NoMatchFoundException.cs ---


using System;

namespace Humanizer;

/// <summary>
/// This is thrown on String.DehumanizeTo enum when the provided string cannot be mapped to the target enum
/// </summary>
#pragma warning disable 1591
public class NoMatchFoundException : Exception
{
    public NoMatchFoundException()
    {
    }

    public NoMatchFoundException(string message)
        : base(message)
    {
    }

    public NoMatchFoundException(string message, Exception inner)
        : base(message, inner)
    {
    }
}
#pragma warning restore 1591


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\NumberToNumberExtensions.cs ---


using System.Runtime.CompilerServices;

namespace Humanizer;

/// <summary>
/// Number to Number extensions
/// </summary>
public static class NumberToNumberExtensions
{
    /// <summary>
    /// 5.Tens == 50
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Tens(this int input) =>
        input * 10;

    /// <summary>
    /// 5.Tens == 50
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Tens(this uint input) =>
        input * 10;

    /// <summary>
    /// 5.Tens == 50
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long Tens(this long input) =>
        input * 10;

    /// <summary>
    /// 5.Tens == 50
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong Tens(this ulong input) =>
        input * 10;

    /// <summary>
    /// 5.Tens == 50
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double Tens(this double input) =>
        input * 10;

    /// <summary>
    /// 4.Hundreds() == 400
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Hundreds(this int input) =>
        input * 100;

    /// <summary>
    /// 4.Hundreds() == 400
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Hundreds(this uint input) =>
        input * 100;

    /// <summary>
    /// 4.Hundreds() == 400
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long Hundreds(this long input) =>
        input * 100;

    /// <summary>
    /// 4.Hundreds() == 400
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong Hundreds(this ulong input) =>
        input * 100;

    /// <summary>
    /// 4.Hundreds() == 400
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double Hundreds(this double input) =>
        input * 100;

    /// <summary>
    /// 3.Thousands() == 3000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Thousands(this int input) =>
        input * 1000;

    /// <summary>
    /// 3.Thousands() == 3000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Thousands(this uint input) =>
        input * 1000;

    /// <summary>
    /// 3.Thousands() == 3000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long Thousands(this long input) =>
        input * 1000;

    /// <summary>
    /// 3.Thousands() == 3000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong Thousands(this ulong input) =>
        input * 1000;

    /// <summary>
    /// 3.Thousands() == 3000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double Thousands(this double input) =>
        input * 1000;

    /// <summary>
    /// 2.Millions() == 2000000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Millions(this int input) =>
        input * 1000000;

    /// <summary>
    /// 2.Millions() == 2000000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Millions(this uint input) =>
        input * 1000000;

    /// <summary>
    /// 2.Millions() == 2000000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long Millions(this long input) =>
        input * 1000000;

    /// <summary>
    /// 2.Millions() == 2000000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong Millions(this ulong input) =>
        input * 1000000;

    /// <summary>
    /// 2.Millions() == 2000000
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double Millions(this double input) =>
        input * 1000000;

    /// <summary>
    /// 1.Billions() == 1000000000 (short scale)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Billions(this int input) =>
        input * 1000000000;

    /// <summary>
    /// 1.Billions() == 1000000000 (short scale)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static uint Billions(this uint input) =>
        input * 1000000000;

    /// <summary>
    /// 1.Billions() == 1000000000 (short scale)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static long Billions(this long input) =>
        input * 1000000000;

    /// <summary>
    /// 1.Billions() == 1000000000 (short scale)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong Billions(this ulong input) =>
        input * 1000000000;

    /// <summary>
    /// 1.Billions() == 1000000000 (short scale)
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double Billions(this double input) =>
        input * 1000000000;
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\NumberToTimeSpanExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Number to TimeSpan extensions
/// </summary>
public static class NumberToTimeSpanExtensions
{
    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this byte ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this sbyte ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this short ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this ushort ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this int ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this uint ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this long ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this ulong ms) =>
        Milliseconds((double)ms);

    /// <summary>
    /// 5.Milliseconds() == TimeSpan.FromMilliseconds(5)
    /// </summary>
    public static TimeSpan Milliseconds(this double ms) =>
        TimeSpan.FromMilliseconds(ms);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this byte seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this sbyte seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this short seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this ushort seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this int seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this uint seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this long seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this ulong seconds) =>
        Seconds((double)seconds);

    /// <summary>
    /// 5.Seconds() == TimeSpan.FromSeconds(5)
    /// </summary>
    public static TimeSpan Seconds(this double seconds) =>
        TimeSpan.FromSeconds(seconds);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this byte minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this sbyte minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this short minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this ushort minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this int minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this uint minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this long minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this ulong minutes) =>
        Minutes((double)minutes);

    /// <summary>
    /// 4.Minutes() == TimeSpan.FromMinutes(4)
    /// </summary>
    public static TimeSpan Minutes(this double minutes) =>
        TimeSpan.FromMinutes(minutes);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this byte hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this sbyte hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this short hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this ushort hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this int hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this uint hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this long hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this ulong hours) =>
        Hours((double)hours);

    /// <summary>
    /// 3.Hours() == TimeSpan.FromHours(3)
    /// </summary>
    public static TimeSpan Hours(this double hours) =>
        TimeSpan.FromHours(hours);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this byte days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this sbyte days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this short days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this ushort days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this int days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this uint days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this long days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this ulong days) =>
        Days((double)days);

    /// <summary>
    /// 2.Days() == TimeSpan.FromDays(2)
    /// </summary>
    public static TimeSpan Days(this double days) =>
        TimeSpan.FromDays(days);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this byte input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this sbyte input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this short input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this ushort input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this int input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this uint input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this long input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this ulong input) =>
        Weeks((double)input);

    /// <summary>
    /// 2.Weeks() == new TimeSpan(14, 0, 0, 0)
    /// </summary>
    public static TimeSpan Weeks(this double input) =>
        Days(7 * input);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\NumberToWordsExtension.cs ---


namespace Humanizer;

/// <summary>
/// Transform a number into words; e.g. 1 => one
/// </summary>
public static class NumberToWordsExtension
{
    /// <summary>
    /// 1.ToOrdinalWords() -> "first"
    /// </summary>
    /// <param name="number">Number to be turned to ordinal words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToOrdinalWords(this int number, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).ConvertToOrdinal(number);

    /// <summary>
    /// Converts a number to ordinal words supporting locale's specific variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 1.ToOrdinalWords(WordForm.Normal) -> "primero" // As in "He llegado el primero".
    /// 3.ToOrdinalWords(WordForm.Abbreviation) -> "tercer" // As in "Vivo en el tercer piso"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to ordinal words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted into ordinal words</returns>
    public static string ToOrdinalWords(this int number, WordForm wordForm, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).ConvertToOrdinal(number, wordForm);

    /// <summary>
    /// for Brazilian Portuguese locale
    /// 1.ToOrdinalWords(GrammaticalGender.Masculine) -> "primeiro"
    /// 1.ToOrdinalWords(GrammaticalGender.Feminine) -> "primeira"
    /// </summary>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToOrdinalWords(this int number, GrammaticalGender gender, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).ConvertToOrdinal(number, gender);

    /// <summary>
    /// Converts a number to ordinal words supporting locale's specific variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 3.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Normal) -> "tercero"
    /// 3.ToOrdinalWords(GrammaticalGender.Masculine, WordForm.Abbreviation) -> "tercer"
    /// 3.ToOrdinalWords(GrammaticalGender.Feminine, WordForm.Normal) -> "tercera"
    /// 3.ToOrdinalWords(GrammaticalGender.Feminine, WordForm.Abbreviation) -> "tercera"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to ordinal words</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted into ordinal words</returns>
    public static string ToOrdinalWords(this int number, GrammaticalGender gender, WordForm wordForm, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).ConvertToOrdinal(number, gender, wordForm);

    /// <summary>
    /// 1.ToTuple() -> "single"
    /// </summary>
    /// <param name="number">Number to be turned to tuple</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToTuple(this int number, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).ConvertToTuple(number);

    /// <summary>
    /// 3501.ToWords() -> "three thousand five hundred and one"
    /// </summary>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToWords(this int number, CultureInfo? culture = null) =>
        ((long)number).ToWords(culture);

    /// <summary>
    /// Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
    /// </summary>
    /// <example>
    /// In Spanish, numbers ended in 1 change its form depending on their position in the sentence.
    /// <code>
    /// 21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
    /// 21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted to words</returns>
    public static string ToWords(this int number, WordForm wordForm, CultureInfo? culture = null) =>
        ((long)number).ToWords(wordForm, culture);

    /// <summary>
    /// 3501.ToWords(false) -> "three thousand five hundred one"
    /// </summary>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="addAnd">To add 'and' before the last number.</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToWords(this int number, bool addAnd, CultureInfo? culture = null) =>
        ((long)number).ToWords(culture, addAnd);

    /// <summary>
    /// Converts a number to words supporting specific word variations of some locales.
    /// </summary>
    /// <example>
    /// In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
    /// <code>
    /// 21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
    /// 21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="addAnd">To add 'and' before the last number</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted to words</returns>
    public static string ToWords(this int number, bool addAnd, WordForm wordForm, CultureInfo? culture = null) =>
        ((long)number).ToWords(wordForm, culture, addAnd);

    /// <summary>
    /// For locales that support gender-specific forms
    /// </summary>
    /// <example>
    /// Russian:
    /// <code>
    ///   1.ToWords(GrammaticalGender.Masculine) -> ""
    ///   1.ToWords(GrammaticalGender.Feminine) -> ""
    /// </code>
    /// Hebrew:
    /// <code>
    ///   1.ToWords(GrammaticalGender.Masculine) -> ""
    ///   1.ToWords(GrammaticalGender.Feminine) -> ""
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToWords(this int number, GrammaticalGender gender, CultureInfo? culture = null) =>
        ((long)number).ToWords(gender, culture);

    /// <summary>
    /// Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
    /// </summary>
    /// <example>
    /// In Spanish, numbers ended in 1 change its form depending on their position in the sentence.
    /// <code>
    /// 21.ToWords(WordForm.Normal, GrammaticalGender.Masculine) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
    /// 21.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) -> veintin // as in "En total, cont veintin coches"
    /// 21.ToWords(WordForm.Normal, GrammaticalGender.Feminine) -> veintiuna // as in "veintiuna personas"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted to words</returns>
    public static string ToWords(this int number, WordForm wordForm, GrammaticalGender gender, CultureInfo? culture = null) =>
        ((long)number).ToWords(wordForm, gender, culture);

    /// <summary>
    /// 3501.ToWords() -> "three thousand five hundred and one"
    /// </summary>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="addAnd">Whether "and" should be included or not.</param>
    public static string ToWords(this long number, CultureInfo? culture = null, bool addAnd = true) =>
        Configurator.GetNumberToWordsConverter(culture).Convert(number, addAnd);

    /// <summary>
    /// Converts a number to words supporting specific word variations of some locales.
    /// </summary>
    /// <example>
    /// In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
    /// <code>
    /// 21.ToWords(WordForm.Normal) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
    /// 21.ToWords(WordForm.Abbreviation) -> veintin // as in "En total, cont veintin coches"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="addAnd">To add 'and' before the last number</param>
    /// <returns>The number converted to words</returns>
    public static string ToWords(this long number, WordForm wordForm, CultureInfo? culture = null, bool addAnd = false) =>
        Configurator.GetNumberToWordsConverter(culture).Convert(number, addAnd, wordForm);

    /// <summary>
    /// For locales that support gender-specific forms
    /// </summary>
    /// <example>
    /// Russian:
    /// <code>
    ///   1.ToWords(GrammaticalGender.Masculine) -> ""
    ///   1.ToWords(GrammaticalGender.Feminine) -> ""
    /// </code>
    /// Hebrew:
    /// <code>
    ///   1.ToWords(GrammaticalGender.Masculine) -> ""
    ///   1.ToWords(GrammaticalGender.Feminine) -> ""
    /// </code>
    /// </example>
    ///
    /// <param name="number">Number to be turned to words</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToWords(this long number, GrammaticalGender gender, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).Convert(number, gender);

    /// <summary>
    /// Converts a number to words supporting specific word variations, including grammatical gender, of some locales.
    /// </summary>
    /// <example>
    /// In Spanish, numbers ended in 1 changes its form depending on their position in the sentence.
    /// <code>
    /// 21.ToWords(WordForm.Normal, GrammaticalGender.Masculine) -> veintiuno // as in "Mi nmero favorito es el veintiuno".
    /// 21.ToWords(WordForm.Abbreviation, GrammaticalGender.Masculine) -> veintin // as in "En total, cont veintin coches"
    /// 21.ToWords(WordForm.Normal, GrammaticalGender.Feminine) -> veintiuna // as in "veintiuna personas"
    /// </code>
    /// </example>
    /// <param name="number">Number to be turned to words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <returns>The number converted to words</returns>
    public static string ToWords(this long number, WordForm wordForm, GrammaticalGender gender, CultureInfo? culture = null) =>
        Configurator.GetNumberToWordsConverter(culture).Convert(number, wordForm, gender);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\OnNoMatch.cs ---


namespace Humanizer;

/// <summary>
/// Dictating what should be done when a match is not found - currently used only for DehumanizeTo
/// </summary>
public enum OnNoMatch
{
    /// <summary>
    /// This is the default behavior which throws a NoMatchFoundException
    /// </summary>
    ThrowsException,

    /// <summary>
    /// If set to ReturnsNull the method returns null instead of throwing an exception
    /// </summary>
    ReturnsNull
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\OrdinalizeExtensions.cs ---


namespace Humanizer;

/// <summary>
/// Ordinalize extensions
/// </summary>
public static class OrdinalizeExtensions
{
    /// <summary>
    /// Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// </summary>
    /// <param name="numberString">The number, in string, to be ordinalized</param>
    public static string Ordinalize(this string numberString) =>
        Configurator.Ordinalizer.Convert(int.Parse(numberString), numberString);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// "1".Ordinalize(WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// "1".Ordinalize(WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="numberString">The number, in string, to be ordinalized</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this string numberString, WordForm wordForm) =>
        Configurator.Ordinalizer.Convert(int.Parse(numberString), numberString, wordForm);

    /// <summary>
    /// Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// </summary>
    /// <param name="numberString">The number, in string, to be ordinalized</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string Ordinalize(this string numberString, CultureInfo culture) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(int.Parse(numberString, culture), numberString);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// "1".Ordinalize(new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// "1".Ordinalize(new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="numberString">The number to be ordinalized</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this string numberString, CultureInfo culture, WordForm wordForm) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(int.Parse(numberString, culture), numberString, wordForm);

    /// <summary>
    /// Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// Gender for Brazilian Portuguese locale
    /// "1".Ordinalize(GrammaticalGender.Masculine) -> "1"
    /// "1".Ordinalize(GrammaticalGender.Feminine) -> "1"
    /// </summary>
    /// <param name="numberString">The number, in string, to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    public static string Ordinalize(this string numberString, GrammaticalGender gender) =>
        Configurator.Ordinalizer.Convert(int.Parse(numberString), numberString, gender);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
    /// locale's variations using the grammatical gender provided
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// "1".Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// "1".Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// "1".Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) -> 1. // As in "Es 1 vez que hago esto"
    /// </code>
    /// </example>
    /// <param name="numberString">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this string numberString, GrammaticalGender gender, WordForm wordForm) =>
        Configurator.Ordinalizer.Convert(int.Parse(numberString), numberString, gender, wordForm);

    /// <summary>
    /// Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// Gender for Brazilian Portuguese locale
    /// "1".Ordinalize(GrammaticalGender.Masculine) -> "1"
    /// "1".Ordinalize(GrammaticalGender.Feminine) -> "1"
    /// </summary>
    /// <param name="numberString">The number, in string, to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string Ordinalize(this string numberString, GrammaticalGender gender, CultureInfo culture) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(int.Parse(numberString, culture), numberString, gender);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
    /// locale's variations using the grammatical gender provided
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// "1".Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// "1".Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// "1".Ordinalize(GrammaticalGender.Feminine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="numberString">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this string numberString, GrammaticalGender gender, CultureInfo culture, WordForm wordForm) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(int.Parse(numberString, culture), numberString, gender, wordForm);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// </summary>
    /// <param name="number">The number to be ordinalized</param>
    public static string Ordinalize(this int number) =>
        Configurator.Ordinalizer.Convert(number, number.ToString(CultureInfo.InvariantCulture));

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 1.Ordinalize(WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// 1.Ordinalize(WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this int number, WordForm wordForm) =>
        Configurator.Ordinalizer.Convert(number, number.ToString(CultureInfo.InvariantCulture), wordForm);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// </summary>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string Ordinalize(this int number, CultureInfo culture) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(number, number.ToString(culture));

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific locale's variations.
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 1.Ordinalize(new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// 1.Ordinalize(new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this int number, CultureInfo culture, WordForm wordForm) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(number, number.ToString(culture), wordForm);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// Gender for Brazilian Portuguese locale
    /// 1.Ordinalize(GrammaticalGender.Masculine) -> "1"
    /// 1.Ordinalize(GrammaticalGender.Feminine) -> "1"
    /// </summary>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    public static string Ordinalize(this int number, GrammaticalGender gender) =>
        Configurator.Ordinalizer.Convert(number, number.ToString(CultureInfo.InvariantCulture), gender);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
    /// locale's variations using the grammatical gender provided
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 1.Ordinalize(GrammaticalGender.Masculine, WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// 1.Ordinalize(GrammaticalGender.Masculine, WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// 1.Ordinalize(GrammaticalGender.Feminine, WordForm.Normal) -> 1. // As in "Es 1 vez que hago esto"
    /// </code>
    /// </example>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this int number, GrammaticalGender gender, WordForm wordForm) =>
        Configurator.Ordinalizer.Convert(number, number.ToString(CultureInfo.InvariantCulture), gender, wordForm);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.
    /// Gender for Brazilian Portuguese locale
    /// 1.Ordinalize(GrammaticalGender.Masculine) -> "1"
    /// 1.Ordinalize(GrammaticalGender.Feminine) -> "1"
    /// </summary>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string Ordinalize(this int number, GrammaticalGender gender, CultureInfo culture) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(number, number.ToString(culture), gender);

    /// <summary>
    /// Turns a number into an ordinal number used to denote the position in an ordered sequence supporting specific
    /// locale's variations using the grammatical gender provided
    /// </summary>
    /// <example>
    /// In Spanish:
    /// <code>
    /// 1.Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"),WordForm.Abbreviation) -> 1.er // As in "Vivo en el 1.er piso"
    /// 1.Ordinalize(GrammaticalGender.Masculine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// 1.Ordinalize(GrammaticalGender.Feminine, new CultureInfo("es-ES"), WordForm.Normal) -> 1. // As in "Fui el 1 de mi promocin"
    /// </code>
    /// </example>
    /// <param name="number">The number to be ordinalized</param>
    /// <param name="gender">The grammatical gender to use for output words</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="wordForm">Form of the word, i.e. abbreviation</param>
    /// <returns>The number ordinalized</returns>
    public static string Ordinalize(this int number, GrammaticalGender gender, CultureInfo culture, WordForm wordForm) =>
        Configurator.Ordinalizers.ResolveForCulture(culture).Convert(number, number.ToString(culture), gender, wordForm);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\Plurality.cs ---


namespace Humanizer;

/// <summary>
/// Provides hint for Humanizer as to whether a word is singular, plural or with unknown plurality
/// </summary>
public enum Plurality
{
    /// <summary>
    /// The word is singular
    /// </summary>
    Singular,
    /// <summary>
    /// The word is plural
    /// </summary>
    Plural,
    /// <summary>
    /// I am unsure of the plurality
    /// </summary>
    CouldBeEither
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\RomanNumeralExtensions.cs ---


// Done by Jesse Slicer https://github.com/jslicer

using System;
using System.Collections.Generic;

namespace Humanizer;

/// <summary>
/// Contains extension methods for changing a number to Roman representation (ToRoman) and from Roman representation back to the number (FromRoman)
/// </summary>
public static class RomanNumeralExtensions
{
    static readonly Dictionary<string, int> RomanNumerals =
        new(StringComparer.OrdinalIgnoreCase)
        {
            {
                "M", 1000
            },
            {
                "CM", 900
            },
            {
                "D", 500
            },
            {
                "CD", 400
            },
            {
                "C", 100
            },
            {
                "XC", 90
            },
            {
                "L", 50
            },
            {
                "XL", 40
            },
            {
                "X", 10
            },
            {
                "IX", 9
            },
            {
                "V", 5
            },
            {
                "IV", 4
            },
            {
                "I", 1
            }
        };

    static readonly Regex ValidRomanNumeral =
        new(
            "^(?i:(?=[MDCLXVI])((M{0,3})((C[DM])|(D?C{0,3}))?((X[LC])|(L?XX{0,2})|L)?((I[VX])|(V?(II{0,2}))|V)?))$",
            RegexOptions.Compiled | RegexOptions.IgnoreCase);

    /// <summary>
    /// Converts Roman numbers into integer
    /// </summary>
    /// <param name="input">Roman number</param>
    /// <returns>Human-readable number</returns>
    public static int FromRoman(this string input)
    {
        if (input == null)
        {
            throw new ArgumentNullException(nameof(input));
        }

        return FromRoman(input.AsSpan());
    }

    /// <summary>
    /// Converts Roman numbers into integer
    /// </summary>
    /// <param name="input">Roman number</param>
    /// <returns>Human-readable number</returns>
    public static int FromRoman(ReadOnlySpan<System.Char> input)
    {
        input = input.Trim();

        var length = input.Length;

        if (length == 0 || IsInvalidRomanNumeral(input))
        {
            throw new ArgumentException("Empty or invalid Roman numeral string.", nameof(input));
        }

        var total = 0;
        var i = length;

        while (i > 0)
        {
            var digit = RomanNumerals[input[--i]
                .ToString()];

            if (i > 0)
            {
                var previousDigit = RomanNumerals[input[i - 1]
                    .ToString()];

                if (previousDigit < digit)
                {
                    digit -= previousDigit;
                    i--;
                }
            }

            total += digit;
        }

        return total;
    }

    /// <summary>
    /// Converts the input to Roman number
    /// </summary>
    /// <param name="input">Integer input</param>
    /// <returns>Roman number</returns>
    /// <exception cref="ArgumentOutOfRangeException">Thrown when the input is smaller than 1 or larger than 3999</exception>
    public static string ToRoman(this int input)
    {
        const int minValue = 1;
        const int maxValue = 3999;
        const int maxRomanNumeralLength = 15;

        if (input is < minValue or > maxValue)
        {
            throw new ArgumentOutOfRangeException();
        }

        var builder = new StringBuilder(maxRomanNumeralLength);

        foreach (var pair in RomanNumerals)
        {
            while (input / pair.Value > 0)
            {
                builder.Append(pair.Key);
                input -= pair.Value;
            }
        }

        return builder.ToString();
    }

    static bool IsInvalidRomanNumeral(ReadOnlySpan<System.Char> input) =>
        !ValidRomanNumeral.IsMatch(input);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\StringDehumanizeExtensions.cs ---


using System.Linq;

namespace Humanizer;

/// <summary>
/// Contains extension methods for dehumanizing strings.
/// </summary>
public static class StringDehumanizeExtensions
{
    /// <summary>
    /// Dehumanizes a string; e.g. 'some string', 'Some String', 'Some string' -> 'SomeString'
    /// If a string is already dehumanized then it leaves it alone 'SomeStringAndAnotherString' -> 'SomeStringAndAnotherString'
    /// </summary>
    /// <param name="input">The string to be dehumanized</param>
    public static string Dehumanize(this string input)
    {
        var pascalizedWords = input
            .Split(' ')
            .Select(word => word
                .Humanize()
                .Pascalize());
        return string
            .Concat(pascalizedWords)
            .Replace(" ", "");
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\StringHumanizeExtensions.cs ---


using System.Linq;

namespace Humanizer;

/// <summary>
/// Contains extension methods for humanizing string values.
/// </summary>
public static class StringHumanizeExtensions
{
    static readonly Regex PascalCaseWordPartsRegex;
    static readonly Regex FreestandingSpacingCharRegex;

    const string OptionallyCapitalizedWord = @"\p{Lu}?\p{Ll}+";
    const string IntegerAndOptionalLowercaseLetters = @"[0-9]+\p{Ll}*";
    const string Acronym = @"\p{Lu}+(?=\p{Lu}|[0-9]|\b)";
    const string SequenceOfOtherLetters = @"\p{Lo}+";
    const string MidSentencePunctuation = "[,;]?";

    static StringHumanizeExtensions()
    {
        PascalCaseWordPartsRegex = new(
            $"({OptionallyCapitalizedWord}|{IntegerAndOptionalLowercaseLetters}|{Acronym}|{SequenceOfOtherLetters}){MidSentencePunctuation}",
            RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
        FreestandingSpacingCharRegex = new(@"\s[-_]|[-_]\s", RegexOptions.Compiled);
    }

    static string FromUnderscoreDashSeparatedWords(string input) =>
        string.Join(" ", input.Split(['_', '-']));

    static string FromPascalCase(string input)
    {
        var result = string.Join(" ", PascalCaseWordPartsRegex
            .Matches(input)
            // ReSharper disable once RedundantEnumerableCastCall
            .Cast<Match>()
            .Select(match =>
            {
                var value = match.Value;
                return value.All(char.IsUpper) &&
                       (value.Length > 1 || (match.Index > 0 && input[match.Index - 1] == ' ') || value == "I")
                    ? value
                    : value.ToLower();
            }));

        if (result
                .Replace(" ", "")
                .All(char.IsUpper) &&
            result.Contains(" "))
        {
            result = result.ToLower();
        }

        return result.Length > 0
            ? char.ToUpper(result[0]) +
              result.Substring(1, result.Length - 1)
            : result;
    }

    /// <summary>
    /// Humanizes the input string; e.g. Underscored_input_String_is_turned_INTO_sentence -> 'Underscored input String is turned INTO sentence'
    /// </summary>
    /// <param name="input">The string to be humanized</param>
    public static string Humanize(this string input)
    {
        // if input is all capitals (e.g. an acronym) then return it without change
        if (input.All(char.IsUpper))
        {
            return input;
        }

        // if input contains a dash or underscore which precedes or follows a space (or both, e.g. free-standing)
        // remove the dash/underscore and run it through FromPascalCase
        if (FreestandingSpacingCharRegex.IsMatch(input))
        {
            return FromPascalCase(FromUnderscoreDashSeparatedWords(input));
        }

        if (input.Contains("_") || input.Contains("-"))
        {
            return FromUnderscoreDashSeparatedWords(input);
        }

        return FromPascalCase(input);
    }

    /// <summary>
    /// Humanized the input string based on the provided casing
    /// </summary>
    /// <param name="input">The string to be humanized</param>
    /// <param name="casing">The desired casing for the output</param>
    public static string Humanize(this string input, LetterCasing casing) =>
        input
            .Humanize()
            .ApplyCase(casing);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TimeOnlyToClockNotationExtensions.cs ---


#if NET6_0_OR_GREATER

namespace Humanizer;

/// <summary>
/// Humanizes TimeOnly into human readable sentence
/// </summary>
public static class TimeOnlyToClockNotationExtensions
{
    /// <summary>
    /// Turns the provided time into clock notation
    /// </summary>
    /// <param name="input">The time to be made into clock notation</param>
    /// <param name="roundToNearestFive">Whether to round the minutes to the nearest five or not</param>
    /// <returns>The time in clock notation</returns>
    public static string ToClockNotation(this TimeOnly input, ClockNotationRounding roundToNearestFive = ClockNotationRounding.None) =>
        Configurator.TimeOnlyToClockNotationConverter.Convert(input, roundToNearestFive);
}

#endif



// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TimeSpanHumanizeExtensions.cs ---


using System;
using System.Collections.Generic;
using System.Linq;

namespace Humanizer;

/// <summary>
/// Humanizes TimeSpan into human readable form
/// </summary>
public static class TimeSpanHumanizeExtensions
{
    const int _daysInAWeek = 7;
    const double _daysInAYear = 365.2425; // see https://en.wikipedia.org/wiki/Gregorian_calendar
    const double _daysInAMonth = _daysInAYear / 12;

    static TimeUnit[] _timeUnits = Enum
        .GetValues(typeof(TimeUnit))
        .Cast<TimeUnit>()
        .Reverse()
        .ToArray();

    /// <summary>
    /// Turns a TimeSpan into a human readable form. E.g. 1 day.
    /// </summary>
    /// <param name="precision">The maximum number of time units to return. Defaulted is 1 which means the largest unit is returned</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="TimeUnit.Week"/>. The time units <see cref="TimeUnit.Month"/> and <see cref="TimeUnit.Year"/> will give approximations for time spans bigger 30 days by calculating with 365.2425 days a year and 30.4369 days a month.</param>
    /// <param name="minUnit">The minimum unit of time to output.</param>
    /// <param name="collectionSeparator">The separator to use when combining humanized time parts. If null, the default collection formatter for the current culture is used.</param>
    /// <param name="toWords">Uses words instead of numbers if true. E.g. one day.</param>
    public static string Humanize(this TimeSpan timeSpan, int precision = 1, CultureInfo? culture = null, TimeUnit maxUnit = TimeUnit.Week, TimeUnit minUnit = TimeUnit.Millisecond, string? collectionSeparator = ", ", bool toWords = false) =>
        Humanize(timeSpan, precision, false, culture, maxUnit, minUnit, collectionSeparator, toWords);

    /// <summary>
    /// Turns a TimeSpan into a human readable form. E.g. 1 day.
    /// </summary>
    /// <param name="precision">The maximum number of time units to return.</param>
    /// <param name="countEmptyUnits">Controls whether empty time units should be counted towards maximum number of time units. Leading empty time units never count.</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="TimeUnit.Week"/>. The time units <see cref="TimeUnit.Month"/> and <see cref="TimeUnit.Year"/> will give approximations for time spans bigger than 30 days by calculating with 365.2425 days a year and 30.4369 days a month.</param>
    /// <param name="minUnit">The minimum unit of time to output.</param>
    /// <param name="collectionSeparator">The separator to use when combining humanized time parts. If null, the default collection formatter for the current culture is used.</param>
    /// <param name="toWords">Uses words instead of numbers if true. E.g. one day.</param>
    public static string Humanize(this TimeSpan timeSpan, int precision, bool countEmptyUnits, CultureInfo? culture = null, TimeUnit maxUnit = TimeUnit.Week, TimeUnit minUnit = TimeUnit.Millisecond, string? collectionSeparator = ", ", bool toWords = false)
    {
        var timeParts = CreateTheTimePartsWithUpperAndLowerLimits(timeSpan, culture, maxUnit, minUnit, toWords);
        timeParts = SetPrecisionOfTimeSpan(timeParts, precision, countEmptyUnits);

        return ConcatenateTimeSpanParts(timeParts, culture, collectionSeparator);
    }

    /// <summary>
    /// Turns a TimeSpan into an age expression, e.g. "40 years old"
    /// </summary>
    /// <param name="timeSpan">Elapsed time</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    /// <param name="maxUnit">The maximum unit of time to output. The default value is <see cref="TimeUnit.Year"/>.</param>
    /// <param name="toWords">Uses words instead of numbers if true. E.g. "forty years old".</param>
    /// <returns>Age expression in the given culture/language</returns>
    public static string ToAge(this TimeSpan timeSpan, CultureInfo? culture = null, TimeUnit maxUnit = TimeUnit.Year, bool toWords = false)
    {
        var timeSpanExpression = timeSpan.Humanize(culture: culture, maxUnit: maxUnit, toWords: toWords);

        var cultureFormatter = Configurator.GetFormatter(culture);
        return string.Format(cultureFormatter.TimeSpanHumanize_Age(), timeSpanExpression);
    }

    static IEnumerable<string> CreateTheTimePartsWithUpperAndLowerLimits(TimeSpan timespan, CultureInfo? culture, TimeUnit maxUnit, TimeUnit minUnit, bool toWords = false)
    {
        var cultureFormatter = Configurator.GetFormatter(culture);
        var firstValueFound = false;
        var timeParts = new List<string?>();

        foreach (var timeUnit in _timeUnits)
        {
            var timePart = GetTimeUnitPart(timeUnit, timespan, maxUnit, minUnit, cultureFormatter, toWords);

            if (timePart != null || firstValueFound)
            {
                firstValueFound = true;
                timeParts.Add(timePart);
            }
        }

        if (IsContainingOnlyNullValue(timeParts))
        {
            var noTimeValueCultureFormatted = toWords
                ? cultureFormatter.TimeSpanHumanize_Zero()
                : cultureFormatter.TimeSpanHumanize(minUnit, 0);
            timeParts = CreateTimePartsWithNoTimeValue(noTimeValueCultureFormatted);
        }

        return timeParts;
    }

    static string? GetTimeUnitPart(TimeUnit timeUnitToGet, TimeSpan timespan, TimeUnit maximumTimeUnit, TimeUnit minimumTimeUnit, IFormatter cultureFormatter, bool toWords = false)
    {
        if (timeUnitToGet <= maximumTimeUnit && timeUnitToGet >= minimumTimeUnit)
        {
            var numberOfTimeUnits = GetTimeUnitNumericalValue(timeUnitToGet, timespan, maximumTimeUnit);
            return BuildFormatTimePart(cultureFormatter, timeUnitToGet, numberOfTimeUnits, toWords);
        }

        return null;
    }

    static int GetTimeUnitNumericalValue(TimeUnit timeUnitToGet, TimeSpan timespan, TimeUnit maximumTimeUnit)
    {
        var isTimeUnitToGetTheMaximumTimeUnit = timeUnitToGet == maximumTimeUnit;
        return timeUnitToGet switch
        {
            TimeUnit.Millisecond => GetNormalCaseTimeAsInteger(timespan.Milliseconds, timespan.TotalMilliseconds, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Second => GetNormalCaseTimeAsInteger(timespan.Seconds, timespan.TotalSeconds, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Minute => GetNormalCaseTimeAsInteger(timespan.Minutes, timespan.TotalMinutes, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Hour => GetNormalCaseTimeAsInteger(timespan.Hours, timespan.TotalHours, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Day => GetSpecialCaseDaysAsInteger(timespan, maximumTimeUnit),
            TimeUnit.Week => GetSpecialCaseWeeksAsInteger(timespan, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Month => GetSpecialCaseMonthAsInteger(timespan, isTimeUnitToGetTheMaximumTimeUnit),
            TimeUnit.Year => GetSpecialCaseYearAsInteger(timespan),
            _ => 0
        };
    }

    static int GetSpecialCaseMonthAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit)
    {
        if (isTimeUnitToGetTheMaximumTimeUnit)
        {
            return (int) (timespan.Days / _daysInAMonth);
        }

        var remainingDays = timespan.Days % _daysInAYear;
        return (int) (remainingDays / _daysInAMonth);
    }

    static int GetSpecialCaseYearAsInteger(TimeSpan timespan) =>
        (int) (timespan.Days / _daysInAYear);

    static int GetSpecialCaseWeeksAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit)
    {
        if (isTimeUnitToGetTheMaximumTimeUnit || timespan.Days < _daysInAMonth)
        {
            return timespan.Days / _daysInAWeek;
        }

        return 0;
    }

    static int GetSpecialCaseDaysAsInteger(TimeSpan timespan, TimeUnit maximumTimeUnit)
    {
        if (maximumTimeUnit == TimeUnit.Day)
        {
            return timespan.Days;
        }

        if (timespan.Days < _daysInAMonth || maximumTimeUnit == TimeUnit.Week)
        {
            var remainingDays = timespan.Days % _daysInAWeek;
            return remainingDays;
        }

        return (int) (timespan.Days % _daysInAMonth);
    }

    static int GetNormalCaseTimeAsInteger(int timeNumberOfUnits, double totalTimeNumberOfUnits, bool isTimeUnitToGetTheMaximumTimeUnit)
    {
        if (isTimeUnitToGetTheMaximumTimeUnit)
        {
            try
            {
                return (int) totalTimeNumberOfUnits;
            }
            catch
            {
                //To be implemented so that TimeSpanHumanize method accepts double type as unit
                return 0;
            }
        }

        return timeNumberOfUnits;
    }

    static string? BuildFormatTimePart(IFormatter cultureFormatter, TimeUnit timeUnitType, int amountOfTimeUnits, bool toWords = false) =>
        // Always use positive units to account for negative timespans
        amountOfTimeUnits != 0
            ? cultureFormatter.TimeSpanHumanize(timeUnitType, Math.Abs(amountOfTimeUnits), toWords)
            : null;

    static List<string?> CreateTimePartsWithNoTimeValue(string noTimeValue) =>
        [noTimeValue];

    static bool IsContainingOnlyNullValue(IEnumerable<string?> timeParts) =>
        timeParts.Count(x => x != null) == 0;

    static IEnumerable<string?> SetPrecisionOfTimeSpan(IEnumerable<string?> timeParts, int precision, bool countEmptyUnits)
    {
        if (!countEmptyUnits)
        {
            timeParts = timeParts.Where(x => x != null);
        }

        timeParts = timeParts.Take(precision);
        if (countEmptyUnits)
        {
            timeParts = timeParts.Where(x => x != null);
        }

        return timeParts;
    }

    static string ConcatenateTimeSpanParts(IEnumerable<string?> timeSpanParts, CultureInfo? culture, string? collectionSeparator)
    {
        if (collectionSeparator == null)
        {
            return Configurator
                .CollectionFormatters.ResolveForCulture(culture)
                .Humanize(timeSpanParts);
        }

        return string.Join(collectionSeparator, timeSpanParts);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TimeUnitToSymbolExtensions.cs ---


namespace Humanizer;

/// <summary>
/// Transform a time unit into a symbol; e.g. <see cref="TimeUnit.Year"/> => "a"
/// </summary>
public static class TimeUnitToSymbolExtensions
{
    /// <summary>
    /// TimeUnit.Day.ToSymbol() -> "d"
    /// </summary>
    /// <param name="unit">Unit of time to be turned to a symbol</param>
    /// <param name="culture">Culture to use. If null, current thread's UI culture is used.</param>
    public static string ToSymbol(this TimeUnit unit, CultureInfo? culture = null) =>
        Configurator.GetFormatter(culture).TimeUnitHumanize(unit);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\ToQuantityExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Enumerates the ways of displaying a quantity value when converting
/// a word to a quantity string.
/// </summary>
public enum ShowQuantityAs
{
    /// <summary>
    /// Indicates that no quantity will be included in the formatted string.
    /// </summary>
    None = 0,

    /// <summary>
    /// Indicates that the quantity will be included in the output, formatted
    /// as its numeric value (e.g. "1").
    /// </summary>
    Numeric,

    /// <summary>
    /// Incidates that the quantity will be included in the output, formatted as
    /// words (e.g. 123 => "one hundred and twenty three").
    /// </summary>
    Words
}

/// <summary>
/// Provides extensions for formatting a <see cref="string"/> word as a quantity.
/// </summary>
public static class ToQuantityExtensions
{
    /// <summary>
    /// Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
    /// </summary>
    /// <param name="input">The word to be prefixed</param>
    /// <param name="quantity">The quantity of the word</param>
    /// <param name="showQuantityAs">How to show the quantity. Numeric by default</param>
    /// <example>
    /// "request".ToQuantity(0) => "0 requests"
    /// "request".ToQuantity(1) => "1 request"
    /// "request".ToQuantity(2) => "2 requests"
    /// "men".ToQuantity(2) => "2 men"
    /// "process".ToQuantity(1200, ShowQuantityAs.Words) => "one thousand two hundred processes"
    /// </example>
    public static string ToQuantity(this string input, long quantity, ShowQuantityAs showQuantityAs = ShowQuantityAs.Numeric) =>
        input.ToQuantity(quantity, showQuantityAs, format: null, formatProvider: null);

    /// <summary>
    /// Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
    /// </summary>
    /// <param name="input">The word to be prefixed</param>
    /// <param name="quantity">The quantity of the word</param>
    /// <param name="format">A standard or custom numeric format string.</param>
    /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
    /// <example>
    /// "request".ToQuantity(0) => "0 requests"
    /// "request".ToQuantity(10000, format: "N0") => "10,000 requests"
    /// "request".ToQuantity(1, format: "N0") => "1 request"
    /// </example>
    public static string ToQuantity(this string input, long quantity, string? format, IFormatProvider? formatProvider = null) =>
        input.ToQuantity(quantity, showQuantityAs: ShowQuantityAs.Numeric, format: format, formatProvider: formatProvider);

    static string ToQuantity(this string input, long quantity, ShowQuantityAs showQuantityAs = ShowQuantityAs.Numeric, string? format = null, IFormatProvider? formatProvider = null)
    {
        var transformedInput = quantity == 1
            ? input.Singularize(inputIsKnownToBePlural: false)
            : input.Pluralize(inputIsKnownToBeSingular: false);

        if (showQuantityAs == ShowQuantityAs.None)
        {
            return transformedInput;
        }

        if (showQuantityAs == ShowQuantityAs.Numeric)
        {
            return string.Format(formatProvider, "{0} {1}", quantity.ToString(format, formatProvider), transformedInput);
        }

        return $"{quantity.ToWords()} {transformedInput}";
    }

    /// <summary>
    /// Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
    /// </summary>
    /// <param name="input">The word to be prefixed</param>
    /// <param name="quantity">The quantity of the word</param>
    /// <param name="format">A standard or custom numeric format string.</param>
    /// <param name="formatProvider">An object that supplies culture-specific formatting information.</param>
    /// <example>
    /// "request".ToQuantity(0.2) => "0.2 requests"
    /// "request".ToQuantity(10.6, format: "N0") => "10.6 requests"
    /// "request".ToQuantity(1.0, format: "N0") => "1 request"
    /// </example>
    public static string ToQuantity(this string input, double quantity, string? format = null, IFormatProvider? formatProvider = null)
    {
        var transformedInput = quantity == 1
            ? input.Singularize(inputIsKnownToBePlural: false)
            : input.Pluralize(inputIsKnownToBeSingular: false);

        return string.Format(formatProvider, "{0} {1}", quantity.ToString(format, formatProvider), transformedInput);
    }

    /// <summary>
    /// Prefixes the provided word with the number and accordingly pluralizes or singularizes the word
    /// </summary>
    /// <param name="input">The word to be prefixed</param>
    /// <param name="quantity">The quantity of the word</param>
    /// <example>
    /// "request".ToQuantity(0.2) => "0.2 requests"
    /// </example>
    public static string ToQuantity(this string input, double quantity) =>
        ToQuantity(input, quantity, null, null);
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TruncateExtensions.cs ---


using System;

namespace Humanizer;

/// <summary>
/// Allow strings to be truncated
/// </summary>
public static class TruncateExtensions
{
    /// <summary>
    /// Truncate the string
    /// </summary>
    /// <param name="input">The string to be truncated</param>
    /// <param name="length">The length to truncate to</param>
    /// <returns>The truncated string</returns>
    [return: NotNullIfNotNull(nameof(input))]
    public static string? Truncate(this string? input, int length) =>
        input.Truncate(length, "", Truncator.FixedLength);

    /// <summary>
    /// Truncate the string
    /// </summary>
    /// <param name="input">The string to be truncated</param>
    /// <param name="length">The length to truncate to</param>
    /// <param name="truncator">The truncate to use</param>
    /// <param name="from">The enum value used to determine from where to truncate the string</param>
    /// <returns>The truncated string</returns>
    [return: NotNullIfNotNull(nameof(input))]
    public static string? Truncate(this string? input, int length, ITruncator truncator, TruncateFrom from = TruncateFrom.Right) =>
        input.Truncate(length, "", truncator, from);

    /// <summary>
    /// Truncate the string
    /// </summary>
    /// <param name="input">The string to be truncated</param>
    /// <param name="length">The length to truncate to</param>
    /// <param name="truncationString">The string used to truncate with</param>
    /// <param name="from">The enum value used to determine from where to truncate the string</param>
    /// <returns>The truncated string</returns>
    [return: NotNullIfNotNull(nameof(input))]
    public static string? Truncate(this string? input, int length, string? truncationString, TruncateFrom from = TruncateFrom.Right) =>
        input.Truncate(length, truncationString, Truncator.FixedLength, from);

    /// <summary>
    /// Truncate the string
    /// </summary>
    /// <param name="input">The string to be truncated</param>
    /// <param name="length">The length to truncate to</param>
    /// <param name="truncationString">The string used to truncate with</param>
    /// <param name="truncator">The truncator to use</param>
    /// <param name="from">The enum value used to determine from where to truncate the string</param>
    /// <returns>The truncated string</returns>
    [return: NotNullIfNotNull(nameof(input))]
    public static string? Truncate(this string? input, int length, string? truncationString, ITruncator truncator, TruncateFrom from = TruncateFrom.Right)
    {
        if (truncator == null)
        {
            throw new ArgumentNullException(nameof(truncator));
        }

        if (input == null)
        {
            return null;
        }

        return truncator.Truncate(input, length, truncationString, from);
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TruncateFrom.cs ---


namespace Humanizer;

/// <summary>
/// Truncation location for humanizer
/// </summary>
public enum TruncateFrom
{
    /// <summary>
    /// Truncate letters from the left (start) of the string
    /// </summary>
    Left,

    /// <summary>
    /// Truncate letters from the right (end) of the string
    /// </summary>
    Right
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\TupleizeExtensions.cs ---


// ReSharper disable IdentifierTypo
// ReSharper disable StringLiteralTypo
namespace Humanizer;

/// <summary>
/// Convert int to named tuple strings (1 -> 'single', 2-> 'double' etc.).
/// Only values 1-10, 100, and 1000 have specific names. All others will return 'n-tuple'.
/// </summary>
public static class TupleizeExtensions
{
    /// <summary>
    /// Converts integer to named tuple (e.g. 'single', 'double' etc.).
    /// </summary>
    /// <param name="input">Integer</param>
    /// <returns>Named tuple</returns>
    public static string Tupleize(this int input) =>
        input switch
        {
            1 => "single",
            2 => "double",
            3 => "triple",
            4 => "quadruple",
            5 => "quintuple",
            6 => "sextuple",
            7 => "septuple",
            8 => "octuple",
            9 => "nonuple",
            10 => "decuple",
            100 => "centuple",
            1000 => "milluple",
            _ => $"{input}-tuple"
        };
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Humanizer\WordForm.cs ---


namespace Humanizer;

/// <summary>
/// Options for specifying the form of the word when different variations of the same word exists.
/// </summary>
public enum WordForm
{
    /// <summary>
    /// Indicates the normal form of a written word.
    /// </summary>
    Normal,

    /// <summary>
    /// Indicates the shortened form of a written word.
    /// </summary>
    Abbreviation,

    /// <summary>
    /// Indicates the Eifeler Rule form of a word.
    /// https://lb.wikipedia.org/wiki/Eifeler_Reegel
    /// </summary>
    Eifeler,
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\AggregateDescriptor.cs ---


using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{Name}")]
class AggregateDescriptor
{
    public ITypeSymbol StateType { get; set; }
    public string Name { get; set; }
    public readonly List<AggregateGivenDescriptor> Givens = new List<AggregateGivenDescriptor>();
    public readonly List<IMethodSymbol> PublicMethods = new List<IMethodSymbol>();

    public AggregateDescriptor(INamedTypeSymbol type)
    {
        this.Type = type;
    }

    public INamedTypeSymbol Type { get; set; }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\AggregateGivenDescriptor.cs ---


using System.Diagnostics;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{EventType.Name}")]
class AggregateGivenDescriptor
{
    public ITypeSymbol EventType { get; set; }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\AggregateStepsGenerator.cs ---


using System.Linq;
using Humanizer;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

static class AggregateStepsGenerator
{
    public static string Generate(this AggregateDescriptor d, IAssemblySymbol assemblySymbol)
    {
        StringBuilder sb = new StringBuilder();

        var dstNs = assemblySymbol.Name.ToString();

        var ns = d.Type.ContainingNamespace.ToString();
        var assemblyRootNs = d.Type.ContainingAssembly.Identity.Name;
        if (ns.StartsWith(assemblyRootNs))
        {
            var rel = ns.Substring(assemblyRootNs.Length + 1);
            dstNs = $"{dstNs}.{rel}";
        }

        sb.AppendLine($"using System;");
        sb.AppendLine($"using System.Collections.Generic;");
        sb.AppendLine($"using System.Linq;");
        sb.AppendLine($"using System.Reflection;");
        sb.AppendLine($"using System.Reflection.Emit;");
        sb.AppendLine($"using System.Text;");
        sb.AppendLine($"using System.Text.Json;");
        sb.AppendLine($"using System.Threading.Tasks;");
        sb.AppendLine($"using FluentAssertions;");
        sb.AppendLine($"using TechTalk.SpecFlow;");

        sb.AppendLine($"using {ns};");
        sb.AppendLine($"namespace {dstNs};");
        sb.AppendLine($"// Generated with Micro-Plumberd");
        sb.AppendLine("[Binding]");
        sb.AppendLine($"public partial class {d.Name}Steps(AppStepsContext context)");
        sb.AppendLine("{");

        //private readonly AggregateSpecs<FooAggregate> _aggregateSpecs = context.AggregateSpecs<FooAggregate>();

        sb.AppendLine($"    private readonly AggregateSpecs<{d.Name}> _aggregateSpecs = context.AggregateSpecs<{d.Name}>();");
        foreach (var g in d.Givens)
        {
            GenerateGivenWithIdentifier(g, d, sb);
            GenerateSingleGivens(g, d, sb);
            GenerateManyGivens(g, d, sb);
            GenerateAnotherGivens(g, d, sb);
            GenerateExpected(g, d, sb);
            
        }
        GenerateExpectedState(d, sb);
        sb.AppendLine("}");
        return sb.ToString();
    }
private static void GenerateManyGivens(AggregateGivenDescriptor g, AggregateDescriptor agg, StringBuilder sb)
    {
        Sentence words = g.EventType.Name;
        Sentence subject = agg.Name;

        var coreName = subject + words;
        coreName = coreName.ToLower()
            .Remove("aggregate")
            .RemoveDuplicates()
            .ChangeWord(0, x => x.Pluralize());

        var regex = coreName
            .ToCapitalizedRegex()
            .InsertBackwards(1, "were");


        sb.AppendLine($"    [Given(@\"{regex}[:]?\")]");
        sb.AppendLine($"    [Given(@\"Some {regex}[:]?\")]");
        sb.AppendLine($"    public async Task {coreName.Dehumanize()}(Table s)");
        sb.AppendLine("    {");

        sb.AppendLine(
            $"        var ev = _aggregateSpecs.ArgumentProvider.RecognizeManyFromTable<{g.EventType.Name}>(s);");
        sb.AppendLine($"        foreach (var i in ev)");
        sb.AppendLine($"             await _aggregateSpecs.Given(i.Id, i.Data);");

        sb.AppendLine("    }");
    }

    private static void GenerateExpected(AggregateGivenDescriptor g, AggregateDescriptor agg, StringBuilder sb)
    {
        Sentence words = g.EventType.Name;
        Sentence subject = agg.Name;

        var coreName = subject + words;
        coreName = coreName.ToLower()
            .Remove("aggregate")
            .RemoveDuplicates();

        var regex = coreName
            .ToCapitalizedRegex()
            .InsertBackwards(1, "was");


        sb.AppendLine($"    [Then(@\"I expect[,] that {regex} with[:]?\")]");
        sb.AppendLine($"    public async Task Expect{coreName.Dehumanize()}(object s)");
        sb.AppendLine("    {");

        sb.AppendLine($"        var ev = _aggregateSpecs.ArgumentProvider.Recognize<{g.EventType.Name}>(s);");
        sb.AppendLine($"        await _aggregateSpecs.ExpectedPublished(ev);");

        sb.AppendLine("    }");
    }
    private static void GenerateExpectedState(AggregateDescriptor agg, StringBuilder sb)
    {
        Sentence subject = agg.Name;

        var coreName = subject;
        coreName = coreName.ToLower()
            .Remove("aggregate")
            .RemoveDuplicates();

        var regex = coreName
            .ToCapitalizedRegex();
        
        sb.AppendLine($"    [Then(@\"I expect[,] that {regex}'s state is set with[:]?\")]");
        sb.AppendLine($"    public async Task Expect{coreName.Dehumanize()}State(object s)");
        sb.AppendLine("    {");

        sb.AppendLine($"        var anonymous = _aggregateSpecs.ArgumentProvider.Recognize(s);");
        sb.AppendLine($"        await _aggregateSpecs.Then(x => x.State().Should().BeEquivalentTo(anonymous));");

        sb.AppendLine("    }");
    }
    private static void GenerateSingleGivens(AggregateGivenDescriptor g, AggregateDescriptor agg, StringBuilder sb)
    {
        Sentence words = g.EventType.Name;
        Sentence subject = agg.Name;

        var coreName = subject + words;
        coreName = coreName.ToLower()
            .Remove("aggregate")
            .RemoveDuplicates();

        var regex1 = coreName
            .ToCapitalizedRegex()
            .InsertBackwards(1, "was");

        var regex2 = coreName
            .ToCapitalizedRegex();


        sb.AppendLine($"    [Given(@\"{regex1}[:]?\")]");
        sb.AppendLine($"    [Given(@\"{regex2}[:]?\")]");
        sb.AppendLine($"    public async Task {coreName.Dehumanize()}(object evt)");
        sb.AppendLine("    {");

        sb.AppendLine($"        var ev = _aggregateSpecs.ArgumentProvider.Recognize<{g.EventType.Name}>(evt);");
        sb.AppendLine($"        await _aggregateSpecs.Given(ev);");

        sb.AppendLine("    }");
    }

    private static void GenerateAnotherGivens(AggregateGivenDescriptor g, AggregateDescriptor agg, StringBuilder sb)
    {
        Sentence words = g.EventType.Name;
        Sentence subject = agg.Name;

        var coreName = subject + words;
        coreName = coreName.ToLower()
            .Insert(0, "Another")
            .Remove("aggregate")
            .RemoveDuplicates();

        var regex = coreName
            .ToCapitalizedRegex()
            .InsertBackwards(1, "was");


        sb.AppendLine($"    [Given(@\"{regex}[:]?\")]");
        sb.AppendLine($"    public async Task {coreName.Dehumanize()}(object evt)");
        sb.AppendLine("    {");

        sb.AppendLine($"        var ev = _aggregateSpecs.ArgumentProvider.Recognize<{g.EventType.Name}>(evt);");
        sb.AppendLine($"        await _aggregateSpecs.Given(_aggregateSpecs.AnotherSubject(), ev);");

        sb.AppendLine("    }");
    }

    private static void GenerateGivenWithIdentifier(AggregateGivenDescriptor g, AggregateDescriptor agg,
        StringBuilder sb)
    {
        //[Given(@"[F|f]oo '(.*)' was [C|c]reated[:]?")]
        //public async Task GivenFooCreated(string id, object s)
        //{
        //    var ev = _aggregateSpecs.ArgumentProvider.Recognize<FooCreated>(s);
        //    await _aggregateSpecs.Given(id, ev);
        //}
        Sentence words = g.EventType.Name;
        Sentence subject = agg.Name;

        var coreName = subject + words;
        coreName = coreName.ToLower()
            .Remove("aggregate")
            .RemoveDuplicates();

        var regex = coreName
            .ToCapitalizedRegex()
            .Insert(1, "'(.*)'")
            .InsertBackwards(1, "was");


        sb.AppendLine($"    [Given(@\"{regex}[:]?\")]");
        sb.AppendLine($"    public async Task {coreName.Dehumanize()}(string id, object evt)");
        sb.AppendLine("     {");

        sb.AppendLine($"        var ev = _aggregateSpecs.ArgumentProvider.Recognize<{g.EventType.Name}>(evt);");
        sb.AppendLine($"        await _aggregateSpecs.Given(id, ev);");

        sb.AppendLine("     }");
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\CommandHandlerDescriptor.cs ---


using System.Collections.Generic;
using System.Diagnostics;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{Name}")]
class CommandHandlerDescriptor
{
    public readonly List<HandleDescriptor> Handles = new List<HandleDescriptor>();
    public string Name { get; set; }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\EventHandlerDescriptor.cs ---


using System.Collections.Generic;
using System.Diagnostics;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{Name}")]
class EventHandlerDescriptor
{
    public string Name { get; set; }
    public readonly List<ModelGivenDescriptor> Givens = new List<ModelGivenDescriptor>();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Extensions.cs ---


using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

static class Extensions
{
    public static bool HasAttribute(this INamedTypeSymbol type, string name)
    {
        var attrs = type.GetAttributes();
        return attrs.Any(attr => attr.AttributeClass?.Name.Contains(name) ?? false);
    }

    public static IEnumerable<INamedTypeSymbol> GetAcceptedTypes(this IMethodSymbol method)
    {
        var acceptedTypeAttributes= method.GetAttributes()
            .Where(attr => attr.AttributeClass?.Name.StartsWith("AcceptedType") ?? false);
        foreach(var acceptedTypeAttribute in acceptedTypeAttributes){
                
            var acceptedTypeArgument = acceptedTypeAttribute?.ConstructorArguments.FirstOrDefault();

            if (acceptedTypeArgument?.Value is INamedTypeSymbol acceptedTypeSymbol)
                yield return acceptedTypeSymbol;
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\GenerationContext.cs ---


using System.Collections.Generic;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

class GenerationContext
{
    public readonly List<AggregateDescriptor> Aggregates = new List<AggregateDescriptor>();
    public readonly List<CommandHandlerDescriptor> CommandHandlers = new List<CommandHandlerDescriptor>();
    public readonly List<EventHandlerDescriptor> EventHandlers = new List<EventHandlerDescriptor>();
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\HandleDescriptor.cs ---


using System.Diagnostics;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{CommandType.Name}")]
class HandleDescriptor
{
    public ITypeSymbol CommandType => Method.Parameters[1].Type;
    public IMethodSymbol Method { get; set; }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\ModelGivenDescriptor.cs ---


using System.Diagnostics;
using Microsoft.CodeAnalysis;

namespace MicroPlumberd.SpecFlow.SourceGenerators;

[DebuggerDisplay("{EventType.Name}")]
class ModelGivenDescriptor
{
    public IMethodSymbol Method { get; set; }
    public ITypeSymbol EventType => Method.Parameters[1].Type;
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\Sentence.cs ---


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Humanizer;

namespace MicroPlumberd.SpecFlow.SourceGenerators
{
    public readonly struct Word : IEquatable<Word>
    {
        public Word Pluralize()
        {
            return new Word(Text.Pluralize());
        }
        public bool Equals(Word other)
        {
            return Text == other.Text;
        }

        public override bool Equals(object obj)
        {
            return obj is Word other && Equals(other);
        }

        public override int GetHashCode()
        {
            return (Text != null ? Text.GetHashCode() : 0);
        }

        public static bool operator ==(Word left, Word right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Word left, Word right)
        {
            return !left.Equals(right);
        }

        public string Text { get; }

        public Word(string text)
        {
            Text = text ?? throw new ArgumentNullException(nameof(text));
        }

        // Implicit conversion from string to Word
        public static implicit operator Word(string text) => new Word(text);

        // Override ToString() to easily convert Word back to string
        public override string ToString() => Text;

        public Word ToLower()
        {
            return new Word(Text.ToLower());
        }

        public char this[int i] => Text[i];

        public Word ToCapitalizedRegex()
        {
            if (Text.Length < 1 || !Char.IsLetter(this[0])) return this;
            var rest = Text.Length > 1 ? this.Text.Substring(1) : string.Empty;
            
            var c = this.Text[0];
            return $"[{Char.ToLower(c)}|{Char.ToUpper(c)}]{rest}";
        }
    }
    public struct Sentence : IEnumerable<Word>
    {
        private readonly List<Word> _words;

        public Sentence ChangeWord(int index, Func<Word, Word> ch)
        {
            var tmp = _words.ToList();
            tmp[index] = ch(tmp[index]);
            return new Sentence(tmp);
        }

        public Sentence ChangeEachWord(Func<Word, Word> ch)
        {
            var tmp = _words.ToList();
            for (int i = 0; i < tmp.Count; i++)
                tmp[i] = ch(tmp[i]);
            return new Sentence(tmp);
        }

        public Sentence(IEnumerable<string> words) : this(words.Select(x => (Word)x)){}
        public Sentence(IEnumerable<Word> words)
        {
            this._words = new List<Word>(words);
        }

        private Sentence(List<Word> words)
        {
            _words = words;
        }
        public static implicit operator Sentence(string text) => new Sentence(text.Humanize().Split(' '));
        public IReadOnlyList<Word> Words => _words.AsReadOnly();

        // Addition operator to add a word to a sentence
        public static Sentence operator +(Sentence sentence, Word word)
        {
            var newWords = sentence._words.ToList();
            newWords.Add(word);
            return new Sentence(newWords);
        }
        public static Sentence operator +(Sentence sentence, Sentence right)
        {
           return new Sentence(sentence.Union(right));
        }
        public static Sentence operator +(Word word, Sentence sentence)
        {
            var newWords = new List<Word>() { word };
            foreach(var i in sentence) newWords.Add(i);
            return new Sentence(newWords);
        }

        // Subtraction operator to remove a word from a sentence
        public static Sentence operator -(Sentence sentence, Word word)
        {
            var newWords = sentence._words.Where(w => w.Text != word.Text).ToList();
            return new Sentence(newWords);
        }

        public Sentence Remove(Word w)
        {
            return _words.Contains(w) ? new Sentence(_words.Where(x => !x.Equals(w))) : this;
        }
        // Method to remove duplicate words
        public Sentence RemoveDuplicates()
        {
            var uniqueWords = _words.Distinct().ToList();
            return new Sentence(uniqueWords);
        }

        public IEnumerator<Word> GetEnumerator()
        {
            return _words.GetEnumerator();
        }

        public int Count => _words.Count;
        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IEnumerable)_words).GetEnumerator();
        }

        public Sentence Insert(int index, Word word)
        {
            var tmp = this._words.ToList();
            tmp.Insert(index,word);
            return new Sentence(tmp);
        }

        public Sentence InsertBackwards(int index, Word word)
        {
            var tmp = this._words.ToList();
            tmp.Insert(tmp.Count - index, word);
            return new Sentence(tmp);
        }

        public override string ToString()
        {
            return string.Join(" ", this._words.Select(x => x.Text));
        }

        public string Dehumanize()
        {
            return ToString().Dehumanize();
        }

        public Sentence ToLower()
        {
            return new Sentence(_words.Select(x => x.ToLower()));
        }

        public Sentence ToCapitalizedRegex()
        {
            return new Sentence(_words.Select(x => x.ToCapitalizedRegex()));
        }
    }
}


// --- File: MicroPlumberd.SpecFlow.SourceGenerators\StepsGenerator.cs ---


using Microsoft.CodeAnalysis;
using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Threading.Tasks;
using Humanizer;

namespace MicroPlumberd.SpecFlow.SourceGenerators
{
    [Generator]
    public class StepsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            //System.Diagnostics.Debugger.Launch();
        }
        public static string FindAssemblyNamePattern(SyntaxTree syntaxTree)
        {
            // Find all AttributeListSyntax nodes in the syntax tree
            var attributeLists = syntaxTree.GetRoot().DescendantNodes().OfType<AttributeListSyntax>();

            foreach (var attributeList in attributeLists)
            {
                // Find all AttributeSyntax nodes within each attribute list
                foreach (var attribute in attributeList.Attributes)
                {
                    // Check if the attribute is DslFromAssembly2
                    if (attribute.Name.ToString().Contains("DslFromAssembly") || attribute.Name.ToString().Contains("DslFromAssemblyAttribute"))
                    {
                        // Check for the constructor argument
                        var argument = attribute.ArgumentList?.Arguments.FirstOrDefault();
                        // Attempt to retrieve the string value
                        if (argument?.Expression is LiteralExpressionSyntax literal && literal.IsKind(SyntaxKind.StringLiteralExpression))
                        {
                            return literal.Token.ValueText;
                        }
                    }
                }
            }

            // Return null or an appropriate value if the specific attribute or its argument is not found
            return null;
        }
        public void Execute(GeneratorExecutionContext context)
        {
            var compilation = context.Compilation;
            var stringBuilder = new StringBuilder();
            var dslAssemblyFilter = GetDslAssemblyFilterPattern(compilation);
            if (dslAssemblyFilter == null) return;
            GenerationContext genContext = new GenerationContext();
            foreach (var reference in compilation.ExternalReferences)
            {
                var assemblySymbol = compilation.GetAssemblyOrModuleSymbol(reference) as IAssemblySymbol;

                stringBuilder.AppendLine("// " + assemblySymbol.Identity);
                if (assemblySymbol.Identity.ToString().Contains(dslAssemblyFilter))
                {
                    // Now, with assemblySymbol, you can explore its namespaces and types
                    ExploreNamespace(assemblySymbol.GlobalNamespace, stringBuilder, genContext);
                }
            }
            
            foreach (var a in genContext.Aggregates)
            {
                var c = a.Generate(context.Compilation.Assembly);
                context.AddSource($"{a.Name}Steps",c);
            }
            Debug.WriteLine(stringBuilder.ToString());
        }

       

        private static string GetDslAssemblyFilterPattern(Compilation compilation)
        {
            string filter = null;

            var attrs = compilation.Assembly.GetAttributes();
            foreach (var a in attrs)
            {
                var syntaxNode = a.ApplicationSyntaxReference.GetSyntax();
                var syntaxTree = syntaxNode.SyntaxTree;
                var className = FindAssemblyNamePattern(syntaxTree);
                if (className != null)
                {
                    filter = className;
                    break;
                }

            }

            return filter;
        }

        void ExploreNamespace(INamespaceSymbol namespaceSymbol, StringBuilder stringBuilder, GenerationContext context)
        {
            foreach (var member in namespaceSymbol.GetMembers())
            {
                if (member is INamespaceSymbol subNamespace)
                {
                    ExploreNamespace(subNamespace, stringBuilder, context);
                }
                else if (member is INamedTypeSymbol typeSymbol && typeSymbol.TypeKind == TypeKind.Class)
                {
                    var members = member.GetMembers().ToArray();

                    if (typeSymbol.HasAttribute("CommandHandler"))
                    {
                        var ch = new CommandHandlerDescriptor();
                        ch.Name = typeSymbol.Name;
                        stringBuilder.AppendLine($"// Found class: {typeSymbol.ToDisplayString()}");
                        foreach (var i in members.OfType<IMethodSymbol>())
                        {
                            if (i.Name == "Handle" && i.Parameters.Length == 2) 
                                ch.Handles.Add(new HandleDescriptor(){ Method = i});
                        }
                        context.CommandHandlers.Add(ch);
                    } 
                    else if(typeSymbol.HasAttribute("Aggregate"))
                    {
                        var agg = new AggregateDescriptor(typeSymbol);
                        agg.Name = typeSymbol.Name;

                        var st = typeSymbol.Interfaces.FirstOrDefault(x => x.Name == "IAggregateStateAccessor");
                        for (ITypeSymbol c = typeSymbol; c != null; c = c.BaseType)
                        {
                            var i = c.Interfaces.FirstOrDefault(x => x.Name.Contains("IAggregateStateAccessor"));
                            if (i != null)
                            {
                                agg.StateType =i.TypeArguments[0];
                                break;
                            }
                        }

                        foreach (var m in members)
                        {
                            if (!(m is IMethodSymbol i)) continue;

                            if (i.Name == "Given" && i.Parameters.Length == 2 && i.Parameters[1].Type.ToString() == "object")
                            {
                                var attrs = i.GetAcceptedTypes();
                                foreach(var e in attrs)
                                    agg.Givens.Add(new AggregateGivenDescriptor() { EventType = e});
                            }
                            else if (i.DeclaredAccessibility == Accessibility.Public &&
                                     !i.IsStatic &&
                                     !i.IsAsync &&
                                     i.MethodKind != MethodKind.PropertyGet &&
                                     i.MethodKind != MethodKind.PropertySet &&
                                     !string.IsNullOrWhiteSpace(i.Name) &&
                                     i.MethodKind != MethodKind.Constructor)
                                agg.PublicMethods.Add(i);
                        }
                        context.Aggregates.Add(agg);
                    }
                    else if (typeSymbol.HasAttribute("EventHandler"))
                    {
                        var agg = new EventHandlerDescriptor();
                        agg.Name = typeSymbol.Name;
                        foreach (var i in members.OfType<IMethodSymbol>())
                        {
                            if (i.Name == "Given" && i.Parameters.Length == 2 && i.IsAsync)
                                agg.Givens.Add(new ModelGivenDescriptor() { Method = i });
                           
                        }
                        context.EventHandlers.Add(agg);
                    }
                }
            }
        }
    }
}



// --- File: MicroPlumberd.Testing\AggregateSpecs.cs ---


using System.Linq.Expressions;
using System.Text;
using System.Text.Json;
using EventStore.Client;
using MicroPlumberd;
using Xunit;

public class AggregateSpecs<T>(SpecsRoot root) where T : IAggregate<T>, ITypeRegister, IId
{
    public IArgumentProvider ArgumentProvider => root.ArgumentProvider;
    

    public async Task When(Action<T> mth)
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        var aggregateId = root.SubjectPool.GetOrCreate(subject);
        await When(aggregateId, mth);
    }

    private async Task When(Guid aggregateId, Action<T> mth)
    {
        var streamId = root.Plumber.Config.Conventions.ProjectionCategoryStreamConvention(typeof(T));
        var bg = root.Plumber.Client.ReadStreamAsync(Direction.Backwards, streamId, StreamPosition.End, 10, false);
        var first = await bg.FirstAsync();
        var pos = first.OriginalEventNumber;
        try
        {
            
            var a = await root.Plumber.Get<T>(aggregateId);
            mth(a);
            var publishedEvents = a.PendingEvents;
            await root.Plumber.SaveChanges(a);
            root.RegisterStepExecution<T>(StepType.When, pos, publishedEvents);
        }
        catch(Exception ex)
        {
            root.RegisterStepExecutionFailed<T>(StepType.When, ex, pos);
        }
    }

    public Task Given<TEvent>(string id, TEvent ev) => Given<TEvent>(Guid.TryParse(id, out var g) ? g : id.ToGuid(), ev);
    public async Task Given<TEvent>(Guid id, TEvent ev)
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        root.SubjectPool.Store(subject, id);
        var eventHandler = typeof(T);
        var streamId = root.Plumber.Config.Conventions.GetStreamIdConvention(eventHandler, id);
        var eventName = root.Plumber.Config.Conventions.GetEventNameConvention(eventHandler, typeof(TEvent));
        await root.Plumber.AppendEventToStream(streamId, ev, StreamState.Any, eventName);
        root.RegisterStepExecution<T>(StepType.Given, ev);
    }
    public Task Given<TEvent>(TEvent ev)
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        var aggregateId = root.SubjectPool.GetOrCreate(subject);
        return Given<TEvent>(aggregateId, ev);
    }

    public async Task ThenThrown<TException>() => await ExpectedThrown<TException>(x => true);

    public async Task ExpectedThrown<TException>(Expression<Predicate<TException>> ex)
    {
        var prv = root.ExecutedSteps.AsEnumerable()
            .Reverse()
            .TakeWhile(x => x.Type == StepType.When)
            .Where(x => x.Exception != null)
            .Select(x => x.Exception)
            .ToArray();

        var func = ex.Compile();

        if (prv.OfType<TException>().Any(e => func(e)))
            return;

        StringBuilder sb = new StringBuilder();
        sb.Append($"No exception was thrown of type: {typeof(TException).GetFriendlyName()} with {ex.ToString()} predicate");

        if (prv.Any())
        {
            sb.Append(" But those exceptions were thrown:\n");
            foreach (var i in prv.Reverse())
            {
                sb.Append($"Exception of type {i.GetType().GetFriendlyName()}: {i.Message}.");
                if (i is TException e && !func(e))
                {
                    sb.Append(" Provided predicate returned FALSE.");
                }

                sb.AppendLine();
            }
        }
        
        // Should construct message with what happend, just like in FluentAssertions.
        Assert.Fail(sb.ToString());
    }
    public async Task ExpectedPublished<TEvent>(TEvent ev)
    {
        if (ev == null) throw new ArgumentNullException("Event cannot be null");
        
        var prv = root.ExecutedSteps.AsEnumerable()
            .Reverse()
            .TakeWhile(x => x.Type == StepType.When)
            .Last();

        var pos = prv.PreCategoryStreamPosition ?? (StreamPosition.Start);
        var evts = await root.Plumber.Read<T>(pos+1).ToArrayAsync();
        if (evts.OfType<TEvent>().Any(x => ev.Equals(x)))
            return;
        StringBuilder sb = new StringBuilder($"No event found in the stream of type: {typeof(TEvent).Name} that are equal. Maybe you have forgotten to override Equals or use records instead of class???");
        if (evts.Any())
        {
            sb.Append(" But found: ");
            foreach (var e in evts)
            {
                sb.AppendLine(JsonSerializer.Serialize(e));
            }
        }
        Assert.Fail(sb.ToString());
    }

    public Task Then(Action<T> func)
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        var aggregateId = root.SubjectPool.GetOrCreate(subject);
        return Then(aggregateId, func);
    }
    public async Task Then(Guid aggregateId, Action<T> assertion)
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        root.SubjectPool.Store(subject, aggregateId);
        var agg = await root.Plumber.Get<T>(aggregateId);
        assertion(agg);
    }

    public Guid AnotherSubject()
    {
        var subject = root.Conventions.AggregateTypeSubjectConvention(typeof(T));
        return root.SubjectPool.A(subject);
    }
}


// --- File: MicroPlumberd.Testing\AppStepsContext.cs ---


using MicroPlumberd;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using TechTalk.SpecFlow;
using Xunit.Abstractions;

[Binding]
public class AppStepsContext(ITestOutputHelper output, ScenarioContext context)
{
    
    public ITestOutputHelper Output { get; } = output;
    public IHost? App { get; set; }
    public EventStoreServer? EventStore { get; set; }

    private SpecsRoot? _specs;
    
    public SpecsRoot SpecsRoot =>
        _specs ?? (_specs = new SpecsRoot(App.Services.GetRequiredService<IPlumber>(),
            new StepInfoProvider(context)));

    public AggregateSpecs<T> AggregateSpecs<T>() where T : IAggregate<T>, ITypeRegister, IId => SpecsRoot.Aggregate<T>();
    public CommandHandlerSpecs<T> CommandHandlerSpecs<T>() where T : IServiceTypeRegister => SpecsRoot.CommandHandler<T>();
    
    [AfterScenario]
    public void Cleanup()
    {
        App?.Dispose();
        EventStore?.Dispose();
    }

    public ReadModelSpecs<T> ModelSpecs<T>() where T : IEventHandler
    {
        return SpecsRoot.ReadModel<T>();
    }
}


// --- File: MicroPlumberd.Testing\ArgumentProvider.cs ---


using System.Text.Json;
using TechTalk.SpecFlow;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

class ArgumentProvider : IArgumentProvider
{
    public T RecognizeFromYaml<T>(string yaml)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(NullNamingConvention.Instance)  // see height_in_inches in sample yml 
            .Build();
        var obj = deserializer.Deserialize(yaml);
        var json = JsonSerializer.Serialize(obj);

        var ev = JsonSerializer.Deserialize<T>(json);
        return ev;
    }

    public T RecognizeFromTable<T>(Table table)
    {
        var obj = ToDictionary(table);
        return RecognizeDictionary<T>(obj);
    }

    private static T RecognizeDictionary<T>(IDictionary<string, object> obj)
    {
        var json = JsonSerializer.Serialize(obj);
        return JsonSerializer.Deserialize<T>(json);
    }

    public record Item<T>(Guid Id, T Data) : IItem<T>;
    public IReadOnlyList<IItem<T>> RecognizeManyFromTable<T>(Table table)
    {
        var props = table.Header.Except(["Id"]).ToArray();
        var result = new List<IItem<T>>();
        foreach (var r in table.Rows)
        {
            Guid id = Guid.NewGuid();
            if (table.ContainsColumn("Id"))
                id = Guid.TryParse(r["Id"], out var i) ? i : r["Id"].ToGuid();
            var data = props.ToDictionary(h => h, h => (object)r[h]);
            var tmp = new Item<T>(id, RecognizeDictionary<T>(data));
            result.Add(tmp);
        }

        return result;
    }

    private IDictionary<string, object> ToDictionary(Table table)
    {
        Dictionary<string, object> ret = new();
        if (table.Header.Count == 2 && table.Header.Contains("Property") && table.Header.Contains("Value"))
        {
            foreach (var i in table.Rows)
            {
                var prop = i["Property"];
                var value = i["Value"];
                ret.Add(prop, value);
            }
        }
        else if (table.RowCount == 1)
        {
            foreach (var i in table.Header)
            {
                ret.Add(i, table.Rows[0][i]);
            }
        }

        return ret;
    }
    public T Recognize<T>(object s) =>
        s switch
        {
            string s1 when !string.IsNullOrWhiteSpace(s1) => RecognizeFromYaml<T>(s1),
            Table t => RecognizeFromTable<T>(t),
            _ => default
        };
    public object Recognize(object s) =>
        s switch
        {
            string s1 when !string.IsNullOrWhiteSpace(s1) => Recognize(s1),
            Table t => Recognize(t),
            _ => default
        };

    public object Recognize(Table table)
    {
        var dict = ToDictionary(table);
        var anonymous = dict.ToAnonymousObject();
        return anonymous;
    }
    public object Recognize(string yaml)
    {
        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(NullNamingConvention.Instance)  // see height_in_inches in sample yml 
            .Build();
        var dict = deserializer.Deserialize<Dictionary<string,object>>(yaml);
        var anonymous = dict.ToAnonymousObject();
        return anonymous;
    }
}


// --- File: MicroPlumberd.Testing\CommandHandlerSpecs.cs ---


using MicroPlumberd;
using MicroPlumberd.Services;
using Microsoft.Extensions.DependencyInjection;

public class CommandHandlerSpecs<TCommandHandler>(SpecsRoot root) where TCommandHandler :IServiceTypeRegister
{
    private readonly ICommandBus _bus = root.Plumber.Config.ServiceProvider.GetRequiredService<ICommandBus>();

    public Task When<TCommand>(TCommand cmd)
    {
        var subject = root.Conventions.CommandHandlerTypeSubjectConvention(typeof(TCommandHandler));
        var id = root.SubjectPool.GetOrCreate(subject);
        return When(id, cmd);
    }
    public async Task When<TCommand>(Guid recipient, TCommand cmd)
    {
        if (cmd == null) throw new ArgumentNullException($"Command {typeof(TCommand).Name} cannot be null.");
        var subject = root.Conventions.CommandHandlerTypeSubjectConvention(typeof(TCommandHandler));
        root.SubjectPool.Store(subject, recipient);
        try
        {
            await _bus.SendAsync(recipient, cmd);
            root.RegisterStepExecution<TCommand>(StepType.When, cmd);
        }
        catch (Exception ex)
        {
            root.RegisterStepExecutionFailed<TCommand>(StepType.When, ex);
        }
    }
}


// --- File: MicroPlumberd.Testing\DslFromAssemblyAttribute.cs ---


using System.Reflection;

namespace MicroPlumberd.Testing
{
    

    [AttributeUsage(AttributeTargets.Assembly)]
    public sealed class DslFromAssemblyAttribute(string assembly) : Attribute
    {

    }
}



// --- File: MicroPlumberd.Testing\DynamicClassEmitter.cs ---


using System.Collections.ObjectModel;
using System.Formats.Asn1;
using System.Reflection;
using System.Reflection.Emit;
using SpecFlow.Internal.Json;
using TechTalk.SpecFlow.Bindings;


public static class DynamicClassEmitter
{
    public static object ToAnonymousObject(this IDictionary<string, object> dict)
    {
        var type = EmitClassFromDictionary(dict);
        var instance = Activator.CreateInstance(type);

        foreach (var kvp in dict)
        {
            var property = type.GetProperty(kvp.Key);
            property.SetValue(instance, kvp.Value, null);
        }

        return instance;
    }

    private static int _counter = 0;
    public static Type EmitClassFromDictionary(IDictionary<string, object> dictionary)
    {
        var assemblyName = new AssemblyName("DynamicAssembly_" + Interlocked.Increment(ref _counter));
        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
        var moduleBuilder = assemblyBuilder.DefineDynamicModule("MainModule");

        // Define a public class named 'DynamicClass'.
        var typeBuilder = moduleBuilder.DefineType("DynamicClass", TypeAttributes.Public);

        // For each key-value pair in the dictionary, define a public property.
        foreach (var kvp in dictionary)
        {
            var propertyName = kvp.Key;
            var propertyType = kvp.Value.GetType();

            // Define a private field.
            var fieldBuilder = typeBuilder.DefineField("_" + propertyName, propertyType, FieldAttributes.Private);
            // Define the property.
            var propertyBuilder = typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, null);

            // Define the 'get' accessor for the property.
            var getMethodBuilder = typeBuilder.DefineMethod("get_" + propertyName, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, propertyType, Type.EmptyTypes);
            var getIlGenerator = getMethodBuilder.GetILGenerator();
            getIlGenerator.Emit(OpCodes.Ldarg_0);
            getIlGenerator.Emit(OpCodes.Ldfld, fieldBuilder);
            getIlGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetGetMethod(getMethodBuilder);

            // Define the 'set' accessor for the property.
            var setMethodBuilder = typeBuilder.DefineMethod("set_" + propertyName, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig, null, new Type[] { propertyType });
            var setIlGenerator = setMethodBuilder.GetILGenerator();
            setIlGenerator.Emit(OpCodes.Ldarg_0);
            setIlGenerator.Emit(OpCodes.Ldarg_1);
            setIlGenerator.Emit(OpCodes.Stfld, fieldBuilder);
            setIlGenerator.Emit(OpCodes.Ret);
            propertyBuilder.SetSetMethod(setMethodBuilder);
        }

        // Create the type.
        var resultType = typeBuilder.CreateTypeInfo().AsType();
        return resultType;
    }
}


// --- File: MicroPlumberd.Testing\EventStoreServer.cs ---


using System.Diagnostics;
using System.Net;
using Docker.DotNet;
using Docker.DotNet.Models;
using EventStore.Client;
using Xunit;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace MicroPlumberd.Testing;

public class EventStoreServer :  IDisposable, IAsyncDisposable
{
    public EventStoreClientSettings GetEventStoreSettings() => EventStoreClientSettings.Create(HttpUrl.ToString());

    public Uri HttpUrl { get; }
    private readonly int httpPort;
    private static PortSearcher _searcher = new PortSearcher();
    private readonly DockerClient client;
    private readonly bool _isDebuggerAttached = false;
    public static EventStoreServer Create(string? containerName = null) => new EventStoreServer(containerName);
    public EventStoreServer() : this(null) {}
    internal EventStoreServer(string? containerName = null)
    {
        if (containerName != null)
            _containerName = containerName;
        httpPort = _searcher.FindNextAvailablePort();
        const string eventStoreHostName = "localhost";
        //await CheckDns(eventStoreHostName);
        _isDebuggerAttached = Debugger.IsAttached;
        HttpUrl = new Uri($"esdb://admin:changeit@{eventStoreHostName}:{httpPort}?tls=false&tlsVerifyCert=false");
        client = new DockerClientConfiguration()
            .CreateClient();
    }

    private string? _containerName;
    public string ContainerName => _containerName ?? $"eventstore-mem-{httpPort}";
    public int HttpPort => httpPort;

    private async Task<ContainerListResponse?> GetEventStoreContainer()
    {
        var containers = await client.Containers.ListContainersAsync(new ContainersListParameters()
        {
            All = true,
            Limit = 10000
        });
        var container = containers.FirstOrDefault(x => x.Names.Any(n => n.Contains(ContainerName)));
        return container;
    }

    public async Task<bool> Stop()
    {
        var container = await GetEventStoreContainer();
        if (container != null)
        {
            var data = await client.Containers.InspectContainerAsync(container.ID);
            if (data.State.Running)
            {
                await client.Containers.StopContainerAsync(data.ID, new ContainerStopParameters());
                return true;
            }
        }

        return false;
    }

    public async Task Restart(TimeSpan delay)
    {
        var container = await GetEventStoreContainer();
        if (container != null)
        {
            var data = await client.Containers.InspectContainerAsync(container.ID);
            if (data.State.Running)
            {
                await client.Containers.StopContainerAsync(data.ID, new ContainerStopParameters());
                await Task.Delay(delay);
                await client.Containers.StartContainerAsync(data.ID, new ContainerStartParameters());
                await Task.Delay(10000);
                return;
            }
        }

        throw new InvalidOperationException("No event-store container found");

    }
    public async Task<EventStoreServer> StartInDocker(bool wait = true, bool inMemory=true)
    {
        var container = await GetEventStoreContainer();
        if (!inMemory && container != null)
        {
            var data = await client.Containers.InspectContainerAsync(container.ID);
            await client.Containers.RemoveContainerAsync(data.ID, new ContainerRemoveParameters() { RemoveVolumes = true});
            container = null;
        }
        if (container == null)
        {
            var response = await client.Containers.CreateContainerAsync(new CreateContainerParameters()
            {
                Image = "eventstore/eventstore:latest",
                Env = new List<string>()
                {
                    "EVENTSTORE_RUN_PROJECTIONS=All",
                    "EVENTSTORE_START_STANDARD_PROJECTIONS=true",
                    "EVENTSTORE_INSECURE=true",
                    "EVENTSTORE_ENABLE_ATOM_PUB_OVER_HTTP=true",
                    $"EVENTSTORE_MEM_DB={inMemory.ToString().ToLower()}",
                    //"EVENTSTORE_CERTIFICATE_PASSWORD=ca",
                    //"EVENTSTORE_CERTIFICATE_FILE=/cert/eventstore.p12",
                    //"EVENTSTORE_TRUSTED_ROOT_CERTIFICATES_PATH=/cert/ca-certificates/"
                },
                Name = ContainerName,
                HostConfig = new HostConfig()
                {
                    PortBindings = new Dictionary<string, IList<PortBinding>>()
                    {
                        { $"2113", new List<PortBinding>() { new PortBinding() { HostPort = $"{httpPort}", HostIP = "0.0.0.0" } }}
                    }

                },
                Volumes = new Dictionary<string, EmptyStruct>() { },
                ExposedPorts = new Dictionary<string, EmptyStruct>()
                {
                    { "2113", default},
                }
            });
            await client.Containers.StartContainerAsync(response.ID, new ContainerStartParameters());
        }
        else
        {
            var data = await client.Containers.InspectContainerAsync(container.ID);
            if (data.State.Running)
                await client.Containers.RestartContainerAsync(data.ID, new ContainerRestartParameters());
            else
                await client.Containers.StartContainerAsync(data.ID, new ContainerStartParameters());
        }

        await this.GetEventStoreSettings().WaitUntilReady(TimeSpan.FromSeconds(30));
        return this;
    }

   
    private static async Task CheckDns(string eventStoreHostName)
    {
        try
        {
            var result = await Dns.GetHostEntryAsync(eventStoreHostName);
            foreach (var i in result.AddressList)
            {
                if (i.Equals(IPAddress.Loopback))
                    return;
            }
        }
        catch { }

        throw new Exception(
            $"To run tests put {eventStoreHostName} to your etc/hosts and modellution's ca certificate to trusted certificate store.");

    }

    async ValueTask Cleanup()
    {
        var container = await GetEventStoreContainer();
        if (container != null)
        {
            var data = await client.Containers.InspectContainerAsync(container.ID);
            if (data.State.Running) 
                await client.Containers.StopContainerAsync(data.ID, new ContainerStopParameters());
            await client.Containers.RemoveContainerAsync(data.ID, new ContainerRemoveParameters() { Force = true});
        }
    }

    public void Dispose()
    {
        Task.Run(Cleanup).Wait();
    }

    public ValueTask DisposeAsync()
    {
        return Cleanup();
    }
}




// --- File: MicroPlumberd.Testing\Extensions.cs ---


using System.Collections.Concurrent;
using System.Security.Cryptography;
using System.Text;

static class Extensions
{
    public static string Remove(this string t, string word) => t.Replace(word, string.Empty);
    public static byte[] ToHash(this string t)
    {
        using (SHA256 shA256 = SHA256.Create())
        {
            byte[] hash = shA256.ComputeHash(Encoding.Default.GetBytes(t));
            ulong uint64_1 = BitConverter.ToUInt64(hash, 0);
            ulong uint64_2 = BitConverter.ToUInt64(hash, 8);
            ulong uint64_3 = BitConverter.ToUInt64(hash, 16);
            ulong uint64_4 = BitConverter.ToUInt64(hash, 24);
            ulong num1 = uint64_1 ^ uint64_3;
            ulong num2 = uint64_2 ^ uint64_4;
            Memory<byte> memory = new Memory<byte>(new byte[16]);
            BitConverter.TryWriteBytes(memory.Span, num1);
            BitConverter.TryWriteBytes(memory.Slice(8, 8).Span, num2);
            return memory.ToArray();
        }
    }

    public static Guid ToGuid(this string t) => new Guid(t.ToHash());

    public static byte[] NameHash(this Type t1)
    {
        return _hashCache.GetOrAdd(t1, (Func<Type, byte[]>) (t2 => t2.FullName.ToHash()));
    }
    private static ConcurrentDictionary<Type, byte[]> _hashCache = new ConcurrentDictionary<Type, byte[]>();

    public static Guid NameId(this Type t) => new Guid(t.NameHash());
}


// --- File: MicroPlumberd.Testing\IArgumentProvider.cs ---


using TechTalk.SpecFlow;

public interface IArgumentProvider
{
    T RecognizeFromYaml<T>(string yaml);
    T RecognizeFromTable<T>(Table table);
    IReadOnlyList<IItem<T>> RecognizeManyFromTable<T>(Table table);
    T Recognize<T>(object arg);
    object Recognize(Table table);
    object Recognize(string yaml);
    object Recognize(object s);
}


// --- File: MicroPlumberd.Testing\IItem.cs ---


public interface IItem<T>
{
    Guid Id { get; }
    T Data { get; }
}


// --- File: MicroPlumberd.Testing\ISpecConventions.cs ---


public interface ISpecConventions
{
    Func<Type, string> AggregateTypeSubjectConvention { get; set; }
    Func<Type, string> CommandHandlerTypeSubjectConvention { get; set; }
}


// --- File: MicroPlumberd.Testing\IStepInfoProvider.cs ---


using TechTalk.SpecFlow;

public interface IStepInfoProvider
{
    string CurrentStepName { get; }
    Table Table { get; }
    string Multiline { get; }
}


// --- File: MicroPlumberd.Testing\ISubjectPool.cs ---


public interface ISubjectPool
{
    Guid Store(string subject, Guid id);
    Guid A(string subject);
    Guid The(string subject);
    Guid GetOrCreate(string subject);
}


// --- File: MicroPlumberd.Testing\PortSearcher.cs ---


using System.Net;
using System.Net.Sockets;

namespace MicroPlumberd.Testing;

public class PortSearcher
{
    private int lastPort = 2700;

    public PortSearcher()
    {
        
    }

    public PortSearcher(int startPort)
    {
        lastPort = startPort;
    }
    public int FindNextAvailablePort()
    {
        var actual = Interlocked.Increment(ref this.lastPort);
        while (true)
        {
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            try
            {
                
                socket.Bind(new IPEndPoint(IPAddress.Loopback, actual));
                socket.Listen();
                socket.Close();
                socket.Dispose();
                Thread.Sleep(100);
                
                return actual;
            }
            catch (SocketException)
            {
                // Increment the port number and try again
                actual = Interlocked.Increment(ref this.lastPort);
                socket.Dispose();
            }
        }
    }
}


// --- File: MicroPlumberd.Testing\ReadModelSpecs.cs ---


using Microsoft.Extensions.DependencyInjection;

public class ReadModelSpecs<T>(SpecsRoot root)
{
    public async Task When<TValue>(Func<T, Task<TValue>> valueExtractor)
    {
        await using var scope = root.Plumber.Config.ServiceProvider.CreateAsyncScope();
        var model = scope.ServiceProvider.GetRequiredService<T>();
        await Task.Delay(5000);
        var value = await valueExtractor(model);
        root.RegisterQueryStepExecution<T>(StepType.When, value);
    }

    public void ThenQueryResult(Action<object> assertion)
    {
        var queryResults = root.ExecutedSteps
            .Reverse()
            .TakeWhile(x => x.Type == StepType.When)
            .Where(x=> x.QueryResult != null && x.HandlerType == typeof(T))
            .Select(x=>x.QueryResult)
            .ToArray();

        foreach (var qr in queryResults) 
            assertion(qr);
    }
}


// --- File: MicroPlumberd.Testing\SpecConventions.cs ---


using MicroPlumberd;

class SpecConventions : ISpecConventions
{
    public Func<Type, string> AggregateTypeSubjectConvention { get; set; } = x => x.GetFriendlyName().Remove("Aggregate");
    public Func<Type, string> CommandHandlerTypeSubjectConvention { get; set; } = x => x.GetFriendlyName().Remove("CommandHandler");
}


// --- File: MicroPlumberd.Testing\SpecsContext.cs ---


namespace MicroPlumberd.Testing;

public class SpecsContext(IPlumber plumber)
{
        
    private Dictionary<Type, Dictionary<string, object>> _index = new();
        
}


// --- File: MicroPlumberd.Testing\SpecsRoot.cs ---


using System.Collections.Concurrent;
using EventStore.Client;
using MicroPlumberd;
using MicroPlumberd.Services;

public class SpecsRoot
{
    public ISpecConventions Conventions { get; private set; } = new SpecConventions();
    public ISubjectPool SubjectPool { get; private set; } = new SubjectPool();
    public IArgumentProvider ArgumentProvider { get; set; } 
    internal void RegisterStepExecution<T>(StepType type, StreamPosition pos, params object[] events){
        _executedSteps.Add(new Step()
        {
            PreCategoryStreamPosition = pos,
            Type=type,
            Events = events,
            Text=_stepInfoProvider.CurrentStepName, 
            HandlerType = typeof(T) 
        });
    }
    internal void RegisterStepExecution<T>(StepType type,params object[] events){
        _executedSteps.Add(new Step()
        {
            Type=type,
            Events = events,
            Text=_stepInfoProvider.CurrentStepName, 
            HandlerType = typeof(T) 
        });
    }
    internal void RegisterQueryStepExecution<T>(StepType type, object queryResult){
        _executedSteps.Add(new Step()
        {
            Type=type,
            QueryResult = queryResult,
            Text=_stepInfoProvider.CurrentStepName, 
            HandlerType = typeof(T) 
        });
    }
    internal void RegisterStepExecutionFailed<T>(StepType type, Exception ex, StreamPosition? pos=null){
        _executedSteps.Add(new Step()
        {
            Type=type,
            Exception = ex,
            Text=_stepInfoProvider.CurrentStepName, 
            HandlerType = typeof(T) ,
            PreCategoryStreamPosition = pos
        });
    }

    private readonly ConcurrentDictionary<Type, object> _specs = new();
    private readonly List<Step> _executedSteps = new();
    private readonly IPlumber _plumber;
    private readonly IStepInfoProvider _stepInfoProvider;
    
    internal IPlumber Plumber => _plumber;
    internal IStepInfoProvider StepInfoProvider => _stepInfoProvider;
    internal IEnumerable<Step> ExecutedSteps => _executedSteps;
    
    public SpecsRoot(IPlumber plumber, IStepInfoProvider stepInfoProvider)
    {
        _plumber = plumber;
        _stepInfoProvider = stepInfoProvider;
        ArgumentProvider = new ArgumentProvider();
    }
    public AggregateSpecs<T> Aggregate<T>() where T : IAggregate<T>, ITypeRegister, IId
    {
        return (AggregateSpecs<T>)_specs.GetOrAdd(typeof(T), x => new AggregateSpecs<T>(this));
    }
    public CommandHandlerSpecs<T> CommandHandler<T>() where T : IServiceTypeRegister
    {
        return (CommandHandlerSpecs<T>)_specs.GetOrAdd(typeof(T), x => new CommandHandlerSpecs<T>(this));
    }

    public ReadModelSpecs<T> ReadModel<T>() where T : IEventHandler
    {
        return (ReadModelSpecs<T>)_specs.GetOrAdd(typeof(T), x => new ReadModelSpecs<T>(this));
    }
}


// --- File: MicroPlumberd.Testing\Step.cs ---


using EventStore.Client;

internal class Step
{
    public Type HandlerType { get; init; }
    public object[] Events { get; init; }
    public object? QueryResult { get; init; }
    public string Text { get; init; }
    public StepType Type { get; init; }
    public Exception? Exception { get; set; }
    public StreamPosition? PreCategoryStreamPosition { get; init; }
}


// --- File: MicroPlumberd.Testing\StepInfoProvider.cs ---


using TechTalk.SpecFlow;

class StepInfoProvider(ScenarioContext scenarioContext) : IStepInfoProvider
{
    public string CurrentStepName => scenarioContext.StepContext.StepInfo.Text;
    public Table Table => scenarioContext.StepContext.StepInfo.Table;
    public string Multiline => scenarioContext.StepContext.StepInfo.MultilineText;
}


// --- File: MicroPlumberd.Testing\StepType.cs ---


enum StepType
{
    Given, When, Then
}


// --- File: MicroPlumberd.Testing\SubjectPool.cs ---


class SubjectPool : ISubjectPool
{
    private readonly Dictionary<string, List<Guid>> _index = new();

    public Guid Store(string subject, Guid id)
    {
        if (!_index.TryGetValue(subject, out var l))
            return WithNewList(subject, id)[0];
        if(l.Last() != id)
            l.Add(id);
        return id;
    }

    public Guid A(string subject)
    {
        if (!_index.TryGetValue(subject, out var l)) 
            return WithNewList(subject);
        var r = Guid.NewGuid();
        l.Add(r);
        return r;
    }

    public Guid The(string subject)
    {
        if (_index.TryGetValue(subject, out var l))
            return l.Last();
        throw new ArgumentOutOfRangeException($"Subject named {subject} was not defined.");
    }
    private Guid WithNewList(string key) => WithNewList(key, Guid.NewGuid())[0];

    private Guid[] WithNewList(string key, params Guid[] ids)
    {
        _index.Add(key, [..ids]);
        return ids;
    }
    public Guid GetOrCreate(string subject) => _index.TryGetValue(subject, out var l) ? l.Last() : WithNewList(subject);
}


// --- File: MicroPlumberd.Testing\TestCollection.cs ---


using Xunit;

namespace MicroPlumberd.Testing;

[CollectionDefinition("Specs")]
public class TestCollection : ICollectionFixture<SpecsContext>
{
    // This class has no code and is never created. Its purpose is solely
    // to be the place to apply [CollectionDefinition] and all the
    // ICollectionFixture<> interfaces.
}


// --- File: MicroPlumberd.Tests\HowTo\PlumberMethodsTests.cs ---


using EventStore.Client;
using FluentAssertions;
using LiteDB;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;

using MicroPlumberd.Tests.App.CinemaDomain;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;

using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Identity.Client;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.HowTo
{
    [TestCategory("HowTo")]
    public class PlumberMethodsTests : IClassFixture<EventStoreServer>, IDisposable
    {
        private readonly IPlumber plumber;
        private readonly EventStoreServer es;
        private readonly TestAppHost _host;

        public PlumberMethodsTests(EventStoreServer es, ITestOutputHelper logger)
        {
            plumber = Plumber.Create(es.GetEventStoreSettings());
            _host = new TestAppHost(logger);
            this.es = es;
        }
        [Fact]
        public async Task HowToAppendEventToHisBaseStream()
        {
            await es.StartInDocker();

            var ourLovelyEvent = new TicketReserved();
            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            await plumber.AppendEvent(ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
        }

        [Fact]
        public async Task HowToAppendEventToSpecificStream()
        {
            await es.StartInDocker();

            var streamIdentifier = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved();

            await plumber.AppendEventToStream($"VIPReservationStream-{streamIdentifier}", ourLovelyEvent);

        }

       
        [Fact]
        public async Task HowToMakeModelSubscribe()
        {
            await es.StartInDocker();

            var fromWhenShouldWeSubscribeOurStream = FromRelativeStreamPosition.Start;
            var modelThatWantToSubscribeToStream = new ReservationModel(new InMemoryAssertionDb());
          

            await plumber.SubscribeEventHandler(modelThatWantToSubscribeToStream, start: fromWhenShouldWeSubscribeOurStream);

            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved();

            await plumber.AppendEvent(ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);

            modelThatWantToSubscribeToStream.EventHandled.Should().BeTrue();
          
        }

        [Fact]
        public async Task HowToSubscribeRealModel()
        {
            await es.StartInDocker();

            using var db = LiteDbFactory.Get();
            var dbModel = new DbReservationModel(LiteDbFactory.Get());

            await plumber.SubscribeEventHandler(dbModel);

            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved() { MovieName = "Golden Eye", RoomName = "101"};

            await plumber.AppendEvent(ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);

            dbModel.Reservations.Query().Count().Should().Be(1);

        }
        [Fact]
        public async Task HowToSubscribeRealModelWithHost()
        {
            await es.StartInDocker();

            var sp = await _host.Configure(x => x
                    .AddSingleton<LiteDatabase>((sp) => LiteDbFactory.Get())
                    .AddEventHandler<DbReservationModel>(true)
                    .AddPlumberd(es.GetEventStoreSettings()))
                .StartAsync();
            
            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved() { MovieName = "Golden Eye", RoomName = "101" };

            await sp.GetRequiredService<IPlumber>().AppendEvent(ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);

            sp.GetRequiredService<LiteDatabase>().Reservations().Query().Count().Should().Be(1);

        }

        [Fact]
        public async Task HowToMakeModelSubscribeFromLastEvent()
        {
            await es.StartInDocker();

            var modelThatWantToSubscribeToStream = new ReservationModel(new InMemoryAssertionDb());
            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var someVeryOldEvent = new TicketReserved();

            await plumber.AppendEvent(someVeryOldEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);

            await plumber.SubscribeEventHandler(modelThatWantToSubscribeToStream, start: FromRelativeStreamPosition.End-1);
            modelThatWantToSubscribeToStream.EventHandled.Should().BeFalse();

            var ourLovelyEvent = new TicketReserved();

            await plumber.AppendEvent(ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);
            modelThatWantToSubscribeToStream.EventHandled.Should().BeTrue();


        }
        [Fact]
        public async Task HowToLinkEventsToOtherStream()
        {
            await es.StartInDocker();

            var ourLovelyEvent = new TicketReserved()
            {
                MovieName = "Scream",
                RoomName = "Venus"
            };
            await plumber.SubscribeEventHandlerPersistently(new TicketProjection(plumber));
            await plumber.AppendEvent(ourLovelyEvent);

            await plumber.Subscribe($"RoomOccupancy-{ourLovelyEvent.RoomName}", FromRelativeStreamPosition.Start)
                .WithHandler(new RoomOccupancy());


        }
        [Fact]
        public async Task HowToFindEventInStream()
        {
            await es.StartInDocker();

            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved();

            await plumber.AppendEvent( ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            
            //await plumber.FindEventInStream($"ReservationStream-{streamIdentifier}", ourLovelyEvent);


        }
        [Fact]
        public async Task HowToRehydrateModel()
        {
            await es.StartInDocker();
            var modelThatWantToSubscribeToStream = new ReservationModel(new InMemoryAssertionDb());
            var suffixOfStreamWhereOurEventWillBeAppend = Guid.NewGuid();
            var ourLovelyEvent = new TicketReserved();

            await plumber.AppendEvent( ourLovelyEvent, suffixOfStreamWhereOurEventWillBeAppend);
            await Task.Delay(1000);

            await plumber.SubscribeEventHandler(modelThatWantToSubscribeToStream, start: FromRelativeStreamPosition.Start);

            await Task.Delay(1000);
            modelThatWantToSubscribeToStream.EventHandled.Should().BeTrue();

            modelThatWantToSubscribeToStream.EventHandled = false;
            modelThatWantToSubscribeToStream.EventHandled.Should().BeFalse();

            await plumber.Rehydrate(modelThatWantToSubscribeToStream,
                $"ReservationStream-{suffixOfStreamWhereOurEventWillBeAppend}");

            modelThatWantToSubscribeToStream.EventHandled.Should().BeTrue();

        }


        public void Dispose()
        {
            _host?.Dispose();
        }
    }
}



// --- File: MicroPlumberd.Tests\Integration\Services\Grpc\DirectConnect\Fixtures\ClientApp.cs ---


using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd.Tests.Integration.Services.Grpc.DirectConnect.Fixtures;

class ClientApp : IDisposable, IAsyncDisposable
{
    private ServiceProvider? sp;

    public IServiceProvider Start(Action<IServiceCollection>? configure = null)
    {
        IServiceCollection service = new ServiceCollection();


        configure?.Invoke(service);

        return sp = service.BuildServiceProvider();
    }

    public void Dispose()
    {
        sp?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        if (sp != null)
            await sp.DisposeAsync();
    }
}


// --- File: MicroPlumberd.Tests\Integration\Services\Grpc\DirectConnect\Fixtures\ServerApp.cs ---


using EventStore.Client;
using MicroPlumberd.Testing;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.VisualStudio.TestPlatform.CommunicationUtilities;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.Tests.Integration.Services.Grpc.DirectConnect.Fixtures;

class ServerApp : IDisposable, IAsyncDisposable
{
    private static PortSearcher _portSearcher = new PortSearcher(5001);
    private readonly int _esPort;
    private WebApplication? app;
    public int HttpPort { get; private set; }
    public ServerApp(int esPort)
    {
        _esPort = esPort;
        HttpPort = _portSearcher.FindNextAvailablePort();
    }
    public async Task<IServiceProvider> StartAsync(Action<IServiceCollection>? configure = null)
    {
        var builder = WebApplication.CreateBuilder();

        // Add services to the container.
        builder.Services.AddGrpc();

        configure?.Invoke(builder.Services);
        builder.Services.AddSingleton<IPlumber>(sp => sp.GetRequiredService<Plumber>());
        builder.Services.AddSingleton(new Plumber(GetEventStoreSettings()));
        // Adding a decorator for logging.
        builder.Services.TryDecorate(typeof(IRequestHandler<>), typeof(LoggerRequestAspect<>));
        builder.Services.TryDecorate(typeof(IRequestHandler<,>), typeof(LoggerRequestResponseAspect<,>));

        builder.WebHost.ConfigureKestrel(options =>
        {
            // Setup a HTTP/2 endpoint without TLS for development purposes.
            options.ListenLocalhost(HttpPort, o => o.Protocols = HttpProtocols.Http2);
        });

        app = builder.Build();

        // Configure the HTTP request pipeline.
        app.MapDirectConnect();
        app.MapGet("/", () => "This server supports gRPC");

        await app.StartAsync();
        return app.Services;
    }
    private EventStoreClientSettings GetEventStoreSettings()
    {
        string connectionString = $"esdb://admin:changeit@localhost:{_esPort}?tls=false&tlsVerifyCert=false";

        return EventStoreClientSettings.Create(connectionString);
    }
    public void Dispose()
    {
        (app as IDisposable)?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        if (app != null)
            await app.DisposeAsync();
    }
}


// --- File: MicroPlumberd.Tests\Integration\Services\Grpc\DirectConnect\GrpcApiTests.cs ---


using System.Diagnostics;
using System.Net;
using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.DirectConnect;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;
using MicroPlumberd.Tests.App.Srv;
using MicroPlumberd.Tests.Integration.Services.Grpc.DirectConnect.Fixtures;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using ModelingEvolution.DirectConnect;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Integration.Services.Grpc.DirectConnect;


[TestCategory("Integration")]
public class GrpcApiTests : IClassFixture<EventStoreServer>, IAsyncDisposable, IDisposable
{
    private readonly EventStoreServer _eventStore;
    private readonly ITestOutputHelper _testOutputHelper;
    private Fixtures.ClientApp? client;

    public GrpcApiTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
    {
        _eventStore = eventStore;
        _testOutputHelper = testOutputHelper;
    }

    [Fact]
    public async Task ApiSuccessfulInvocation()
    {
        await _eventStore.StartInDocker();
        await using ServerApp srv = new ServerApp(_eventStore.HttpPort);
        await srv.StartAsync(x => { x.AddCommandHandler<FooCommandHandler>().AddServerDirectConnect(); });

        var invoker = ArrangeClientApp(srv.HttpPort);
        var streamId = Guid.NewGuid();

        await invoker.Execute(streamId, new CreateFoo() { Name = "Hello" });
        Stopwatch sw = new Stopwatch();
        sw.Start();
        var ret2 = await invoker.Execute<HandlerOperationStatus>(streamId, new RefineFoo() { Name = "Hello" });
        _testOutputHelper.WriteLine("Command executed in:" + sw.Elapsed);
        ret2.Code.Should().Be(HttpStatusCode.OK);
    }
    [Fact]
    public async Task ApiInvocationWithProcessorCorrelation()
    {
        await _eventStore.StartInDocker();
        // App Server
        await using ServerApp srv = new ServerApp(_eventStore.HttpPort);

        var srvProvider = await srv.StartAsync(x =>
        {
            x.AddCommandHandler<FooCommandHandler>().AddServerDirectConnect();
        });
        FooModel srvModel = new FooModel(new InMemoryAssertionDb());

        await srvProvider.GetRequiredService<IPlumber>().SubscribeEventHandler(srvModel, start: FromStream.End);
        await srvProvider.GetRequiredService<IPlumber>().SubscribeEventHandler(new FooProcessor(srvProvider.GetRequiredService<IPlumber>()), start: FromStream.End);

        // Making sure we have subscribed.
        await Task.Delay(1000);

        // Client App
        var invoker = ArrangeClientApp(srv.HttpPort);

        // Invocation
        var streamId = Guid.NewGuid();
        var initialCommand = new CreateFoo() { Name = "Hello" };
        await invoker.Execute(streamId, initialCommand);
        var secondCommand = new RefineFoo() { Name = "Hello" };
        var ret = await invoker.Execute<HandlerOperationStatus>(streamId, secondCommand);
        ret.Code.Should().Be(HttpStatusCode.OK);

        await Task.Delay(1000);
        // Let's wait for results to flow back.
        srvModel.AssertionDb.Index.Should().HaveCount(3);
        srvModel.AssertionDb.Index[2].Metadata.CorrelationId().Should().Be(secondCommand.Id);
        srvModel.AssertionDb.Index[2].Event.Should().BeOfType<FooCreated>();
    }

    private IRequestInvoker ArrangeClientApp(int port)
    {
        client = new Fixtures.ClientApp();

        var sp = client.Start(service => service.AddClientDirectConnect()
            .AddCommandInvokers(typeof(CreateFoo), typeof(RefineFoo)));

        var clientPool = sp.GetRequiredService<IRequestInvokerPool>();
        var invoker = clientPool.Get($"http://localhost:{port}");

        return invoker;
    }

    [Fact]
    public async Task ApiHandingExceptionInvocation()
    {
        await _eventStore.StartInDocker();
        await using ServerApp srv = new ServerApp(_eventStore.HttpPort);

        await srv.StartAsync(x => { x.AddCommandHandler<FooCommandHandler>().AddServerDirectConnect(); });

        var invoker = ArrangeClientApp(srv.HttpPort);
        var streamId = Guid.NewGuid();

        await invoker.Execute(streamId, new CreateFoo() { Name = "Hello" });

        var action = async () => await invoker.Execute<HandlerOperationStatus>(streamId, new RefineFoo() { Name = "error" });
        await action.Should().ThrowAsync<FaultException<BusinessFault>>();
    }


    public void Dispose()
    {
        client?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        if (client != null)
            await client.DisposeAsync();
    }
}



// --- File: MicroPlumberd.Tests\Integration\Services\CommandBusTests.cs ---


using System.ComponentModel.DataAnnotations;
using FluentAssertions;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Srv;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Integration.Services;

[TestCategory("Integration")]
public class CommandBusTests : IClassFixture<EventStoreServer>
{
    private readonly EventStoreServer _eventStore;
    private readonly ITestOutputHelper _testOutputHelper;
    private readonly TestAppHost _serverTestApp;
    private readonly TestAppHost _clientTestApp;

    public CommandBusTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
    {
        _eventStore = eventStore;
        _testOutputHelper = testOutputHelper;
        _serverTestApp = new TestAppHost(testOutputHelper);
        _clientTestApp = new TestAppHost(testOutputHelper);
    }
        
    [Fact]
    public async Task HandleAggregateValidateCommand()
    {
        await _eventStore.StartInDocker();

        var client = await _clientTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10)))
            .StartAsync();

        var bus = client.GetRequiredService<ICommandBus>();
            
        var recipientId = Guid.NewGuid();
        var mth = async () => await bus.SendAsync(recipientId, new ValidateBoo() { Name = $"1" });
        await mth.Should().ThrowAsync<ValidationException>();

    }



}


// --- File: MicroPlumberd.Tests\Integration\Services\CommandHandlerTests.cs ---


using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Docker.DotNet.Models;
using EventStore.Client;
using MicroPlumberd.Services;

using FluentAssertions;
using MicroPlumberd.Protobuf;
using MicroPlumberd.Testing;
using ModelingEvolution.DirectConnect;
using Xunit.Abstractions;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;
using MicroPlumberd.Tests.App.Srv;
using Xunit.Sdk;
using static MicroPlumberd.Tests.Integration.Services.FluentAssertionExtensions;

namespace MicroPlumberd.Tests.Integration.Services
{
    public static class FluentAssertionExtensions
    {
        public static async Task Eventually(
            Func<Task> action,
            TimeSpan? timeout = null,
            TimeSpan? interval = null)
        {
            timeout ??= TimeSpan.FromSeconds(5);
            interval ??= TimeSpan.FromMilliseconds(100);

            var sw = Stopwatch.StartNew();
            Exception? lastException = null;

            while (sw.Elapsed < timeout)
            {
                try
                {
                    await action();
                    return;
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    await Task.Delay(interval.Value);
                }
            }

            throw new XunitException($"Assertion failed within timeout of {timeout}. Last error: {lastException}");
        }
        public static async Task Eventually(
            Action action,
            TimeSpan? timeout = null,
            TimeSpan? interval = null)
        {
            timeout ??= TimeSpan.FromSeconds(5);
            interval ??= TimeSpan.FromMilliseconds(100);

            var sw = Stopwatch.StartNew();
            Exception? lastException = null;

            while (sw.Elapsed < timeout)
            {
                try
                {
                    action();
                    return;
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    await Task.Delay(interval.Value);
                }
            }

            throw new XunitException($"Assertion failed within timeout of {timeout}. Last error: {lastException}");
        }
    }
    
    [TestCategory("Integration")]
    public class CommandHandlerTests : IClassFixture<EventStoreServer>, IAsyncLifetime
    {
        private readonly EventStoreServer _eventStore;
        private readonly ITestOutputHelper _testOutputHelper;
        private readonly TestAppHost _serverTestApp;
        private readonly TestAppHost _clientTestApp;

        public CommandHandlerTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
        {
            _eventStore = eventStore;
            _testOutputHelper = testOutputHelper;
            _serverTestApp = new TestAppHost(testOutputHelper);
            _clientTestApp = new TestAppHost(testOutputHelper);
        }
        [Fact]
        public async Task HandleAggregateCommandsWithProtoSerialization()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp,x)=>x.SerializerFactory = x => new ProtoBuffObjectSerialization())
                .AddCommandHandler<BooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();
            

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) =>
                    {
                        x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10);
                        x.SerializerFactory = x => new ProtoBuffObjectSerialization();
                    }))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            Stopwatch sw = new Stopwatch();
            sw.Start();
            var recipientId = Guid.NewGuid();
            await bus.SendAsync(recipientId, new CreateBoo() { Name = $"Name1" });
            for (int i = 0; i < 1000; i++)
                await bus.SendAsync(recipientId, new RefineBoo() { Name = $"Name_{i}" });

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed / 101);

            await Task.Delay(3000);

        }
        [Fact]
        public async Task HandleAggregateCommands()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<BooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();
            
            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10)))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            Stopwatch sw = new Stopwatch();
            sw.Start();
            var recipientId = Guid.NewGuid();
            await bus.SendAsync(recipientId, new CreateBoo() { Name = $"Name1" });
            for (int i = 0; i < 1000; i++)
                await bus.SendAsync(recipientId, new RefineBoo() { Name = $"Name_{i}" });

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed / 101);

            await Task.Delay(3000);

        }

        [Fact]
        public async Task HandleStrCommandHandle()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<StrCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10)))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            await bus.SendAsync("Fun", new CreateStrFoo() { Name = "Cool" });

            var state = await srv.GetRequiredService<IPlumber>().GetState<StrEntityState>("Fun");
            state.Should().NotBeNull();
        }
        [Fact]
        public async Task HandleCommandsScoped()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings(), scopedCommandBus:true)
                .AddCommandHandler<FooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();

            var fooModel = new FooModel(new InMemoryAssertionDb());
            var sub = await srv.GetRequiredService<IPlumber>().SubscribeEventHandler(fooModel);

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(5), scopedCommandBus:true))
                .StartAsync();

            using var scope = client.CreateScope();
            var bus = scope.ServiceProvider.GetRequiredService<ICommandBus>();

            Stopwatch sw = new Stopwatch();
            sw.Start();
            await Parallel.ForAsync(0, 100, new ParallelOptions() { MaxDegreeOfParallelism = 10 },
                async (i, ct) => await bus.QueueAsync(Guid.NewGuid(), new CreateFoo() { Name = $"Name_{i}", TimeoutMs = 100 }, token: ct, fireAndForget: false));

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed / 100);

            await Eventually(() => fooModel.AssertionDb.Index.Should().HaveCount(100));

        }
        [Fact]
        public async Task HandleCommandsParallel()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<FooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();

            var fooModel = new FooModel(new InMemoryAssertionDb());
            var sub = await srv.GetRequiredService<IPlumber>().SubscribeEventHandler(fooModel);

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(5)))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            Stopwatch sw = new Stopwatch();
            sw.Start();
            await Parallel.ForAsync(0, 100, new ParallelOptions() { MaxDegreeOfParallelism = 10 },
                 async (i, ct) => await bus.QueueAsync(Guid.NewGuid(), new CreateFoo() { Name = $"Name_{i}", TimeoutMs = 100 }, token: ct, fireAndForget:false));

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed / 100);

            await Eventually(() => fooModel.AssertionDb.Index.Should().HaveCount(100));

        }
        [Fact]
        public async Task HandleCommands()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<FooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();
            
            var fooModel = new FooModel(new InMemoryAssertionDb());
            var sub = await srv.GetRequiredService<IPlumber>().SubscribeEventHandler(fooModel);

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(5)))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            Stopwatch sw = new Stopwatch();
            sw.Start();
            for (int i = 0; i < 100; i++) 
                 await bus.SendAsync(Guid.NewGuid(), new CreateFoo() { Name = $"Name_{i}", TimeoutMs = 100 });

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed/100);

            await Eventually(() => fooModel.AssertionDb.Index.Should().HaveCount(100));

        }
        [Fact]
        public async Task HandleCommand()
        {
            
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<FooCommandHandler>(start: StreamPosition.Start));

            var srv = await _serverTestApp.StartAsync();
            
            var cmd = new CreateFoo() { Name = "Hello" };
            var recipientId = Guid.NewGuid();

            Stopwatch sw = new Stopwatch();
            sw.Start();

            var client = await _clientTestApp.Configure( x=>x
                .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10)))
                .StartAsync();

            await client.GetRequiredService<ICommandBus>().SendAsync(recipientId, cmd);

            _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed);
            

            var fooModel = new FooModel(new InMemoryAssertionDb());
            var sub = await srv.GetRequiredService<IPlumber>().SubscribeEventHandler(fooModel);
            await Eventually(() =>
            {

                fooModel.AssertionDb.Index.Should().HaveCount(1);
                fooModel.AssertionDb.Index[0].Metadata.CausationId().Should().Be(cmd.Id);
                fooModel.AssertionDb.Index[0].Metadata.CorrelationId().Should().Be(cmd.Id);
                fooModel.AssertionDb.Index[0].Metadata.SourceStreamId.Should().Be($"FooAggregate-{recipientId}");
            });
        }

        [Fact]
        public async Task HandleCommandException()
        {
            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings())
                .AddCommandHandler<FooCommandHandler>(start: StreamPosition.Start));
            

            var sp = await _serverTestApp.StartAsync();
            
            var cmd = new CreateFoo() { Name = "error" };
            
            Func<Task> action = async () => await sp.GetRequiredService<ICommandBus>().SendAsync(Guid.NewGuid(), cmd);

            await action.Should().ThrowAsync<FaultException<BusinessFault>>();
        }


        public async Task InitializeAsync()
        {
            await _eventStore.StartInDocker();
        }

        public async Task DisposeAsync()
        {
            await _eventStore.DisposeAsync();
        }
    }
}



// --- File: MicroPlumberd.Tests\Integration\Services\ProcessManagerTests.cs ---


using MicroPlumberd.Services;

using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using System.Diagnostics;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Srv;
using ModelingEvolution.DirectConnect;
using Xunit.Sdk;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Integration.Services;

[TestCategory("Integration")]
public class ProcessManagerTests : IClassFixture<EventStoreServer>
{
    private readonly EventStoreServer _eventStore;
    private readonly TestAppHost _serverTestApp;
    private readonly TestAppHost _clientTestApp;
    public ProcessManagerTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
    {
        _eventStore = eventStore;
        _serverTestApp = new TestAppHost(testOutputHelper);
        _clientTestApp = new TestAppHost(testOutputHelper);
    }

    [Fact]
    public async Task TestProcessorFlow()
    {
        await _eventStore.StartInDocker();

        await _serverTestApp.Configure(x => x
            .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(100))
            .AddCommandHandler<FooCommandHandler>()
            .AddCommandHandler<BooCommandHandler>()
            .AddProcessManager<XooProcessManager>())
            .StartAsync();

        await Task.Delay(2000);

        
        var client = await _clientTestApp.Configure(x=> x
            .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(100)))
            .StartAsync();
        var clientBus = client.GetRequiredService<ICommandBus>();

        Stopwatch sw = new Stopwatch();
        sw.Start();
        await clientBus.SendAsync(Guid.NewGuid(), new CreateFoo() { Name = "Hello" });
        sw.Stop();

        
        await Task.Delay(2000);
        await clientBus.SendAsync("Hello".ToGuid(), new RefineBoo() { Name="Okidoki"} );

        await Task.Delay(2000);
    }
}


// --- File: MicroPlumberd.Tests\Integration\Services\SecretTests.cs ---


using System.Diagnostics;
using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.Encryption;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;
using MicroPlumberd.Tests.App.Srv;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Integration.Services;

[TestCategory("Integration")]
public class SecretTests : IClassFixture<EventStoreServer>
{
    private readonly EventStoreServer _eventStore;
    private readonly ITestOutputHelper _testOutputHelper;
    private readonly TestAppHost _serverTestApp;
    private readonly TestAppHost _clientTestApp;

    public SecretTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
    {
        _eventStore = eventStore;
        _testOutputHelper = testOutputHelper;
        _serverTestApp = new TestAppHost(testOutputHelper);
        _clientTestApp = new TestAppHost(testOutputHelper);
    }
    [Fact]
    public async Task HandleCommand()
    {
        await _eventStore.StartInDocker();

        _serverTestApp.Configure(x => x
            .AddEncryption()
            .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp,x) => x.EnableEncryption())
            .AddCommandHandler<SecretCommandHandler>(start: StreamPosition.Start));

        var srv = await _serverTestApp.StartAsync();

        var cmd = new CreateSecret() { Password = "Very secret password" };
        var recipientId = Guid.NewGuid();

        Stopwatch sw = new Stopwatch();
        sw.Start();

        var client = await _clientTestApp.Configure(x => x
                .AddEncryption()
                .AddPlumberd(_eventStore.GetEventStoreSettings(), (sp, x) =>
                    x
                        .EnableEncryption()
                        .ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(10)))
            .StartAsync();

        await client.GetRequiredService<ICommandBus>().SendAsync(recipientId, cmd);

        _testOutputHelper.WriteLine("Command executed in: " + sw.Elapsed);
        var result = await srv.GetRequiredService<IPlumber>().ReadEventsOfType<SecretCreated>().FirstOrDefaultAsync();

        string pwd = result.Item1.Password;
        pwd.Should().Be("Very secret password");

    }
}


// --- File: MicroPlumberd.Tests\Integration\Services\WorkflowTests.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.WorkflowDomain;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Integration.Services
{
    [TestCategory("Integration")]
    public class WorkflowTests : IClassFixture<EventStoreServer>
    {
        private readonly EventStoreServer _eventStore;
        private readonly ITestOutputHelper _testOutputHelper;
        private readonly TestAppHost _serverTestApp;
        private readonly TestAppHost _clientTestApp;


        public WorkflowTests(EventStoreServer eventStore, ITestOutputHelper testOutputHelper)
        {
            _eventStore = eventStore;
            _testOutputHelper = testOutputHelper;
            _serverTestApp = new TestAppHost(testOutputHelper);
            _clientTestApp = new TestAppHost(testOutputHelper);
        }
        
        [Fact]
        public async Task NestedCommandInvocationShouldComplete()
        {
            await _eventStore.StartInDocker();

            _serverTestApp.Configure(x => x
                .AddPlumberd(_eventStore.GetEventStoreSettings(),scopedCommandBus:true)
                .AddCommandHandler<StartWorkflowHandler>()
                .AddCommandHandler<CompleteWorkflowHandler>());

            var srv = await _serverTestApp.StartAsync();

            var client = await _clientTestApp.Configure(x => x
                    .AddPlumberd(_eventStore.GetEventStoreSettings(),
                        (sp, x) => x.ServicesConfig().DefaultTimeout = TimeSpan.FromSeconds(90)))
                .StartAsync();

            var bus = client.GetRequiredService<ICommandBus>();

            var recipientId = Guid.NewGuid();
            var startWorkflow = new StartWorkflow { Name = "Test" };
            var correlationId = startWorkflow.Id;
            
            await bus.SendAsync(recipientId, startWorkflow);
            await Task.Delay(1000);
            var pl = srv.GetRequiredService<IPlumber>();
            var model = await pl.CorrelationModel()
                .WithCommandHandler<StartWorkflowHandler>()
                .WithCommandHandler<CompleteWorkflowHandler>()
                .WithEvent<WorkflowCompleted>()
                .Read(correlationId);
        }
    }
}



// --- File: MicroPlumberd.Tests\Integration\Specflow\Aggregate.feature.cs ---


// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by SpecFlow (https://www.specflow.org/).
//      SpecFlow Version:3.9.0.0
//      SpecFlow Generator Version:3.9.0.0
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
namespace MicroPlumberd.Tests.Integration.Specflow
{
    using TechTalk.SpecFlow;
    using System;
    using System.Linq;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [Xunit.TraitAttribute("Category", "Aggregate")]
    public partial class FooAggregateFlowFeature : object, Xunit.IClassFixture<FooAggregateFlowFeature.FixtureData>, System.IDisposable
    {
        
        private static TechTalk.SpecFlow.ITestRunner testRunner;
        
        private static string[] featureTags = new string[] {
                "Aggregate"};
        
        private Xunit.Abstractions.ITestOutputHelper _testOutputHelper;
        
#line 1 "Aggregate.feature"
#line hidden
        
        public FooAggregateFlowFeature(FooAggregateFlowFeature.FixtureData fixtureData, MicroPlumberd_Tests_XUnitAssemblyFixture assemblyFixture, Xunit.Abstractions.ITestOutputHelper testOutputHelper)
        {
            this._testOutputHelper = testOutputHelper;
            this.TestInitialize();
        }
        
        public static void FeatureSetup()
        {
            testRunner = TechTalk.SpecFlow.TestRunnerManager.GetTestRunner();
            TechTalk.SpecFlow.FeatureInfo featureInfo = new TechTalk.SpecFlow.FeatureInfo(new System.Globalization.CultureInfo("en-US"), "Integration/Specflow", "Foo aggregate flow", null, ProgrammingLanguage.CSharp, featureTags);
            testRunner.OnFeatureStart(featureInfo);
        }
        
        public static void FeatureTearDown()
        {
            testRunner.OnFeatureEnd();
            testRunner = null;
        }
        
        public void TestInitialize()
        {
        }
        
        public void TestTearDown()
        {
            testRunner.OnScenarioEnd();
        }
        
        public void ScenarioInitialize(TechTalk.SpecFlow.ScenarioInfo scenarioInfo)
        {
            testRunner.OnScenarioInitialize(scenarioInfo);
            testRunner.ScenarioContext.ScenarioContainer.RegisterInstanceAs<Xunit.Abstractions.ITestOutputHelper>(_testOutputHelper);
        }
        
        public void ScenarioStart()
        {
            testRunner.OnScenarioStart();
        }
        
        public void ScenarioCleanup()
        {
            testRunner.CollectScenarioErrors();
        }
        
        public virtual void FeatureBackground()
        {
#line 4
#line hidden
#line 5
    testRunner.Given("the Foo App is up and running", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Given ");
#line hidden
        }
        
        void System.IDisposable.Dispose()
        {
            this.TestTearDown();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Creating and changing Foo should be successful")]
        [Xunit.TraitAttribute("FeatureTitle", "Foo aggregate flow")]
        [Xunit.TraitAttribute("Description", "Creating and changing Foo should be successful")]
        public void CreatingAndChangingFooShouldBeSuccessful()
        {
            string[] tagsOfScenario = ((string[])(null));
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Creating and changing Foo should be successful", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 7
this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((TagHelper.ContainsIgnoreTag(tagsOfScenario) || TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 4
this.FeatureBackground();
#line hidden
#line 9
    testRunner.Given("Foo created", "Name: \"Ok\"", ((TechTalk.SpecFlow.Table)(null)), "Given ");
#line hidden
                TechTalk.SpecFlow.Table table1 = new TechTalk.SpecFlow.Table(new string[] {
                            "Property",
                            "Value"});
                table1.AddRow(new string[] {
                            "Name",
                            "Ok"});
#line 14
    testRunner.And("Foo was refined:", ((string)(null)), table1, "And ");
#line hidden
#line 18
    testRunner.When("I change Foo with msg: \'Blabla\'", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
                TechTalk.SpecFlow.Table table2 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table2.AddRow(new string[] {
                            "Blabla"});
#line 19
    testRunner.Then("I expect, that Foo was refined with:", ((string)(null)), table2, "Then ");
#line hidden
            }
            this.ScenarioCleanup();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Changing Foo with an error")]
        [Xunit.TraitAttribute("FeatureTitle", "Foo aggregate flow")]
        [Xunit.TraitAttribute("Description", "Changing Foo with an error")]
        public void ChangingFooWithAnError()
        {
            string[] tagsOfScenario = ((string[])(null));
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Changing Foo with an error", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 23
this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((TagHelper.ContainsIgnoreTag(tagsOfScenario) || TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 4
this.FeatureBackground();
#line hidden
                TechTalk.SpecFlow.Table table3 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table3.AddRow(new string[] {
                            "Foo"});
#line 25
    testRunner.Given("Foo was created", ((string)(null)), table3, "Given ");
#line hidden
#line 29
    testRunner.When("I change Foo with msg: \'error\'", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
                TechTalk.SpecFlow.Table table4 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table4.AddRow(new string[] {
                            "Houston we have a problem!"});
#line 30
    testRunner.Then("I expect business fault exception:", ((string)(null)), table4, "Then ");
#line hidden
            }
            this.ScenarioCleanup();
        }
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        public class FixtureData : System.IDisposable
        {
            
            public FixtureData()
            {
                FooAggregateFlowFeature.FeatureSetup();
            }
            
            void System.IDisposable.Dispose()
            {
                FooAggregateFlowFeature.FeatureTearDown();
            }
        }
    }
}
#pragma warning restore
#endregion



// --- File: MicroPlumberd.Tests\Integration\Specflow\CommandHandler.feature.cs ---


// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by SpecFlow (https://www.specflow.org/).
//      SpecFlow Version:3.9.0.0
//      SpecFlow Generator Version:3.9.0.0
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
namespace MicroPlumberd.Tests.Integration.Specflow
{
    using TechTalk.SpecFlow;
    using System;
    using System.Linq;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public partial class CommandHandlerFeature : object, Xunit.IClassFixture<CommandHandlerFeature.FixtureData>, System.IDisposable
    {
        
        private static TechTalk.SpecFlow.ITestRunner testRunner;
        
        private static string[] featureTags = ((string[])(null));
        
        private Xunit.Abstractions.ITestOutputHelper _testOutputHelper;
        
#line 1 "CommandHandler.feature"
#line hidden
        
        public CommandHandlerFeature(CommandHandlerFeature.FixtureData fixtureData, MicroPlumberd_Tests_XUnitAssemblyFixture assemblyFixture, Xunit.Abstractions.ITestOutputHelper testOutputHelper)
        {
            this._testOutputHelper = testOutputHelper;
            this.TestInitialize();
        }
        
        public static void FeatureSetup()
        {
            testRunner = TechTalk.SpecFlow.TestRunnerManager.GetTestRunner();
            TechTalk.SpecFlow.FeatureInfo featureInfo = new TechTalk.SpecFlow.FeatureInfo(new System.Globalization.CultureInfo("en-US"), "Integration/Specflow", "CommandHandler", "\tSimple command handler that uses a Foo aggregate and Command Bus.", ProgrammingLanguage.CSharp, featureTags);
            testRunner.OnFeatureStart(featureInfo);
        }
        
        public static void FeatureTearDown()
        {
            testRunner.OnFeatureEnd();
            testRunner = null;
        }
        
        public void TestInitialize()
        {
        }
        
        public void TestTearDown()
        {
            testRunner.OnScenarioEnd();
        }
        
        public void ScenarioInitialize(TechTalk.SpecFlow.ScenarioInfo scenarioInfo)
        {
            testRunner.OnScenarioInitialize(scenarioInfo);
            testRunner.ScenarioContext.ScenarioContainer.RegisterInstanceAs<Xunit.Abstractions.ITestOutputHelper>(_testOutputHelper);
        }
        
        public void ScenarioStart()
        {
            testRunner.OnScenarioStart();
        }
        
        public void ScenarioCleanup()
        {
            testRunner.CollectScenarioErrors();
        }
        
        public virtual void FeatureBackground()
        {
#line 4
#line hidden
#line 5
 testRunner.Given("the Foo App is up and running", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Given ");
#line hidden
        }
        
        void System.IDisposable.Dispose()
        {
            this.TestTearDown();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Invoking one command")]
        [Xunit.TraitAttribute("FeatureTitle", "CommandHandler")]
        [Xunit.TraitAttribute("Description", "Invoking one command")]
        public void InvokingOneCommand()
        {
            string[] tagsOfScenario = ((string[])(null));
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Invoking one command", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 7
this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((TagHelper.ContainsIgnoreTag(tagsOfScenario) || TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 4
this.FeatureBackground();
#line hidden
                TechTalk.SpecFlow.Table table5 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table5.AddRow(new string[] {
                            "Foo"});
#line 8
 testRunner.Given("Foo \'Orange\' was created", ((string)(null)), table5, "Given ");
#line hidden
                TechTalk.SpecFlow.Table table6 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table6.AddRow(new string[] {
                            "Blabla"});
#line 11
    testRunner.When("I change foo \'Orange\' with:", ((string)(null)), table6, "When ");
#line hidden
                TechTalk.SpecFlow.Table table7 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table7.AddRow(new string[] {
                            "Blabla"});
#line 14
 testRunner.Then("I expect, that Foo was refined with:", ((string)(null)), table7, "Then ");
#line hidden
                TechTalk.SpecFlow.Table table8 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table8.AddRow(new string[] {
                            "Blabla"});
#line 17
    testRunner.And("I expect, that Foo\'s state is set with:", ((string)(null)), table8, "And ");
#line hidden
            }
            this.ScenarioCleanup();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Invoking one command to raise exception")]
        [Xunit.TraitAttribute("FeatureTitle", "CommandHandler")]
        [Xunit.TraitAttribute("Description", "Invoking one command to raise exception")]
        public void InvokingOneCommandToRaiseException()
        {
            string[] tagsOfScenario = ((string[])(null));
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Invoking one command to raise exception", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 21
this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((TagHelper.ContainsIgnoreTag(tagsOfScenario) || TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 4
this.FeatureBackground();
#line hidden
                TechTalk.SpecFlow.Table table9 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table9.AddRow(new string[] {
                            "Foo"});
#line 22
 testRunner.Given("Foo was created", ((string)(null)), table9, "Given ");
#line hidden
                TechTalk.SpecFlow.Table table10 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table10.AddRow(new string[] {
                            "error"});
#line 25
 testRunner.When("I change foo with:", ((string)(null)), table10, "When ");
#line hidden
                TechTalk.SpecFlow.Table table11 = new TechTalk.SpecFlow.Table(new string[] {
                            "Name"});
                table11.AddRow(new string[] {
                            "Houston we have a problem!"});
#line 28
 testRunner.Then("I expect business fault exception:", ((string)(null)), table11, "Then ");
#line hidden
            }
            this.ScenarioCleanup();
        }
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        public class FixtureData : System.IDisposable
        {
            
            public FixtureData()
            {
                CommandHandlerFeature.FeatureSetup();
            }
            
            void System.IDisposable.Dispose()
            {
                CommandHandlerFeature.FeatureTearDown();
            }
        }
    }
}
#pragma warning restore
#endregion



// --- File: MicroPlumberd.Tests\Integration\Specflow\ReadModel.feature.cs ---


// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by SpecFlow (https://www.specflow.org/).
//      SpecFlow Version:3.9.0.0
//      SpecFlow Generator Version:3.9.0.0
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
namespace MicroPlumberd.Tests.Integration.Specflow
{
    using TechTalk.SpecFlow;
    using System;
    using System.Linq;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public partial class ReadModelFeature : object, Xunit.IClassFixture<ReadModelFeature.FixtureData>, System.IDisposable
    {
        
        private static TechTalk.SpecFlow.ITestRunner testRunner;
        
        private static string[] featureTags = ((string[])(null));
        
        private Xunit.Abstractions.ITestOutputHelper _testOutputHelper;
        
#line 1 "ReadModel.feature"
#line hidden
        
        public ReadModelFeature(ReadModelFeature.FixtureData fixtureData, MicroPlumberd_Tests_XUnitAssemblyFixture assemblyFixture, Xunit.Abstractions.ITestOutputHelper testOutputHelper)
        {
            this._testOutputHelper = testOutputHelper;
            this.TestInitialize();
        }
        
        public static void FeatureSetup()
        {
            testRunner = TechTalk.SpecFlow.TestRunnerManager.GetTestRunner();
            TechTalk.SpecFlow.FeatureInfo featureInfo = new TechTalk.SpecFlow.FeatureInfo(new System.Globalization.CultureInfo("en-US"), "Integration/Specflow", "ReadModel", "\tSimple model to query some data", ProgrammingLanguage.CSharp, featureTags);
            testRunner.OnFeatureStart(featureInfo);
        }
        
        public static void FeatureTearDown()
        {
            testRunner.OnFeatureEnd();
            testRunner = null;
        }
        
        public void TestInitialize()
        {
        }
        
        public void TestTearDown()
        {
            testRunner.OnScenarioEnd();
        }
        
        public void ScenarioInitialize(TechTalk.SpecFlow.ScenarioInfo scenarioInfo)
        {
            testRunner.OnScenarioInitialize(scenarioInfo);
            testRunner.ScenarioContext.ScenarioContainer.RegisterInstanceAs<Xunit.Abstractions.ITestOutputHelper>(_testOutputHelper);
        }
        
        public void ScenarioStart()
        {
            testRunner.OnScenarioStart();
        }
        
        public void ScenarioCleanup()
        {
            testRunner.CollectScenarioErrors();
        }
        
        public virtual void FeatureBackground()
        {
#line 4
#line hidden
#line 5
 testRunner.Given("the Foo App is up and running", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Given ");
#line hidden
        }
        
        void System.IDisposable.Dispose()
        {
            this.TestTearDown();
        }
        
        [Xunit.SkippableFactAttribute(DisplayName="Foo model")]
        [Xunit.TraitAttribute("FeatureTitle", "ReadModel")]
        [Xunit.TraitAttribute("Description", "Foo model")]
        public void FooModel()
        {
            string[] tagsOfScenario = ((string[])(null));
            System.Collections.Specialized.OrderedDictionary argumentsOfScenario = new System.Collections.Specialized.OrderedDictionary();
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Foo model", null, tagsOfScenario, argumentsOfScenario, featureTags);
#line 7
this.ScenarioInitialize(scenarioInfo);
#line hidden
            if ((TagHelper.ContainsIgnoreTag(tagsOfScenario) || TagHelper.ContainsIgnoreTag(featureTags)))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 4
this.FeatureBackground();
#line hidden
                TechTalk.SpecFlow.Table table12 = new TechTalk.SpecFlow.Table(new string[] {
                            "Id",
                            "Name"});
                table12.AddRow(new string[] {
                            "1",
                            "Ok"});
                table12.AddRow(new string[] {
                            "2",
                            "Oki"});
#line 8
 testRunner.Given("Some foos were created:", ((string)(null)), table12, "Given ");
#line hidden
#line 12
    testRunner.When("I find by id \'1\'", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
#line 13
    testRunner.Then("I get \'Ok\'", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
#line hidden
            }
            this.ScenarioCleanup();
        }
        
        [System.CodeDom.Compiler.GeneratedCodeAttribute("TechTalk.SpecFlow", "3.9.0.0")]
        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        public class FixtureData : System.IDisposable
        {
            
            public FixtureData()
            {
                ReadModelFeature.FeatureSetup();
            }
            
            void System.IDisposable.Dispose()
            {
                ReadModelFeature.FeatureTearDown();
            }
        }
    }
}
#pragma warning restore
#endregion



// --- File: MicroPlumberd.Tests\Integration\AggregateTests.cs ---


using System.Reflection;
using FluentAssertions;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;

using MicroPlumberd.Tests.Utils;

using TechTalk.SpecFlow.UnitTestProvider;

namespace MicroPlumberd.Tests.Integration
{
    [TestCategory("Unit")]
    public class AggregateReflection
    {
        [Fact]
        public void GivenMethodsAreAccessible()
        {
            var mth = typeof(FooAggregate).GetMethods(BindingFlags.NonPublic | BindingFlags.InvokeMethod | BindingFlags.Instance)
                .Where(x=>x.Name == "Given").FirstOrDefault();

            var acceptedTypeAttributes = mth.GetCustomAttributes<AcceptedTypeAttribute>().ToArray();
            acceptedTypeAttributes.Should().HaveCountGreaterThan(1);
        }
    }
   

    [TestCategory("Integration")]
    public class AggregateTests : IClassFixture<EventStoreServer>
    {
        private readonly IPlumber plumber;
        private readonly EventStoreServer es;


        public AggregateTests(EventStoreServer es)
        {
            plumber = Plumber.Create(es.GetEventStoreSettings());
            this.es = es;
        }

        [Fact]
        public async Task New()
        {
            await es.StartInDocker();
            using var scope = new InvocationScope();
            scope.SetCausation(Guid.NewGuid()).SetCorrelation(Guid.NewGuid()).SetUserId(Guid.NewGuid());

            FooAggregate aggregate = FooAggregate.Open("Hello");

            await plumber.SaveNew(aggregate);
        }
        [Fact]
        public async Task Get()
        {
            await es.StartInDocker();
            FooAggregate aggregate = FooAggregate.Open("Hello");

            await plumber.SaveNew(aggregate);

            var aggregate2 = await plumber.Get<FooAggregate>(aggregate.Id);

            aggregate2.Version.Should().Be(0);
            aggregate2.State.Name.Should().Be("Hello");
        }
        [Fact]
        public async Task Update()
        {
            await es.StartInDocker();
            FooAggregate aggregate = FooAggregate.Open("Hello");
            await plumber.SaveNew(aggregate);

            aggregate.Refine("World");

            await plumber.SaveChanges(aggregate);
        }

    }

}


// --- File: MicroPlumberd.Tests\Integration\ModelSetsTests.cs ---


using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;

using MicroPlumberd.Tests.Utils;

namespace MicroPlumberd.Tests.Integration;

[TestCategory("Integration")]
public class ModelSetsTests : IClassFixture<EventStoreServer>
{
    private readonly EventStoreServer _eventStore;

    private readonly IPlumber plumber;

    public ModelSetsTests(EventStoreServer eventStore)
    {
        _eventStore = eventStore;
        plumber = new Plumber(_eventStore.GetEventStoreSettings());
    }


    [Fact]
    public async Task SubscribeModels()
    {
        await _eventStore.StartInDocker();
        var fk = Guid.NewGuid();
        await plumber.AppendEvents($"Dim-{fk}", StreamState.NoStream, new DimentionCreated() { Name = "Dependency" });
        await plumber.AppendEvents($"Fact-{Guid.NewGuid()}", StreamState.NoStream, new MasterRecordCreated() { Name = "Master", DependencyId = fk });

        var dimentionTable = new DimentionLookupModel();
        var factTable = new MasterModel(dimentionTable);


        await plumber.SubscribeSet()
            .With(dimentionTable)
            .With(factTable)
            .SubscribeAsync("MasterStream", FromStream.Start);

        await Task.Delay(1000);

        factTable.Index.Should().HaveCount(1);
        dimentionTable.Index.Should().HaveCount(1);
        factTable.Index.First().Value.DependencyName.Should().Be("Dependency");
    }

}



// --- File: MicroPlumberd.Tests\Integration\ReadModelTests.cs ---


using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;

namespace MicroPlumberd.Tests.Integration;

[TestCategory("Integration")]
public class ReadModelTests : IClassFixture<EventStoreServer>
{
    private readonly EventStoreServer _eventStore;

    private IPlumber plumber;

    public ReadModelTests(EventStoreServer eventStore)
    {
        _eventStore = eventStore;
        plumber = new Plumber(_eventStore.GetEventStoreSettings());
    }

    [Fact]
    public async Task SubscribeModelPersistently()
    {
        await _eventStore.StartInDocker();
        await AppendOneEvent();

        var fooModel = new FooModel(new InMemoryAssertionDb());

        var sub = await plumber.SubscribeEventHandlerPersistently(fooModel, startFrom: StreamPosition.Start);

        await Task.Delay(1000);

        fooModel.AssertionDb.Index.Should().HaveCount(1);
    }
    [Fact]
    public async Task SubscribeModelFromEnd()
    {
        await _eventStore.StartInDocker();
        await AppendOneEvent();
        await AppendOneEvent();
        await Task.Delay(100);

        var fooModel = new FooModel(new InMemoryAssertionDb());
        var sub = await plumber.SubscribeEventHandler(fooModel, start: FromRelativeStreamPosition.End-1);

        await Task.Delay(1000);

        fooModel.AssertionDb.Index.Should().HaveCount(1);

        await AppendOneEvent();
        await Task.Delay(200);
        fooModel.AssertionDb.Index.Should().HaveCount(2);
    }
    [Fact]
    public async Task SubscribeModel()
    {
        await _eventStore.StartInDocker();
        await AppendOneEvent();

        var fooModel = new FooModel(new InMemoryAssertionDb());

        var sub = await plumber.SubscribeEventHandler(fooModel);

        await Task.Delay(1000);

        fooModel.AssertionDb.Index.Should().HaveCount(1);
    }
    [Fact]
    public async Task SubscribeModelWithEventStoreRestart()
    {
        await _eventStore.StartInDocker(inMemory:false);
        await AppendOneEvent();

        var fooModel = new FooModel(new InMemoryAssertionDb());

        var sub = await plumber.SubscribeEventHandler(fooModel);

        await Task.Delay(1000);

        fooModel.AssertionDb.Index.Should().HaveCount(1);

        await _eventStore.Restart(TimeSpan.FromSeconds(5));
        await AppendOneEvent();
        await Task.Delay(1000);
        fooModel.AssertionDb.Index.Should().HaveCount(2);

    }
    [Fact]
    public async Task SubscribeScopedModel()
    {
        // TODO: Switch to EF to check
        await _eventStore.StartInDocker();
        await AppendOneEvent();

        var sp = new ServiceCollection()
            .AddPlumberd(_eventStore.GetEventStoreSettings())
            .AddEventHandler<FooModel>()
            .BuildServiceProvider();

        plumber = sp.GetRequiredService<IPlumber>();

        var sub = await plumber.SubscribeEventHandler<FooModel>();

        await Task.Delay(1000);
        // Should check db.
    }

    private async Task AppendOneEvent()
    {
        FooAggregate aggregate = FooAggregate.Open("Hello");
        await plumber.SaveNew(aggregate);
    }
}


// --- File: MicroPlumberd.Tests\Integration\StateTests.cs ---


using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.Utils;

namespace MicroPlumberd.Tests.Integration;

[TestCategory("Integration")]
public class SubscriptionRunnerStateTests : IClassFixture<EventStoreServer>
{
    private readonly IPlumber plumber;
    private readonly EventStoreServer es;

    public SubscriptionRunnerStateTests(EventStoreServer es)
    {
        plumber = Plumber.Create(es.GetEventStoreSettings());
        this.es = es;
    }

    [Fact]
    public async Task ThrowsWrongExpectedVersionExceptionWhenStreamAlreadyExists()
    {
        await es.StartInDocker();

        var st = new FooEntityState() { Name = "Foo" };
        await plumber.AppendState(st);

        var st2 = new FooEntityState() { Id = st.Id, Name = "Whatever" };

        var mth = async () => await plumber.AppendState(st2);

        await mth.Should().ThrowAsync<WrongExpectedVersionException>();
    }
    [Fact]
    public async Task ThrowsWrongExpectedVersionExceptionWhenOnDoubleChange()
    {
        await es.StartInDocker();

        var root = new FooEntityState() { Name = "Foo" };
        await plumber.AppendState(root);

        FooEntityState second = await plumber.GetState<FooEntityState>(root.Id);
        
        root.Name = "Bar";
        await plumber.AppendState(root);

        var mth = async () => await plumber.AppendState(second);

        await mth.Should().ThrowAsync<WrongExpectedVersionException>();
    }

    [Fact]
    public async Task TripleWrite()
    {
        await es.StartInDocker();

        var st = new FooEntityState() { Name = "Foo"};
        await plumber.AppendState(st);

        st.Name = "Bar";
        await plumber.AppendState(st);

        st.Name = "Xoo";
        await plumber.AppendState(st);

        FooEntityState actual = await plumber.GetState<FooEntityState>(st.Id);

        actual.Should().Be(st);
    }
    [Fact]
    public async Task WriteAfterGet()
    {
        await es.StartInDocker();

        var st = new FooEntityState() { Name = "Foo" };
        await plumber.AppendState(st);
            
        FooEntityState nx = await plumber.GetState<FooEntityState>(st.Id);
        nx.Name = "Bar";
        await plumber.AppendState(nx);

        FooEntityState actual = await plumber.GetState<FooEntityState>(st.Id);
        actual.Should().Be(nx);

    }
}


// --- File: MicroPlumberd.Tests\Unit\ApiTypeRegisterTests.cs ---


using FluentAssertions;
using MicroPlumberd.DirectConnect;
using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Srv;
using MicroPlumberd.Tests.Integration.Services.Grpc.DirectConnect.Fixtures;
using MicroPlumberd.Tests.Utils;
using Microsoft.Extensions.DependencyInjection;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.Tests.Unit;

[TestCategory("Unit")]
public class ApiTypeRegisterTests
{
    [Fact]
    public void ServerMessagesCount()
    {
        var actual = Messages<FooCommandHandler>().ToArray();
        actual.Should().BeEquivalentTo(new[] { typeof(HandlerOperationStatus), typeof(CreateFoo), typeof(RefineFoo), typeof(BusinessFault) });
    }

    [Fact]
    public async Task ClientMessagesCount()
    {
        await using var client = new ClientApp();

        var sp = client.Start(service => service.AddClientDirectConnect()
            .AddCommandInvokers(typeof(CreateFoo), typeof(RefineFoo)));

        var t = sp.GetRequiredService<TypeRegister>();

        t[typeof(CommandEnvelope<CreateFoo>).FullName!.ToGuid()].Should().NotBeNull();
        t[typeof(CommandEnvelope<RefineFoo>).FullName!.ToGuid()].Should().NotBeNull();
        //t[typeof(BusinessFault).FullName!.ToGuid()].Should().NotBeNull();
        t[typeof(HandlerOperationStatus).FullName!.ToGuid()].Should().NotBeNull();
    }

    private IEnumerable<Type> Messages<T>() where T : IServiceTypeRegister
    {
        return T.FaultTypes.Union(T.CommandTypes).Union(T.ReturnTypes).Distinct();
    }
}


// --- File: MicroPlumberd.Tests\Unit\AsyncLazy2.cs ---


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace MicroPlumberd.Tests.Unit
{
    

    
        public class AsyncLazyTests2
        {
            [Fact]
            public void Constructor_NullFactory_ThrowsArgumentNullException()
            {
                Assert.Throws<ArgumentNullException>(() => new AsyncLazy<int>(null));
            }

            [Fact]
            public async Task Value_NotInitialized_ReturnsFalse()
            {
                var lazy = new AsyncLazy<int>(() => Task.FromResult(42));
                Assert.False(lazy.IsValueCreated);
            }

            [Fact]
            public async Task Value_AfterInitialization_ReturnsTrue()
            {
                var lazy = new AsyncLazy<int>(() => Task.FromResult(42));
                await lazy.Value;
                Assert.True(lazy.IsValueCreated);
            }

            [Fact]
            public async Task Value_SingleThread_InitializesOnce()
            {
                var initCount = 0;
                var lazy = new AsyncLazy<int>(async () =>
                {
                    Interlocked.Increment(ref initCount);
                    await Task.Delay(10);
                    return 42;
                });

                var value1 = await lazy.Value;
                var value2 = await lazy.Value;
                var value3 = await lazy.Value;

                Assert.Equal(42, value1);
                Assert.Equal(42, value2);
                Assert.Equal(42, value3);
                Assert.Equal(1, initCount);
            }

            [Fact]
            public async Task Value_MultipleThreads_InitializesOnce()
            {
                var initCount = 0;
                var lazy = new AsyncLazy<int>(async () =>
                {
                    Interlocked.Increment(ref initCount);
                    await Task.Delay(100); // Long enough to ensure concurrent access
                    return 42;
                });

                var tasks = new List<Task<int>>();
                for (int i = 0; i < 10; i++)
                {
                    tasks.Add(Task.Run(async () => await lazy.Value));
                }

                await Task.WhenAll(tasks);

                foreach (var task in tasks)
                {
                    Assert.Equal(42, await task);
                }
                Assert.Equal(1, initCount);
            }

            [Fact]
            public async Task Value_FactoryThrows_PropagatesException()
            {
                var exception = new InvalidOperationException("Test exception");
                var lazy = new AsyncLazy<int>(() => Task.FromException<int>(exception));

                var ex = await Assert.ThrowsAsync<InvalidOperationException>(() => lazy.Value.AsTask());
                Assert.Same(exception, ex);
            }

            [Fact]
            public async Task Value_FactoryThrows_PropagatesSameExceptionToAllWaiters()
            {
                var exception = new InvalidOperationException("Test exception");
                var lazy = new AsyncLazy<int>(async () =>
                {
                    await Task.Delay(10);
                    throw exception;
                });

                var tasks = new List<Task>();
                for (int i = 0; i < 5; i++)
                {
                    tasks.Add(Task.Run(async () =>
                    {
                        var ex = await Assert.ThrowsAsync<InvalidOperationException>(() => lazy.Value.AsTask());
                        Assert.Same(exception, ex);
                    }));
                }

                await Task.WhenAll(tasks);
            }

            [Fact]
            public async Task Value_AfterInitialization_ReturnsImmediately()
            {
                var lazy = new AsyncLazy<int>(async () =>
                {
                    await Task.Delay(1100);
                    return 42;
                });

                // First access - should take time
                var sw = Stopwatch.StartNew();
                await lazy.Value;
                var firstAccessTime = sw.ElapsedMilliseconds;

                // Second access - should be immediate
                sw.Restart();
                await lazy.Value;
                var secondAccessTime = sw.ElapsedMilliseconds;

                Assert.True(firstAccessTime >= 1000, "First access should take at least 1000ms");
                Assert.True(secondAccessTime < 50, "Second access should be nearly immediate");
            }

            [Fact]
            public async Task Value_ConcurrentAccess_AllThreadsGetSameValue()
            {
                var random = new Random();
                var lazy = new AsyncLazy<int>(async () =>
                {
                    await Task.Delay(100);
                    return random.Next();
                });

                var tasks = new Task<int>[10];
                for (int i = 0; i < tasks.Length; i++)
                {
                    tasks[i] = Task.Run(async () => await lazy.Value);
                }

                var results = await Task.WhenAll(tasks);
                var firstValue = results[0];
                foreach (var result in results)
                {
                    Assert.Equal(firstValue, result);
                }
            }

            [Fact]
            public async Task Value_LongRunningTask_DoesNotBlockOtherThreads()
            {
                var initStarted = new TaskCompletionSource<bool>();
                var lazy = new AsyncLazy<int>(async () =>
                {
                    initStarted.SetResult(true);
                    await Task.Delay(1000);
                    return 42;
                });

                // Start the initialization
                var initTask = Task.Run(async () => await lazy.Value);

                // Wait for initialization to start
                await initStarted.Task;

                // Try to get value from other threads
                var tasks = new List<Task>();
                for (int i = 0; i < 5; i++)
                {
                    tasks.Add(Task.Run(async () =>
                    {
                        var value = await lazy.Value;
                        Assert.Equal(42, value);
                    }));
                }

                await Task.WhenAll(tasks.Concat(new[] { initTask }));
            }
        
    }
}



// --- File: MicroPlumberd.Tests\Unit\OptionTests.cs ---


using System.Text.Json;
using FluentAssertions;

namespace MicroPlumberd.Tests.Unit;

public class OptionTests
{
    record Foo(Option<int> SomeCoolValue);

    [Fact]
    public void CanSerializeDeserialize()
    {
        var options = new JsonSerializerOptions();
        options.Converters.Add(new OptionConverterFactory());

        var origin = new Foo(10);
        var json = JsonSerializer.Serialize(origin, options);

        var actual = JsonSerializer.Deserialize<Foo>(json, options);
        actual.Should().Be(origin);
    }
}


// --- File: MicroPlumberd.Tests\Unit\PositionTests.cs ---


using System.Globalization;
using System.Numerics;
using EventStore.Client;
using FluentAssertions;
using MicroPlumberd.Services;

using MicroPlumberd.Tests.Integration.Services;
using MicroPlumberd.Tests.Utils;
using ModelingEvolution.DirectConnect;
using ProtoBuf;
using System.Text.Json.Serialization;
using Xunit.Abstractions;

namespace MicroPlumberd.Tests.Unit;

[TestCategory("Unit")]
public class PositionTests
{
    [Fact]
    public void CanConvertFromToStreamPositionStart()
    {
        var sp = FromStream.Start.ToStreamPosition();
        sp.Should().Be(StreamPosition.Start);
    }
    [Fact]
    public void CanConvertFromToStreamPositionEnd()
    {
        var sp = FromStream.End.ToStreamPosition();
        sp.Should().Be(StreamPosition.End);
    }
    [Fact]
    public void CanConvertFromToStreamPositionCustom()
    {
        var sp = FromStream.After(StreamPosition.FromInt64(1000)).ToStreamPosition();
        sp.ToInt64().Should().Be(1000);
    }
}




// --- File: MicroPlumberd.Tests\Unit\ProcessManagerSourceGenerationTests.cs ---


using FluentAssertions;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Srv;
using MicroPlumberd.Tests.Utils;

namespace MicroPlumberd.Tests.Unit;

[TestCategory("Unit")]
public class ProcessManagerSourceGenerationTests
{
    [Fact]
    public void CommandTypes()
    {
        GetCommandTypes<XooProcessManager>().Should().BeEquivalentTo(ExpectedCommands());
    }


    [Fact]
    public void Types()
    {
        GetTypes<XooProcessManager>().Should().BeEquivalentTo(ExpectedTypes());
    }

    [Fact]
    public void StartType()
    {
        GetStartType<XooProcessManager>().Should().Be(typeof(FooCreated));
    }

    IEnumerable<Type> ExpectedTypes()
    {
        yield return typeof(FooCreated);
        yield return typeof(BooRefined);
        yield return typeof(CommandEnqueued<CreateBoo>);
    }

    private Type GetStartType<T>() where T : IProcessManager
    {
        return T.StartEvent;
    }
    private IEnumerable<Type> GetTypes<T>() where T : ITypeRegister
    {
        return T.Types;
    }
    private IEnumerable<Type> ExpectedCommands()
    {
        yield return typeof(CommandEnqueued<CreateBoo>);
        yield return typeof(CommandEnqueued<CreateLoo>);
    }
    private IEnumerable<Type> GetCommandTypes<T>() where T : IProcessManager
    {
        return T.CommandTypes;
    }
}


// --- File: MicroPlumberd.Tests\Utils\TestCategoryDiscoverer.cs ---


using Xunit.Abstractions;
using Xunit.Sdk;

namespace MicroPlumberd.Tests.Utils;

[TraitDiscoverer("MicroPlumberd.Tests.Utils.TestCategoryDiscoverer", "MicroPlumberd.Tests")]
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]
public class TestCategoryAttribute : Attribute, ITraitAttribute
{
    public string Category { get; }

    public TestCategoryAttribute(string category)
    {
        Category = category;
    }
}
public class TestCategoryDiscoverer : ITraitDiscoverer
{
    private const string Key = "Category";
    public IEnumerable<KeyValuePair<string, string>> GetTraits(IAttributeInfo traitAttribute)
    {
        string testCase;
        var attributeInfo = traitAttribute as ReflectionAttributeInfo;
        var testCaseAttribute = attributeInfo?.Attribute as TestCategoryAttribute;
        if (testCaseAttribute != null)
        {
            testCase = testCaseAttribute.Category;
        }
        else
        {
            var constructorArguments = traitAttribute.GetConstructorArguments().ToArray();
            testCase = constructorArguments[0].ToString();
        }
        yield return new KeyValuePair<string, string>(Key, testCase);
    }
}


// --- File: MicroPlumberd.Tests.App\CinemaDomain\ReservationModel.cs ---


using LiteDB;
using MicroPlumberd.Tests.App.Infrastructure;

namespace MicroPlumberd.Tests.App.CinemaDomain;

[OutputStream("ReservationModel_v1")]
[EventHandler]
public partial class ReservationModel(InMemoryAssertionDb assertionModelStore)
{
    public InMemoryAssertionDb ModelStore => assertionModelStore;
    public bool EventHandled{ get; set; } = false;
    private async Task Given(Metadata m, TicketReserved ev)
    {
        EventHandled = true;
        assertionModelStore.Add(m, ev);
        await Task.Delay(0);
    }
   
}



[OutputStream(DbReservationModel.MODEL_NAME)]
[EventHandler]
public partial class DbReservationModel(LiteDatabase db)
{
    internal const string MODEL_VER = "_v2";
    internal const string MODEL_NAME = $"Reservations{MODEL_VER}";
    public ILiteCollection<Reservation> Reservations { get; } = db.Reservations();

    private async Task Given(Metadata m, TicketReserved ev)
    {
        Reservations.Insert(new Reservation() { RoomName = ev.RoomName, MovieName = ev.MovieName });
        
    }
}

public static class DbExtensions
{
    public static ILiteCollection<Reservation> Reservations(this LiteDatabase db) => db.GetCollection<Reservation>(DbReservationModel.MODEL_NAME);
}
public record Reservation
{
    public ObjectId ReservationId { get; set; }
    public string RoomName { get; set; }
    public string MovieName { get; set; }
}


// --- File: MicroPlumberd.Tests.App\CinemaDomain\RoomOccupancy.cs ---


namespace MicroPlumberd.Tests.App.CinemaDomain;

[EventHandler]
public partial class RoomOccupancy
{

    private async Task Given(Metadata m, TicketReserved ev)
    {

    }
}


// --- File: MicroPlumberd.Tests.App\CinemaDomain\TicketProjection.cs ---


namespace MicroPlumberd.Tests.App.CinemaDomain;

[EventHandler]
public partial class TicketProjection(IPlumber plumber)
{
    private async Task Given(Metadata m, TicketReserved ev)
    {
        await plumber.AppendLink($"RoomOccupancy-{ev.RoomName}", m);
    }
}




// --- File: MicroPlumberd.Tests.App\CinemaDomain\TicketReserved.cs ---


namespace MicroPlumberd.Tests.App.CinemaDomain;

[OutputStream("ReservationStream")]
public record TicketReserved { 
    public string? MovieName { get; init; } 
    public string? RoomName { get; init; }
}



// --- File: MicroPlumberd.Tests.App\CinemaDomain\TicketReservedCategory.cs ---


namespace MicroPlumberd.Tests.App.CinemaDomain;

record TicketReservedCategory;


// --- File: MicroPlumberd.Tests.App\FooDomain\BusinessFault.cs ---


using ProtoBuf;

namespace MicroPlumberd.Tests.App.Domain;

[ProtoContract]
public record BusinessFault { [ProtoMember(1)] public string? Name { get; init; } }


// --- File: MicroPlumberd.Tests.App\FooDomain\BusinessFaultException.cs ---


using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.Tests.App.Domain;

public class BusinessFaultException : FaultException<BusinessFault>
{
    public BusinessFaultException(string name) : base(new BusinessFault() { Name = name }) { }
}


// --- File: MicroPlumberd.Tests.App\FooDomain\FooAggregate.cs ---


using System.Data.SqlTypes;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using MicroPlumberd.Encryption;
using MicroPlumberd.Services;
using MicroPlumberd.Services.Uniqueness;
using ModelingEvolution.DirectConnect;
using ProtoBuf;

namespace MicroPlumberd.Tests.App.Domain;

public record FooEntityState {
    [JsonIgnore]
    public Guid Id { get; set; } = Guid.NewGuid();
    public string Name { get; set; }
    [JsonIgnore]
    public long Version { get; set; } = -1;
}

[Aggregate]
[ThrowsFaultException<BusinessFaultException>()]
public partial class FooAggregate(Guid id) : AggregateBase<Guid,FooAggregate.FooState>(id)
{
    public new FooState State => base.State;
    public record FooState { public string? Name { get; set; } };

    
    private static FooState Given(FooState state, FooCreated ev) => state with { Name = ev.Name };

    private static FooState Given(FooState state, FooRefined ev) => state with { Name =ev.Name };
    public static FooAggregate Open(string msg, Guid id)
    {
        var r = FooAggregate.Empty(id);
        r.AppendPendingChange(new FooCreated() { Name = msg });
        return r;
    }

    public static FooAggregate Open(string msg) => Open(msg, Guid.NewGuid());

    public void Refine(string msg)
    {
        if (msg == "error") throw new BusinessFaultException("Houston we have a problem!");
        AppendPendingChange(new FooRefined() { Name = msg });
    }
}
[Aggregate(SnapshotEvery = 50)]
public partial class BooAggregate(Guid id) : AggregateBase<Guid, BooAggregate.BooState>(id)
{
    internal new BooState State => base.State;
    [ProtoContract] public record BooState { [ProtoMember(1)] public string? Name { get; set; } };
    private static BooState Given(BooState state, BooCreated ev) => state with { Name = ev.Name };
    private static BooState Given(BooState state, BooRefined ev) => state with { Name = ev.Name };
    public static BooAggregate Open(string msg)
    {
        var r = BooAggregate.Empty(msg.ToGuid());
        r.AppendPendingChange(new BooCreated() { Name = msg });
        return r;
    }

    public void Refine(string msg) => AppendPendingChange(new BooRefined() { Name = msg });
}


public record FooCreated { [Unique<FooCategory>] public string? Name { get; set; }  }
public record FooRefined { public string? Name { get; set; } }

[Unique<BooCategory>()]
[ProtoContract]
public class BooCreated { [ProtoMember(1)] public string? Name { get; set; } }

[Unique<BooCategory>()]
[ProtoContract]
public class BooRefined { [ProtoMember(1)] public string? Name { get; set; } }

record FooCategory;
record BooCategory(string Name) : IUniqueFrom<BooCategory, BooCreated>, IUniqueFrom<BooCategory, BooRefined>
{
    public static BooCategory From(BooCreated x) => new(x.Name);
    public static BooCategory From(BooRefined x) => new(x.Name);
}


// --- File: MicroPlumberd.Tests.App\FooDomain\FooModel.cs ---


using MicroPlumberd.Tests.App.Infrastructure;

namespace MicroPlumberd.Tests.App.Domain;

[OutputStream("FooModel_v1")]
[EventHandler]
public partial class FooModel(InMemoryAssertionDb assertionDb)
{
    public InMemoryAssertionDb AssertionDb => assertionDb;
    public async Task<string?> FindById(Guid id) => (await assertionDb.FindLast<FooCreated>(id))?.Name;
    private async Task Given(Metadata m, FooCreated ev)
    {
        assertionDb.Add(m,ev);
         await Task.Delay(0);
    }
    private async Task Given(Metadata m, FooRefined ev)
    {
        assertionDb.Add(m, ev);
        await Task.Delay(0);
    }
}


[EventHandler]
public partial class MasterModel(DimentionLookupModel lookup)
{
    public record MasterRecord(Guid Id, string Name, string DependencyName, Guid DependencyId);
    public readonly Dictionary<Guid, MasterRecord> Index = new();
    public readonly List<Metadata> Metadatas = new();
    public readonly List<object> Events = new();
   
    private async Task Given(Metadata m, MasterRecordCreated ev)
    {
        Index[m.Id] = new MasterRecord(m.Id, ev.Name, lookup.Index[ev.DependencyId], ev.DependencyId);
        Metadatas.Add(m);
        Events.Add(ev);
        await Task.Delay(0);
    }
}

public class DimentionCreated
{
    public string Name { get; init; }
}
public record MasterRecordCreated
{
    public string Name { get; init; }
    public Guid DependencyId { get; init; }
}

[EventHandler]
public partial class DimentionLookupModel
{
    public readonly Dictionary<Guid, string> Index = new();
    
    private async Task Given(Metadata m, DimentionCreated ev)
    {
        Index.Add(m.Id, ev.Name!);
        await Task.Delay(0);
    }
   
}



// --- File: MicroPlumberd.Tests.App\FooDomain\FooProcessor.cs ---


namespace MicroPlumberd.Tests.App.Domain;

[EventHandler]
public partial class FooProcessor(IPlumber plumber)
{
    private async Task Given(Metadata m, FooRefined ev)
    {
        var agg = FooAggregate.Open(ev.Name + "new");
        await plumber.SaveNew(agg);
    }
}


// --- File: MicroPlumberd.Tests.App\FooDomain\XooProcessManager.cs ---


using MicroPlumberd.Tests.App.Srv;
using ModelingEvolution.DirectConnect;

namespace MicroPlumberd.Tests.App.Domain;

[ProcessManager]
public partial class XooProcessManager 
{
    public async Task<ICommandRequest<CreateBoo>> StartWhen(Metadata m, FooCreated ev)
    {
        return CommandRequest.Create("Hello".ToGuid(), new CreateBoo());
    }
    private async Task<ICommandRequest<CreateLoo>> When(Metadata m, BooRefined ev)
    {
        return CommandRequest.Create(Guid.NewGuid(), new CreateLoo());
    }

    private async Task Given(Metadata m, FooCreated ev)
    {
        // This method is used to rebuild the state;
        // In this example, It is called only When method "When(.., BooUpdated)" is executed.
        // Because the state of the FooProcessManager needs to be rebuilt.
        Console.WriteLine("Given-FooCreated");
    }

    private async Task Given(Metadata m, CommandEnqueued<CreateBoo> ev)
    {
        // This method is optional; It is used to capture the fact, that command was sent to the queue.
        Console.WriteLine("Given-CommandEnqueued<CreateLoo>");
    }


}


// --- File: MicroPlumberd.Tests.App\Infrastructure\InMemoryAssertionDb.cs ---


using System.Collections.Concurrent;
using LiteDB;

namespace MicroPlumberd.Tests.App.Infrastructure;

/// <summary>
/// This class is only for acting aa a mock.
/// </summary>
public class InMemoryAssertionDb
{
    public record Item(Metadata Metadata, object Event);

    public readonly SortedList<int, Item> Index = new();
    public readonly ConcurrentDictionary<Guid, List<Item>> IndexById = new();

    private int _i = -1;
    public void Add(Metadata m, object evt)
    {
        var i = new Item(m, evt);
        Index.Add(Interlocked.Increment(ref _i), i);
        IndexById.GetOrAdd(m.Id, x => new()).Add(i);
    }

    public async Task<T?> FindLast<T>(Guid id)
    {
        for (int i = 0; i < 100; i++)
            if (!IndexById.ContainsKey(id))
                await Task.Delay(100);
        return IndexById[id]
            .Where(x => x.Event is T)
            .Select(x => x.Event)
            .OfType<T>()
            .Reverse()
            .FirstOrDefault();
    }
}

public class LiteDbFactory
{
    private static int _id = 0;

    public static LiteDatabase Get()
    {
        string fileName = $"./test_{Interlocked.Increment(ref _id)}.db";
        if(File.Exists(fileName))
            File.Delete(fileName);
        return new LiteDatabase(fileName);
    }
}


// --- File: MicroPlumberd.Tests.App\Srv\BooCommandHandler.cs ---


using System.Diagnostics;
using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;

using BooAggregate = MicroPlumberd.Tests.App.Domain.BooAggregate;

namespace MicroPlumberd.Tests.App.Srv;

[CommandHandler]
public partial class BooCommandHandler(IPlumber plumber)
{
    public async Task Handle(Guid id, CreateBoo cmd)
    {
        if (cmd.Name == "error")
            throw new BusinessFaultException("Boo");

        var agg = BooAggregate.Open(cmd.Name!);

        await plumber.SaveNew(agg);
        Debug.WriteLine("BooCreated");
    }
    public async Task Handle(Guid id, ValidateBoo cmd)
    {
        if (cmd.Name == "error")
            throw new BusinessFaultException("Boo");

        var agg = BooAggregate.Open(cmd.Name!);

        await plumber.SaveNew(agg);
        Debug.WriteLine("BooCreated");
    }

    [ThrowsFaultException<BusinessFault>]
    public async Task Handle(Guid id, RefineBoo cmd)
    {
        if (cmd.Name == "error")
            throw new BusinessFaultException("Boo");

        var agg = await plumber.Get<BooAggregate>(id);
        agg.Refine(cmd.Name!);

        await plumber.SaveChanges(agg);
        Debug.WriteLine("BooChanged");
    }

}


// --- File: MicroPlumberd.Tests.App\Srv\ChangeFoo.cs ---


using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;
using ProtoBuf;

namespace MicroPlumberd.Tests.App.Srv;

[ProtoContract]
[ThrowsFaultException<BusinessFault>]
public class RefineFoo : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}
[ProtoContract]
[ThrowsFaultException<BusinessFault>]
public class RefineBoo : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Tests.App\Srv\CreateFoo.cs ---


using System.ComponentModel.DataAnnotations;
using MicroPlumberd.DirectConnect;
using MicroPlumberd.Encryption;
using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;
using ProtoBuf;

namespace MicroPlumberd.Tests.App.Srv;



[ProtoContract]
[ThrowsFaultException<BusinessFault>]
[Returns<HandlerOperationStatus>]
public class CreateFoo : IId<Guid>
{
    [ProtoMember(2)]
    [Required]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();

    [ProtoMember(3)]
    public int TimeoutMs { get; set; }
}
[ProtoContract]
[ThrowsFaultException<BusinessFault>]
[Returns<HandlerOperationStatus>]
public class CreateStrFoo 
{
    [ProtoMember(2)]
    [Required]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}


public class ValidateBoo : IId<Guid>
{
    [Required]
    [Length(5, 10)]    
    public string? Name { get; set; }
    public Guid Id { get; set; } = Guid.NewGuid();
}

[ProtoContract]
[Returns<HandlerOperationStatus>]
public class CreateBoo : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}

[ProtoContract]
[Returns<HandlerOperationStatus>]
public class CreateLoo : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();

}

public class CreateSecret
{
    public SecretObject<string> Password { get; set; }
}
[OutputStream("Password")]
public class SecretCreated
{
    public SecretObject<string> Password { get; set; }
}


// --- File: MicroPlumberd.Tests.App\Srv\FooCommandHandler.cs ---


using MicroPlumberd.DirectConnect;
using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;

using FooAggregate = MicroPlumberd.Tests.App.Domain.FooAggregate;

namespace MicroPlumberd.Tests.App.Srv;

[CommandHandler]
public partial class FooCommandHandler(IPlumber plumber)
{
    public async Task Handle(Guid id, CreateFoo cmd)
    {
        if (cmd.Name == "error")
            throw new BusinessFaultException("Foo");

        var agg = FooAggregate.Open(cmd.Name, id);

        if (cmd.TimeoutMs > 0)
            await Task.Delay(cmd.TimeoutMs);
        
        await plumber.SaveNew(agg);
    }


    [ThrowsFaultException<BusinessFault>]
    public async Task<HandlerOperationStatus> Handle(Guid id, RefineFoo cmd)
    {
        var agg = await plumber.Get<FooAggregate>(id);
        agg.Refine(cmd.Name!);

        await plumber.SaveChanges(agg);
        return HandlerOperationStatus.Ok();
    }
}
[CommandHandler]
public partial class SecretCommandHandler(IPlumber plumber)
{
    public async Task Handle(Guid id, CreateSecret cmd)
    {
        await plumber.AppendEvent(new SecretCreated() { Password = cmd.Password }, id);
    }

}


// --- File: MicroPlumberd.Tests.App\Srv\StrCommandHandler.cs ---


using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;
using System.Text.Json.Serialization;

namespace MicroPlumberd.Tests.App.Srv;

[CommandHandler]
public partial class StrCommandHandler(IPlumber plumber)
{
    public async Task Handle(string id, CreateStrFoo cmd)
    {
        if (cmd.Name == "error")
            throw new BusinessFaultException("Foo");

        
        await plumber.AppendState(new StrEntityState() { Name = cmd.Name, Id = id });
    }
}
public record StrEntityState
{
    [JsonIgnore]
    public string Id { get; set; } 
    public string Name { get; set; }
    [JsonIgnore]
    public long Version { get; set; } = -1;
}


// --- File: MicroPlumberd.Tests.App\WorkflowDomain\Class1.cs ---


using MicroPlumberd.DirectConnect;
using MicroPlumberd.Services;
using MicroPlumberd.Tests.App.Domain;
using ProtoBuf;

namespace MicroPlumberd.Tests.App.WorkflowDomain;

[ProtoContract]
[ThrowsFaultException<BusinessFault>]
[Returns<HandlerOperationStatus>]
public class StartWorkflow : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}

[ProtoContract]
[ThrowsFaultException<BusinessFault>]
[Returns<HandlerOperationStatus>]
public class CompleteWorkflow : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}

[ProtoContract]
[OutputStream("Workflow")]
public class WorkflowCompleted : IId<Guid>
{
    [ProtoMember(2)]
    public string? Name { get; set; }
    [ProtoMember(1)]
    public Guid Id { get; set; } = Guid.NewGuid();
}


// --- File: MicroPlumberd.Tests.App\WorkflowDomain\CompleteWorkflowHandler.cs ---


using System.Diagnostics;
using MicroPlumberd.DirectConnect;
using MicroPlumberd.Services;

namespace MicroPlumberd.Tests.App.WorkflowDomain;

[CommandHandler]
public partial class CompleteWorkflowHandler(IPlumber pl)
{
    public async Task Handle(Guid id, CompleteWorkflow cmd)
    {
        Debug.WriteLine("===> Complete workflow returned.");
        await pl.AppendEvent(new WorkflowCompleted(), id);
    }
}


// --- File: MicroPlumberd.Tests.App\WorkflowDomain\StartWorkflowHandler.cs ---


using System.Diagnostics;
using MicroPlumberd.DirectConnect;
using MicroPlumberd.Services;

namespace MicroPlumberd.Tests.App.WorkflowDomain;

[CommandHandler]
public partial class StartWorkflowHandler(ICommandBus bus)
{
    public async Task Handle(Guid id, StartWorkflow cmd)
    {
        Debug.WriteLine("===> Start workflow handler begin invocation...");
        await bus.SendAsync(id, new CompleteWorkflow { Name = cmd.Name });
        Debug.WriteLine("===> Start workflow handler Invoked");
    }
}


// --- File: MicroPlumberd.Tests.App.Dsl\Domain\FooAggregateSteps.cs ---


using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using FluentAssertions;
using MicroPlumberd.Tests.App.Domain;
using TechTalk.SpecFlow;

namespace MicroPlumberd.Tests.App.Dsl.Domain;


public partial class FooAggregateSteps
{

    
    // TODO
    [Scope(Tag = "Aggregate")]
    [When(@"I [C|c]hange Foo with msg:\s*'(.*)'")]
    public async Task WhenIChangeFooWithMsg(string mth)
    {
        await _aggregateSpecs.When(x => x.Refine(mth));
    }

   
    // TODO
    [Then(@"I expect business fault exception:")]
    public async Task ThenIExpectBusinessFaultException(object s)
    {
        var errorData = _aggregateSpecs.ArgumentProvider.Recognize<BusinessFault>(s);
        await _aggregateSpecs.ExpectedThrown<FaultException<BusinessFault>>(x => x.Data.Equals(errorData));
    }

}


// --- File: MicroPlumberd.Tests.App.Dsl\AppHost.cs ---


using BoDi;
using MicroPlumberd.Services;
using MicroPlumberd.Testing;
using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Infrastructure;
using MicroPlumberd.Tests.App.Srv;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TechTalk.SpecFlow;
using Xunit.Abstractions;

[assembly: DslFromAssembly("MicroPlumberd.Tests.App")]

[Binding]
public class AppSteps
{
    private readonly AppStepsContext _context;
    

    public AppSteps(AppStepsContext context)
    {
        _context = context;
    }
    


    [Given(@"the Foo App is up and running")]
    public async Task GivenTheAppIsUpAndRunning()
    {
        _context.EventStore = await EventStoreServer.Create().StartInDocker();

        var testAppHost = new TestAppHost(_context.Output)
            .Configure(x => x
                .AddPlumberd(_context.EventStore.GetEventStoreSettings())
                .AddCommandHandler<FooCommandHandler>()
                .AddSingleton<InMemoryAssertionDb>()
                .AddEventHandler<FooModel>());
        _context.App = testAppHost.Host;

        await testAppHost.StartAsync();
    }

}
public partial class TestAppHost : IDisposable
{
    public IHost Host { get; private set; }
    private readonly ITestOutputHelper logger;

    public TestAppHost(ITestOutputHelper logger)
    {
        this.logger = logger;
    }

    public virtual TestAppHost Configure(Action<IServiceCollection>? configure = null)
    {
        Host = Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()
            .ConfigureLogging(x => x.SetMinimumLevel(LogLevel.Trace)
                .AddDebug()
                .AddXunit(logger))
            .ConfigureServices(services =>
            {
                configure(services);
            })
            .Build();

        return this;
    }

    public void Dispose()
    {
        Host?.Dispose();
    }


    public async Task<IServiceProvider> StartAsync()
    {
        await Host.StartAsync();

        var hc = Host.Services.GetRequiredService<StartupHealthCheck>();
        while (true)
        {
            var ret = await hc.CheckHealthAsync(null, default);
            if (ret.Status == HealthStatus.Healthy) break;
            await Task.Delay(1000);
        }
        
        return Host.Services;
    }
}


// --- File: MicroPlumberd.Tests.App.Dsl\AssertionExtensions.cs ---


namespace MicroPlumberd.Tests.App.Dsl;

public static class AssertionExtensions
{
    public static T State<T>(this IStatefull<T> aggregate)
    {
        return aggregate.State;
    }
}


// --- File: MicroPlumberd.Tests.App.Dsl\CommandHandlerSteps.cs ---


using MicroPlumberd.Tests.App.Domain;
using MicroPlumberd.Tests.App.Srv;
using ModelingEvolution.DirectConnect;
using TechTalk.SpecFlow;

namespace MicroPlumberd.Tests.App.Dsl;

[Binding]
public partial class CommandHandlerSteps(AppStepsContext context)
{
    private readonly CommandHandlerSpecs<FooCommandHandler> _specs = context.CommandHandlerSpecs<FooCommandHandler>();

    [When(@"I change foo '(.*)' with:")]
    public async Task WhenIChangeFooWith(string id, object arg)
    {
        var cmd = context.SpecsRoot.ArgumentProvider.Recognize<RefineFoo>(arg);
        var recipient = Guid.TryParse(id, out var g) ? g : id.ToGuid();
        await _specs.When(recipient, cmd);
    }
    [When(@"I change foo with:")]
    public async Task WhenIChangeFooWith(object arg)
    {
        var cmd = context.SpecsRoot.ArgumentProvider.Recognize<RefineFoo>(arg);
        await _specs.When(cmd);
    }

    
}


// --- File: MicroPlumberd.Tests.App.Dsl\FooModelSteps.cs ---


using FluentAssertions;
using MicroPlumberd.Tests.App.Domain;
using ModelingEvolution.DirectConnect;
using TechTalk.SpecFlow;

namespace MicroPlumberd.Tests.App.Dsl;

[Binding]
public partial class FooModelSteps(AppStepsContext context)
{
    [When(@"I find by id '(.*)'")]
    public async Task WhenIFindById(string id)
    {
        Guid arg_1 = Guid.TryParse(id, out var r) ? r : id.ToGuid();
        await context.ModelSpecs<FooModel>().When(x => x.FindById(arg_1));
    }

    [Then(@"I get '(.*)'")]
    public void ThenIGet(string arg)
    {
        context.ModelSpecs<FooModel>().ThenQueryResult(x => x.Should().Be(arg));
    }
}


// Processed 530 files on 03/03/2025 13:06:59
